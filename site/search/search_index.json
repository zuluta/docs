{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inicio","text":""},{"location":"devcamp/","title":"DevCamp","text":"DevCamp <p>PT Full Stack Development with JavaScript, Python, React</p> <p>\u00cdNDICE DE CONTENIDOS</p> <ol> <li>Checkpoint 06</li> <li>Checkpoint 07</li> <li>Checkpoint 08</li> </ol> <p> </p>"},{"location":"devcamp/checkpoint-06/","title":"Checkpoint 06","text":""},{"location":"devcamp/checkpoint-06/#documentacion-python","title":"Documentaci\u00f3n Python","text":"<p>\u00cdNDICE CHECKPOINT 06</p> <ol> <li>Introducci\u00f3n al uso de clases</li> <li>\u00bfQu\u00e9 es un m\u00e9todo dunder?</li> <li>\u00bfQu\u00e9 es un decorador?</li> <li>\u00bfQu\u00e9 es el polimorfismo?</li> <li>\u00bfQu\u00e9 es una API?</li> <li>\u00bfEs MongoDB una base de datos SQL o NoSQL? </li> </ol>"},{"location":"devcamp/checkpoint-06/introduccion-clases-py/","title":"1. Introducci\u00f3n al uso de clases","text":"<p>Python es un lenguaje orientado a objetos, no es necesario hacer uso de ellas para poder crear un programa. De hecho, hemos estado trabajando hasta ahora sin hacer menci\u00f3n a ellas ni emplearlas.</p> <p>Hasta ahora, hemos construido aplicaciones peque\u00f1as de manera secuenciada y desorganizada. Esto no significa que lo hayamos hecho mal, lo que quiero decir es, que cuando empecemos a crear aplicaciones di\u00e1micas y sean mas complejas, necesitaremos mejorar la estructura del c\u00f3digo, la organizaci\u00f3n y crear c\u00f3digo reutilizable y facilitar su mantenimiento.</p> <p></p>"},{"location":"devcamp/checkpoint-06/introduccion-clases-py/#11-clase-estatica","title":"1.1. Clase est\u00e1tica:","text":"<p>PRECAUCI\u00d3N</p> <p>Hay que evitar el mal uso de las clases, en este ejemplo, vemos que las variables no son reutilizables, tampoco podemos pasarle argumentos.</p> <p></p> <p> </p> <p>C\u00f3digo Python \ud83d\udc47</p> <pre><code>class Cliente:\n\n    dni = '88521596P'\n    nombre = 'Luis'\n    apellido = 'Mendoza'\n\n    def __init__(self):\n        print(f'DNI: {self.dni}\\nNombre: {self.nombre}\\nApellido: {self.apellido}')\n\n\nCliente()\n\n# salida:\n    # DNI: 88521596P\n    # Nombre: Luis\n    # Apellido: Mendoza\n</code></pre> <ul> <li>\u274c Estructurado.</li> <li>\u274c Organizado.</li> <li>\u274c Escalable.</li> <li>\u274c Reutilizable. </li> </ul>"},{"location":"devcamp/checkpoint-06/introduccion-clases-py/#12-clase-dinamica","title":"1.2. Clase din\u00e1mica:","text":"<p>La manera recomendada de contruir aplicaci\u00f3nes con c\u00f3digo reutilizable y organizada, es con el uso de las clases. Al principio, es normal que te sientas perdido con todo esto de las clases, pero no te preocupes, todos hemos pasado por esta etapa.</p> <p>Para crear una clase, vamos a emplear la palabra reservada <code>class</code> seguido de un nombre escrito en PascalCase, primera letra de cada palabra se escribe en may\u00fascula, y sin guiones bajos. Sabemos que las clases pueden contener funciones, a las que llamamos m\u00e9todos. Una clase tambi\u00e9n puede contener variables, a las que se conoce con el nombre de atributos. Para crear atributos, primero definimos un m\u00e9todo especial llamado <code>__init__()</code>, que es invocado por Python autom\u00e1ticamente siempre que se crea una instancia de la clase (conocido tambi\u00e9n como constructor o inicializador).</p> <p>Los clientes que vayamos a crear, no tendr\u00e1n el mismo <code>dni</code>, <code>nombre</code> ni <code>apellido</code>. Por ello ser\u00eda conveniente permitir que, al definir una instancia, se pase como argumento el dni del cliente y \u00e9ste se almacene en el atributo <code>self.dni</code>, nombre del cliente en el atributo <code>self.nombre</code> y apellido del cliente en el atributo <code>self.apellido</code>.</p> <p></p> <p>IMPORTANTE</p> <p>Dentro de la clase, las variables pasan a llamarse atributos, el primer atributo obligatorio siempre sera <code>self</code>, las funciones pasan a llamarse m\u00e9todos, nos permite pasarle argumentos y eso hace que el c\u00f3digo sea reutilizable. Estas son las razones por el cual se crearon las clases en programaci\u00f3n.</p> <p></p> <p> </p> <p>C\u00f3digo Python \ud83d\udc47</p> <p><pre><code>class Cliente:\n    def __init__(self, dni, nombre, apellido):\n        self.dni = dni\n        self.nombre = nombre\n        self.apellido = apellido\n\n        print(f'DNI: {self.dni}\\nNombre: {self.nombre}\\nApellido: {self.apellido}')\n\nCliente('88521596P', 'Luis', 'Mendoza')\nCliente('96452178K', 'Maribel', '')\n\n# salida:\n    # DNI: 88521596P\n    # Nombre: Luis\n    # Apellido: Mendoza\n    # DNI: 96452178K\n    # Nombre: Maribel\n    # Apellido:\n</code></pre> </p>"},{"location":"devcamp/checkpoint-06/introduccion-clases-py/#13-crear-objetos-con-clase","title":"1.3. Crear objetos con clase:","text":"<p>TIP</p> <p>Antes del auge de la POO, la programaci\u00f3n estaba dominada por el paradigma procedimental. Este enfoque estructuraba los programas como una serie de instrucciones secuenciales y depend\u00eda en gran medida de funciones y datos globales. Si bien este modelo era efectivo para problemas simples, se volvi\u00f3 dif\u00edcil de manejar a medida que los sistemas se hicieron m\u00e1s complejos debido a la falta de separaci\u00f3n clara entre los datos y las operaciones.</p> <p></p> <p>Python es un lenguaje multiparadigma:</p> <ul> <li>Soporta la programaci\u00f3n imperativa y funcional.</li> <li>Soporta la programaci\u00f3n orientada a objetos (POO). </li> </ul> <p>En este ejemplo, vamos a crear 2 objetos que se van a llamar <code>cli_1</code> y <code>cli_2</code>. <code>cli_1</code> va tener DNI, Nombre, Apellido y el <code>cli_2</code> va tener solamente DNI, Nombre. La ventaja de poder crear estos objetos de una forma tan simplificada, es impresionante.</p> <p></p> <p>C\u00f3digo Python \ud83d\udc47</p> <p><pre><code>class Cliente:\n\n    def __init__(self, dni, nombre, apellido):\n        self.dni = dni\n        self.nombre = nombre\n        self.apellido = apellido\n\ncli_1 = Cliente('88521596P', 'Luis', 'Mendoza')\ncli_2 = Cliente('96452178K', 'Maribel', '')\n\nprint(f'DNI: {cli_1.dni}\\nNombre: {cli_1.nombre}\\nApelllido: {cli_1.apellido}')\nprint(f'DNI: {cli_2.dni}\\nNombre: {cli_2.nombre}')\n\n# salida:\n    # DNI: 88521596P\n    # Nombre: Luis\n    # Apellido: Mendoza\n    # DNI: 96452178K\n    # Nombre: Maribel\n    # Apellido:\n</code></pre> </p>"},{"location":"devcamp/checkpoint-06/introduccion-clases-py/#14-metodos-dentro-de-una-clase","title":"1.4. M\u00e9todos dentro de una clase:","text":"<p>En este ejemplo, vamos a crear un m\u00e9todo normal llamado <code>cuenta</code>, el primer atributo obligatorio se llama <code>self</code>, seguido pondremos nuestros atributos opcionales separadas por una <code>,</code>coma y cerramos la linea con <code>:</code> dos puntos.</p> <p>Dentro del m\u00e9todo, indentamos con 4 espacios para empezar a escribir nuestro c\u00f3digo de ejecuci\u00f3n. En este caso, vamos a emplear <code>return</code> para retornar un mensaje que ponga Cuenta: El cliente ????????? tiene cuenta. Con esto, ya tendriamos nuestra clase completado.</p> <p>Utilizaremos los mismos objetos <code>cli_1</code> y <code>cli_2</code> creados en el ejercicio anterior. La forma de acceder a ello es, llamamos primero al objeto <code>cli_1</code> y ponemos un <code>.</code> punto y llamamos al metodo <code>cuenta</code>. Al tratarse de un m\u00e9todo, como toda funci\u00f3n, devemos cerrarla con <code>()</code>parentesis. El c\u00f3digo quedaria de la siguiente manera <code>cli_1.cuenta()</code></p> <p>Finalizamos el ejemplo con la funci\u00f3n <code>print()</code> para imprimir en pantalla lo que hemos programado en esta clase, <code>print(cli_1.cuenta())</code> y <code>print(cli_2.cuenta())</code></p> <p></p> <p>C\u00f3digo Python \ud83d\udc47</p> <p><pre><code>class Cliente:\n\n    def __init__(self, dni, nombre, apellido):\n        self.dni = dni\n        self.nombre = nombre\n        self.apellido = apellido\n\n    def cuenta(self):\n        return f'Cuenta: El cliente {self.dni} tiene cuenta'\n\ncli_1 = Cliente('88521596P', 'Luis', 'Mendoza')\ncli_2 = Cliente('96452178K', 'Maribel', '')\n\nprint(cli_1.cuenta())\nprint(cli_2.cuenta())\n\n# salida:\n    # Cuenta: El cliente 88521596P tiene cuenta\n    # Cuenta: El cliente 96452178K tiene cuenta\n</code></pre> </p>"},{"location":"devcamp/checkpoint-06/introduccion-clases-py/#15-estructura-basica-de-una-clase","title":"1.5. Estructura b\u00e1sica de una clase:","text":"<p>Llegados aqui, aprenderemos los conceptos b\u00e1sicos que construyen una clase. Trata de leer el c\u00f3digo y entender lo que sucede en cada paso.</p> <p></p> <p>Descripci\u00f3n de conceptos:</p> <ol> <li><code>class</code> Declara una clase.</li> <li><code>Cliente</code> Asigna un nombre a la clase, siempre en PascalCase y sin guiones bajos.</li> <li><code>password = '1234'</code> Declara una variable de clase.</li> <li><code>def</code> Declara un m\u00e9todo.</li> <li><code>__init__</code> Lleva dos guiones al principio y al final del nombre, se le conoce como m\u00e9todo dunder, especial o m\u00e1gico.</li> <li><code>self</code> Es el primer atributo obligatorio siempre.</li> <li><code>dni</code>,<code>nombre</code>, <code>apellido</code> Se llaman atributos del m\u00e9todo y van separados por una <code>,</code> coma.</li> <li><code>self.dni</code> Declara una variable de instancia.</li> <li><code>dni</code> Guarda el valor de la variable de instancia.</li> <li><code>cuenta</code> Asigna un nombre al m\u00e9todo.</li> <li><code>self.password</code> Hace referencia a la variable de instancia para retornar su valor.</li> <li><code>cli_1</code> Crea un objeto.</li> <li><code>Cliente</code> Invoca a la clase desde cualquier parte de la aplicaci\u00f3n.</li> <li><code>'88521596P'</code>, <code>'Luis'</code>, <code>'Mendoza'</code> Se llaman argumentos.</li> <li><code>Print</code> Es una funci\u00f3n para imprimir en pantalla.</li> <li><code>cli_1.cuenta</code> hace referencia al objeto <code>cli_1</code> para acceder a la clase y ejecutar el m\u00e9todo <code>cuenta</code>.</li> <li>Visualizamos los datos en la pantalla.</li> </ol> <p></p> <p>C\u00f3digo Python \ud83d\udc47</p> <pre><code>class Cliente:\n    password = '1234'\n\n    def __init__(self, dni, nombre, apellido):\n        self.dni = dni\n        self.nombre = nombre\n        self.apellido = apellido\n\n    def cuenta(self):\n        return f'{self.nombre} {self.apellido}:\\nUsuario: {self.dni}\\nContrase\u00f1a: {self.password}'\n\ncli_1 = Cliente('88521596P', 'Luis', 'Mendoza')\ncli_2 = Cliente('96452178K', 'Maribel', 'Garcia')\n\nprint(cli_1.cuenta())\nprint(cli_2.cuenta())\n\n# salida:\n    # Luis Mendoza:\n    # Usuario: 88521596P\n    # Contrase\u00f1a: 1234\n    # Maribel Garcia:\n    # Usuario: 96452178K\n    # Contrase\u00f1a: 1234\n</code></pre> <ul> <li>\u2705 Facil de estructurar.</li> <li>\u2705 Facil de organizar.</li> <li>\u2705 Facil de leer.</li> <li>\u2705 Facil de escalar.</li> <li>\u2705 C\u00f3digo reutilizable.</li> </ul> <p>IMPORTANTE</p> <p>Las variables de clase son \u00fatiles cuando queremos utilizar un mismo valor en cualquiera de los metodos. Son accesibles desde cualquier m\u00e9todo. Dentro de las clases, no se recomienda el uso de las condicionales. Su uso est\u00e1 enfocado en gestionar datos y m\u00e9todos.</p> <p>\ud83d\udcac Es fundamental entender bien la estructura y la l\u00f3gica de las clases para poder seguir avanzando y evitar estancamientos en el futuro.  </p>"},{"location":"devcamp/checkpoint-06/metodo-dunder-py/","title":"2. \u00bfQu\u00e9 es un m\u00e9todo dunder?","text":"<p>En programaci\u00f3n orientada a objetos, los m\u00e9todos dunder o m\u00e9todos m\u00e1gicos son funciones especiales que permiten definir comportamientos espec\u00edficos para las clases. Estos m\u00e9todos se llaman \u201cm\u00e1gicos\u201d porque su nombre comienza y termina con dos guiones bajos (__).</p> <p>TIP</p> <p>Los m\u00e9todos m\u00e1gicos son una herramienta poderosa que permite definir comportamientos espec\u00edficos para las clases en Python. Utilizarlos de forma adecuada puede hacer que nuestro c\u00f3digo sea m\u00e1s f\u00e1cil de entender y mantener.</p> <p></p>"},{"location":"devcamp/checkpoint-06/metodo-dunder-py/#21-tipos-de-metodos-dunder","title":"2.1. Tipos de m\u00e9todos dunder:","text":"<ul> <li><code>__init__</code>: Se utiliza para inicializar objetos y es invocado autom\u00e1ticamente cuando se crea una instancia de la clase.</li> <li><code>__str__</code>: Se utiliza para representar el objeto en forma de cadena de texto.</li> <li><code>__len__</code>: Permite determinar la longitud de un objeto.</li> </ul> <p>Existen muchos otros m\u00e9todos m\u00e1gicos que pueden ser \u00fatiles, como <code>__add__</code> (para sumar objetos), <code>__eq__</code> (para comparar igualdad), <code>__lt__</code> (para comparar menor que), entre otros. Sin embargo, es importante tener en cuenta que no siempre es necesario utilizar estos m\u00e9todos y que su uso variar\u00e1 dependiendo de cada caso espec\u00edfico.</p> <p></p> <ul> <li> <p>Ejemplo <code>__init__</code>: <pre><code>class Persona:\n    def __init__(self, nombre):\n        self.nombre = nombre\n\np = Persona('Juan')\nprint(p.nombre)\n</code></pre></p> </li> <li> <p>Ejemplo <code>__init__</code> con <code>__str_</code>: <pre><code>class Persona:\n    def __init__(self, nombre):\n        self.nombre = nombre\n\n    def __str__(self):\n        return f'Mi nombre es {self.nombre}'\n\np = Persona('Juan')\nprint(p)\n</code></pre></p> </li> <li> <p>Ejemplo <code>__init__</code> con <code>__len__</code>: <pre><code>class Lista:\n    def __init__(self, elementos):\n        self.elementos = elementos\n\n    def __len__(self):\n        return len(self.elementos)\n\nl = Lista([1,2,3,4,5])\nprint(len(l)) # Imprime 5\n</code></pre></p> </li> </ul> <p>IMPORTANTE</p> <p>El primer ejemplo y el segundo ejemplo tienen el mismo resultado, lo que hace el m\u00e9todo dunder <code>__str__</code> es convertir el objeto en una cadena de texto.</p> <p></p>"},{"location":"devcamp/checkpoint-06/metodo-dunder-py/#22-que-metodo-dunder-se-ejecuta-automaticamente","title":"2.2. \u00bfQu\u00e9 m\u00e9todo dunder se ejecuta autom\u00e1ticamente?","text":"<p>El m\u00e9todo <code>__init__</code>, es un m\u00e9todo especial que se ejecuta autom\u00e1ticamente al invocar la clase e inicializara los atributos del objeto que le ayamos creado. Es decir, es imposible de olvidarse llamarlo ya que se llamar\u00e1 autom\u00e1ticamente.</p> <p>IMPORTANTE</p> <p>El m\u00e9todo <code>__init__</code> es el primer m\u00e9todo que se ejecuta dentro de una clase.</p> <p></p>"},{"location":"devcamp/checkpoint-06/metodo-dunder-py/#caracteristicas","title":"\ud83d\udcdd Caracter\u00edsticas:","text":"<ul> <li>El m\u00e9todo <code>__init__</code> no puede retornar <code>return</code> datos, no devuelve nada.</li> <li>El m\u00e9todo <code>__init__</code> puede recibir par\u00e1metros que se utilizan para inicializar atributos de forma autom\u00e1tica.</li> <li>El m\u00e9todo <code>__init__</code> es un constructor de instancias.</li> <li>El m\u00e9todo <code>__init__</code> es un m\u00e9todo opcional, de todos modos es muy com\u00fan declararlo.  </li> </ul>"},{"location":"devcamp/checkpoint-06/que-es-mongodb-py/","title":"6. \u00bfEs MongoDB una base de datos SQL o NoSQL?","text":"<p>MongoDB es una base de datos NoSQL orientada a documentos que apareci\u00f3 el a\u00f1o 2007. Se utiliza para almacenar vol\u00famenes masivos de datos.</p>"},{"location":"devcamp/checkpoint-06/que-es-mongodb-py/#61-como-se-almacenan-los-datos","title":"6.1. \u00bfComo se almacenan los datos?","text":"<p>A diferencia de una base de datos relacional SQL tradicional, MongoDB no se basa en tablas y columnas. Los datos se almacenan como colecciones y documentos.</p> <p>La arquitectura de MongoDB se basa en varios componentes principales. En primer lugar, la clave _id es un campo obligatorio para cada documento que se genera de forma autom\u00e1tica. Representa un valor \u00fanico y puede considerarse como la clave principal del documento para identificar al objeto dentro de la colecci\u00f3n.</p> <p></p> <p>IMPORTANTE</p> <ul> <li>Colecciones: Se refiere a un diccionario <code>{...}</code> o lista <code>[...]</code>.</li> <li>Documentos: Se refiere a la <code>\"clave\": \"valor\"</code> dentro de un diccionario. </li> </ul> <p></p> <p></p> <pre><code>{\n    \"_id\": ObjectId(\"5cf0029caff5056591b0ce7d\"),\n    \"nombre\": \"Juan\",\n    \"apellido\": \"Garcia\",\n},\n{\n    \"_id\": ObjectId(\"6sh5930rdee4058890b0ae5c\"),\n    \"nombre\": \"Nerea\",\n    \"apellido\": \"Larralde\",\n    \"telefono\": \"666-666-444\",\n    \"direccion\":  {\n        \"codigo_postal\": \"22222\",\n        \"provincia\": \"Gipuzkoa\",\n        \"pais\": \"Espa\u00f1a\"\n    }\n}\n</code></pre> <p>IMPORTANTE</p> <p>MongoDB almacena los datos en documentos flexibles al estilo JSON pero los reconoce como BSON, esto vendria a ser un JSON binario.</p> <p></p>"},{"location":"devcamp/checkpoint-06/que-es-mongodb-py/#61-comandos-para-interactuar-con-la-base-de-datos-desde-la-terminal","title":"\ud83d\udc68\u200d\ud83d\udcbb 6.1. Comandos para interactuar con la base de datos desde la terminal:","text":"<p>MQL es el lenguaje de consulta y manipulaci\u00f3n de informaci\u00f3n que MongoDB nos provee por defecto (MongoDB Query Language). Las consultas de MongoDB se basan en el lenguaje de programaci\u00f3n JavaScript con algunas diferencias leves.</p> <p></p> <ul> <li>Consultar todos los documentos que tenemos en la base de datos sin formatear la estructura:<ul> <li>C\u00f3digo: <code>db.nombre_de_tu_base_de_datos.find()</code>.</li> </ul> </li> <li>Consultar todos los documentos que tenemos en la base de datos con la estructura formateada:<ul> <li>C\u00f3digo: <code>db.nombre_de_tu_base_de_datos.find().pretty()</code>.</li> </ul> </li> <li>Consultar todos los documentos que coincidan con el valor del apellido:<ul> <li>C\u00f3digo: <code>db.nombre_de_tu_base_de_datos.find({apellido: \"Larralde\"}).pretty()</code>.</li> </ul> </li> <li>Consultar cuantos documentos coinciden con el valor del apellido:<ul> <li>C\u00f3digo: <code>db.nombre_de_tu_base_de_datos.find({apellido: \"Larralde\"}).length()</code>.</li> </ul> </li> <li>Consultar cuantos documentos coinciden con el valor del apellido utilizando Regex:<ul> <li>C\u00f3digo: <code>db.nombre_de_tu_base_de_datos.find({apellido: /.*Larralde.*/i})</code>.</li> </ul> </li> <li>Consultar en el documento si existe una clave o no:<ul> <li>C\u00f3digo: <code>db.nombre_de_tu_base_de_datos.find({apellido: $exists: true})</code>.</li> </ul> </li> <li>Eliminar todos los documentos que coincidan con el valor del apellido:<ul> <li>C\u00f3digo: <code>db.nombre_de_tu_base_de_datos.remove({apellido: \"Larralde\"})</code>.</li> </ul> </li> <li> <p>Eliminar un documento que coincida con el valor del apellido:</p> <ul> <li>C\u00f3digo: <code>db.nombre_de_tu_base_de_datos.remove({apellido: \"Larralde\"}, 1)</code>. </li> </ul> </li> <li> <p>Insertar un nuevo documento \ud83d\udc47 <pre><code>db.nombre_de_tu_base_de_datos.insert({\n    \"nombre\": \"Carlos\",\n    \"apellido\": \"Garrido\",\n    \"direccion\": {\n        \"codigo_postal\": \"45210\",\n        \"provincia\": \"Gipuzkoa\",\n        \"pais\": \"Espa\u00f1a\"\n    }\n});\n</code></pre> </p> </li> </ul> <p>TIP</p> <p>Descargar MongoDB desde https://www.mongodb.com/try/download/community.</p> <p>Para m\u00e1s informaci\u00f3n, consulte en su p\u00e1gina oficial.</p> <p> </p>"},{"location":"devcamp/checkpoint-06/que-es-polimorfismo-py/","title":"4. \u00bfQu\u00e9 es el polimorfismo?","text":"<p>El polimorfismo tiene como objetivo cambiar la funcionalidad entre los m\u00e9todos con el mismo nombre, en este ejemplo, tenemos tres clases, a los m\u00e9todos les hemos asignado el mismo nombre <code>desplazamiento</code>. A pesar de que lleven el mismo nombre, los podemos diferenciar creando una nueva funci\u00f3n y pasandole como atributo, por ejemplo <code>vehiculo</code>. El <code>vehiculo</code> tomara el valor de <code>mi_vehiculo</code> para hacer la m\u00e1gia del polimorfismo. A la variable <code>mi_vehiculo</code>, podemos pasarle cualquiera de las tres clases, <code>Moto()</code>, <code>Coche()</code>, <code>Camion()</code>.</p> <p></p> <p> </p> <p>C\u00f3digo Python \ud83d\udc47</p> <p><pre><code>class Moto():\n\n    def desplazamiento(self):\n        print('Me desplazo utilizando 2 ruedas')\n\nclass Coche():\n\n    def desplazamiento(self):\n        print('Me desplazo utilizando 4 ruedas')\n\nclass Camion():\n\n    def desplazamiento(self):\n        print('Me desplazo utilizando 6 ruedas')\n\ndef desplazamiento_vehiculo(vehiculo):\n    vehiculo.desplazamiento()\n\nmi_vehiculo = Coche()\ndesplazamiento_vehiculo(mi_vehiculo)\n\n# salida:\n    # Me desplazo utilizando 4 ruedas\n</code></pre> </p> <p>IMPORTANTE</p> <p>El polimorfismo puede acceder a cualquiera de las clases y ejecutar m\u00e9todos independientemente del nombre que tengan.</p> <p> </p>"},{"location":"devcamp/checkpoint-06/que-es-un-decorador-py/","title":"3. \u00bfQu\u00e9 es un decorador?","text":"<p>Los decoradores son funciones que toman otra funci\u00f3n como argumento y anidan una nueva funci\u00f3n para agregarle c\u00f3digo extra sin alterar la existente.</p> <p>En el siguiente ejemplo, puedes ver la estructura general de una funci\u00f3n decoradora.</p> <p>TIP</p> <p>Si alguna vez has visto <code>@</code>, est\u00e1s ante un decorador.</p> <p></p> <p> </p> <p>C\u00f3digo Python \ud83d\udc47</p> <p><pre><code>def decorador(f):\n\n    def funcion_nueva():\n        print('Funcionalidad extra')\n        f()\n    return funcion_nueva\n\n@decorador\ndef funcion_inicial():\n    print('Funcionalidad inicial')\n\nfuncion_inicial()\n</code></pre> </p>"},{"location":"devcamp/checkpoint-06/que-es-un-decorador-py/#analicemos-estos-elementos-en-mas-detalle","title":"\ud83d\udd75\ufe0f Analicemos estos elementos en m\u00e1s detalle:","text":"<ul> <li> <p>Esta es la <code>funci\u00f3n_inicial</code> que el <code>@decorador</code> va tomar como referencia. <pre><code>@decorador\ndef funcion_inicial():\n    print('Funcionalidad inicial')\n\nfuncion_inicial()\n</code></pre></p> </li> <li> <p>Esta es una funci\u00f3n intermediaria que va hacer la decoradoraci\u00f3n <code>def decorador</code>. El nombre de la funci\u00f3n hace referencia a <code>@decorador</code>. Toma <code>(f)</code> como argumento para invocar <code>f()</code> m\u00e1s adelante dentro de la <code>funci\u00f3n_nueva()</code> que va ir anidada.</p> </li> </ul> <pre><code>def decorador(f):\n    def funcion_nueva():\n        print('Funcionalidad extra')\n        f()\n    return funcion_nueva\n</code></pre> <ul> <li>Si ejecutamos el c\u00f3digo, podemos ver el siguiente resultado:</li> </ul> <p><pre><code>Funcionalidad extra\nFuncionalidad inicial\n</code></pre> </p>"},{"location":"devcamp/checkpoint-06/que-es-una-api-py/","title":"5. \u00bfQue es una API?","text":"<p>Una API es una (interfaz de programaci\u00f3n de aplicaciones) que sigue un conjunto de restricciones arquitecturales basadas en HTTP. Esto significa que se puede acceder a los recursos a trav\u00e9s de URLs, lo que hace que la API sea f\u00e1cil de entender y utilizar. Podemos crear una API que haga literalmente cualquier cosa, desde dar clima hasta un cat\u00e1logo completo de una tienda en l\u00ednea. Casi todas las aplicaciones utilizan APIs para conectarse con fuentes de datos corporativas, servicios de datos de terceros u otras aplicaciones.</p> <p>TIP</p> <p>El formato de intercambio de datos normalmente es JSON o XML, lo que permite que la API sea compatible con una amplia variedad de aplicaciones.</p> <p></p> <p> </p>"},{"location":"devcamp/checkpoint-06/que-es-una-api-py/#51-una-api-tiene-dos-componentes-principales","title":"5.1. Una API tiene dos componentes principales:","text":"<ul> <li> <p>Recursos:</p> <ul> <li>Datos o informaci\u00f3n.</li> </ul> </li> <li> <p>Verbos HTTP:</p> <ul> <li><code>GET</code> para consultar y leer.</li> <li><code>POST</code> para crear.</li> <li><code>PUT</code> para editar.</li> <li><code>DELETE</code> para eliminar.</li> </ul> </li> </ul> <p>IMPORTANTE</p> <p>Los recursos son los datos o informaci\u00f3n que se pueden acceder a trav\u00e9s de la API. Los verbos HTTP son las operaciones que se pueden realizar en esos recursos, como obtener <code>GET</code> un recurso, crear <code>POST</code> un recurso, actualizar <code>PUT</code> un recurso o eliminar <code>DELETE</code> un recurso.</p> <p></p>"},{"location":"devcamp/checkpoint-06/que-es-una-api-py/#52-de-donde-obtiene-la-api-toda-la-informacion","title":"5.2. \u00bfDe donde obtiene la API toda la informaci\u00f3n?","text":"<p>La informaci\u00f3n de la api no sale de la nada, necesita ser construido por alguien en formato diccionario. Se puede construir de manera manual o cargarle la informaci\u00f3n desde una base de datos. Cuando abrimos la url donde esta alojado el API, veremos un monton de datos en formato diccionario <code>{...}</code>. Puede contener anidamientos tanto de diccionarios como de listas en su interior.</p> <p>Formato de una API \ud83d\udc47 <pre><code>{\n  \"id\": 1,\n  \"nombre\": \"Juan\",\n  \"apellido\": \"Garcia\",\n  \"pais\": \"Espa\u00f1a\"\n},\n{\n  \"id\": 2,\n  \"nombre\": \"Nerea\",\n  \"apellido\": \"Larralde\",\n  \"pais\": \"Espa\u00f1a\"\n}\n</code></pre></p> <p>TIP</p> <p>Puedes practicar con esta API de Rick and Morty https://rickandmortyapi.com/api/character/ utilizando la aplicaci\u00f3n Postman https://www.postman.com/ para testear con APIs.</p> <p>Si accede a <code>https://rickandmortyapi.com/api/character/131</code> por numero de id al personaje, nos devolvera un json con toda la informaci\u00f3n.</p> <p></p>"},{"location":"devcamp/checkpoint-06/que-es-una-api-py/#53-que-es-postman","title":"5.3. \u00bfQu\u00e9 es Postman?","text":"<p>Se trata de una herramienta dirigida a desarrolladores web que permite realizar peticiones HTTP a cualquier API. Postman es muy \u00fatil a la hora de programar y hacer pruebas, puesto que nos ofrece la posibilidad de comprobar el correcto funcionamiento de nuestros desarrollos.</p> <p>Con esto no queremos decir que Postman sea una herramienta exclusiva para profesionales del entorno web, de hecho va a ser muy \u00fatil para todo aquel que tenga que interactuar con una API.</p>"},{"location":"devcamp/checkpoint-06/que-es-una-api-py/#caracteristicas-principales","title":"Caracter\u00edsticas principales:","text":"<ul> <li> <p>Env\u00edo de solicitudes:</p> <ul> <li>Postman permite enviar solicitudes HTTP y HTTPS utilizando m\u00e9todos como GET, POST, PUT y DELETE, entre otros. Los desarrolladores pueden especificar par\u00e1metros, encabezados y el cuerpo de la solicitud para simular diversas interacciones con una API.</li> </ul> </li> <li> <p>Pruebas automatizadas:</p> <ul> <li>Con Postman, los desarrolladores pueden crear y ejecutar pruebas automatizadas para verificar el comportamiento de una API. Esto ayuda a detectar errores de manera temprana y a garantizar que el software cumpla con los est\u00e1ndares de calidad. </li> </ul> </li> </ul> <p>TIP</p> <p>API de testeo https://rickandmortyapi.com</p> <p> </p>"},{"location":"devcamp/checkpoint-07/","title":"Checkpoint 07","text":""},{"location":"devcamp/checkpoint-07/#documentacion-javascript","title":"Documentaci\u00f3n JavaScript","text":"<p>\u00cdNDICE CHECKPOINT 07</p> <ol> <li>\u00bfQu\u00e9 diferencia a Javascript de cualquier otro lenguaje de programaci\u00f3n?</li> <li>\u00bfCu\u00e1les son algunos tipos de datos JS?</li> <li>\u00bfCu\u00e1les son las tres funciones de String en JS?</li> <li>\u00bfQu\u00e9 es un condicional?</li> <li>\u00bfQu\u00e9 es un operador ternario?</li> <li>\u00bfCu\u00e1l es la diferencia entre una declaraci\u00f3n de funci\u00f3n y una expresi\u00f3n de funci\u00f3n?</li> <li>\u00bfQu\u00e9 es la palabra clave \"this\" en JS? </li> </ol>"},{"location":"devcamp/checkpoint-07/condicionales-js/","title":"4. \u00bfQu\u00e9 es un condicional?","text":"<p>Hasta ahora, hemos visto c\u00f3mo resolver los problemas m\u00e1s sencillos pero no podemos resolver todo utilizando estructuras secuenciales. Cuando tenemos que tomar una decisi\u00f3n aparecen las estructuras condicionales. Por ejemplo, en nuestra vida diaria hay momentos donde tenemos que decidir entre un pantal\u00f3n u otro, un camino u otro. En estos casos es com\u00fan resolver un problema combinando estructuras secuenciales y condicionales.</p> <p>JavaScript cuenta con 4 tipos de condicionales:</p> <ul> <li>Condicional if</li> <li>Condicional else</li> <li>Condicional else if</li> <li>Condicional switch </li> </ul>"},{"location":"devcamp/checkpoint-07/condicionales-js/#41-condicional-simple-con-if","title":"4.1. Condicional simple con if","text":"<p>Podemos ver un ejemplo de una estructura condicional simple con el siguiente esquema.</p> <p>IMPORTANTE</p> <p>Puedes usar if solo una vez por bloque y no es obligatorio complementarlo con else.</p> <p> </p> <p>Podemos observar en el esquema que el rombo representa la condici\u00f3n y tenemos dos opciones que podemos tomar. Si la condici\u00f3n devuelve un resultado verdadero, ejecutar\u00e1 las opciones que se encuentren en su interior, si por el contrario es falso, no realizar\u00e1 dicha acci\u00f3n.</p> <p>Vamos a ver el primer ejemplo y el mas simple con el if, le pasamos por variable <code>edad = 20</code>, si tiene 18 o mas a\u00f1os, muestra un mensaje <code>Soy mayor de edad porque tengo 18 o mas a\u00f1os.</code> y si tiene menos de 18 a\u00f1os, no nos muestra ningun mensaje.</p> ejemplo.js<pre><code>let edad = 20;\nif (edad &gt;= 18) {\n    console.log(`Soy mayor de edad porque tengo ${edad} o mas a\u00f1os.`)\n}\n</code></pre> <p>La palabra clave <code>if</code> implica el inicio de una condici\u00f3n, seguidamente incluimos la condici\u00f3n entre <code>()</code> par\u00e9ntesis y finalizamos la l\u00ednea con el car\u00e1cter <code>{</code> apertura de llave.</p> <p>Una de las caracter\u00edsticas de JavaScript que adem\u00e1s ayuda a tener una estructura organizada es la indentaci\u00f3n o sangrado de texto con dos o cuatro espacios. Es decir, si queremos incluir una condici\u00f3n, el texto que deba ir en su interior debe ir con cuatro espacios con respecto al inicio de la palabra <code>if</code>.</p>"},{"location":"devcamp/checkpoint-07/condicionales-js/#42-condicional-alternativa-con-if-else","title":"4.2. Condicional alternativa con if else","text":"<p>Podemos ver un ejemplo de una estructura condicional compuesta con el siguiente esquema.</p> <p>IMPORTANTE</p> <p>Puedes usar else solo una vez por condici\u00f3n if.</p> <p> </p> <p>Cuando se presenta una elecci\u00f3n entre if o else, tenemos la opci\u00f3n de realizar una acci\u00f3n u otra, es decir, tenemos operaciones diferentes a ejecutar si la condici\u00f3n es verdadera o es falsa. Es decir, se tomara una de las 2 elecciones de la bifurcaci\u00f3n.</p> <p>Vamos a volver a realizar el ejercicio anterior pero, con la diferencia, de que si la edad es menor a 18 a\u00f1os, nos muestre un mensaje <code>Soy menor de edad porque tengo menos de 18 a\u00f1os.</code>.</p> ejemplo.js<pre><code>edad = 16;\nif (edad &gt;= 18) {\n    console.log(`Soy mayor de edad porque tengo ${edad} o mas a\u00f1os.`)\n}\nelse {\n    console.log(`Soy menor de edad porque tengo menos de ${edad} a\u00f1os.`);\n}\n</code></pre> <p>Como podemos ver, si la condici\u00f3n es falsa, y queremos que realice una operaci\u00f3n, la forma ser\u00eda incluyendo la palabra <code>else</code> en una l\u00ednea nueva seguida del car\u00e1cter <code>{</code> apertura de llave. Despu\u00e9s las operaciones necesarias que queramos ejecutar separadas con 4 espacios con respecto a la l\u00ednea de la palabra <code>else</code>. Despues de la operaci\u00f3n y en una nueva l\u00ednea, toca cerrar <code>}</code> la llave y con eso, finaliza el bloque <code>else</code>.</p>"},{"location":"devcamp/checkpoint-07/condicionales-js/#43-condicional-encadenada-con-if-else-if-else","title":"4.3. Condicional encadenada con if else if else","text":"<p>Podemos ver un ejemplo de una estructura condicional encadenada con el siguiente esquema.</p> <p>IMPORTANTE</p> <p>El flujo de ejecucci\u00f3n se prioriza siempre de arriba hacia abajo y puedes crear tantas else if que desees.</p> <p> </p> <p>Cuando se presentan mas de dos elecci\u00f3nes a elegir entre <code>if</code> <code>else if</code> y <code>else</code>, se tomara como v\u00e1lida, solamente una de las 3 elecciones de la bifurcaci\u00f3n. El flujo de ejecuci\u00f3n se priorizara siempre de arriba hacia abajo.</p> <p>Vamos a volver a realizar el ejercicio anterior con una condici\u00f3nal mas, que sera la condicional <code>else if</code>, pero con la diferencia, de que si la edad es mayor o igual a 67 a\u00f1os, nos muestre un mensaje <code>Tengo 70 a\u00f1os y estoy jubilado.</code>. El resto de las condicionales se mantienen igual.</p> ejemplo.js<pre><code>let edad = 36;\n\nif (edad &gt;= 67) {\n    console.log(`Tengo ${edad} a\u00f1os y estoy jubilado.`);\n}\nelse if (edad &gt;= 18) {\n    console.log(`Soy mayor de edad porque tengo ${edad} o mas a\u00f1os.`)\n}\nelse {\n    console.log(`Soy menor de edad porque tengo menos de ${edad} a\u00f1os.`);\n}\n</code></pre> <p>Como vemos en el ejempo anterior, el uso de la condicional else if, nos da la posibilidad de crear muchas condiciones sobre un mismo if ya que su uso no esta limitado. Recuerda que cuanto mas corto y menos condicionales tenga el bloque, mas legible sera el c\u00f3digo.</p>"},{"location":"devcamp/checkpoint-07/condicionales-js/#44-condicionales-anidadas","title":"4.4. Condicionales anidadas","text":"<p>Podemos ver un ejemplo de una estructura condicional anidado con el siguiente esquema.</p> <p>IMPORTANTE</p> <p>Podemos tener infinidad de condiciones anidadas pero en la medida de lo posible, procuraremos anidar lo menos posible.</p> <p> </p>"},{"location":"devcamp/checkpoint-07/condicionales-js/#45-condicional-switch","title":"4.5. Condicional switch","text":"<p>La estructura de control switch permite definir casos espec\u00edficos a realizar cuando la variable expuesta como condici\u00f3n sea igual a los valores que se especifican a continuaci\u00f3n mediante cada case:.</p> <p>Las sentencias switch no ser\u00e1n apropiadas para usar en todas las situaciones. Pero si sientes que las sentencias else if son largas y complicadas, entonces una sentencia switch podr\u00eda ser una opci\u00f3n alternativa. Aunque, mucha gente opina que en lugar de mejorar la legibilidad, normalmente la empeora.</p> <p>Veamos un ejemplo de c\u00f3mo se utiliza:</p> ejemplo.js<pre><code>let numero = 88734;\n\nswitch (numero) {\n    case 00003:\n        console.log('\u00a1Primer premio!');\n        break;\n    case 00012:\n        console.log('\u00a1Segundo premio!');\n        break;\n    case 88734:\n        console.log('\u00a1Tercer premio!');\n        break;\n    // con default, toma la salida de cualquier otra opci\u00f3n\n    default:\n        console.log(`El n\u00famero ${numero} no tiene premio`);\n        break;\n}\n</code></pre> <p>El valor de la variable (<code>numero</code>) es 88734, toma la salida (<code>case 88734</code>) con el mensaje \u00a1Tercer premio!</p> <ul> <li>switch: Se define el tipo de condici\u00f3n que debe cumplir, en este caso, compara el valor de la variable con la opci\u00f3n.</li> <li>case 00003: Es la primera opci\u00f3n, si cumple la condici\u00f3n, toma la salida y sale con el break, si no cumple, continua</li> <li>case 00012: Es la segunda opci\u00f3n, si cumple la condici\u00f3n, toma la salida y sale con el break, si no cumple, continua</li> <li>case 88734: Es la tercera opcion, si cumple la condici\u00f3n, toma la salida y sale con el break, si no cumple, continua</li> <li>default: Si no cumple con ninguna condicion anterior, toma la salida con el mensaje (<code>El n\u00famero (?) no tiene premio</code>) y sale con el break</li> </ul> <p> </p>"},{"location":"devcamp/checkpoint-07/declaracion-de-funcion-vs-expresion-de-funcion-js/","title":"6. \u00bfCu\u00e1l es la diferencia entre una declaraci\u00f3n de funci\u00f3n y una expresi\u00f3n de funci\u00f3n?","text":"<p>JavaScript al ser un lenguaje din\u00e1mico, tiene ciertos mecanismos para garantizar que la ejecuci\u00f3n de nuestro c\u00f3digo sea la m\u00e1s \u00f3ptima y correcta.</p> <p>Tenemos dos maneras principales de definir funciones:</p> <ul> <li>Podemos definir una funci\u00f3n declarando </li> <li>Podemos definir una funci\u00f3n como una expresi\u00f3n</li> </ul> <p>Veamos un ejemplo para compararlos:</p> ejemplo.js<pre><code>// Declaracion de funcion\nfunction saludar() {\n    console.log('Hola');\n}\n\n// Expresion de funcion\nlet saludar = function() {\n    console.log('Hola');\n};\n</code></pre>"},{"location":"devcamp/checkpoint-07/declaracion-de-funcion-vs-expresion-de-funcion-js/#analicemos-las-diferencias","title":"\ud83d\udd75\ufe0f Analicemos las diferencias","text":"<p>Declaraci\u00f3n de funci\u00f3n:</p> <ul> <li>S\u00f3lo es visible dentro del bloque de c\u00f3digo en el que reside, por ejemplo dentro de un <code>if</code></li> <li>JavaScript precarga todas las funciones declaradas al inicio y puede llamarse antes o despues de la funci\u00f3n</li> </ul> <p>Expresi\u00f3n de funci\u00f3n:</p> <ul> <li>Es visible dentro y fuera del bloque de c\u00f3digo en el que reside pudiendo declarar una variable fuera del bloque</li> <li>Se define dentro de una variable como una expresi\u00f3n normal, por eso lleva <code>;</code> punto y coma al final de la funci\u00f3n</li> <li>Solo puede llamarse despues de la funci\u00f3n, si se llama antes de la funci\u00f3n tira error de (variable no est\u00e1 definida)</li> </ul> <p>Las diferencias de sintaxis son claras.</p> <p>Veamos el mismo ejemplo anterior, agregando una llamada antes de la funci\u00f3n:</p> ejemplo.js<pre><code>// Declaracion de funcion\nsaludar() // Salida: Hola\n\nfunction saludar() {\n    console.log('Hola');\n}\n\n// Expresion de funcion\nsaludar(); // Error: saludar no est\u00e1 definida\n\nlet saludar = function() {\n    console.log('Hola');\n};\n</code></pre> <p>En el caso de expresi\u00f3n de funci\u00f3n nos da el error de (variable no est\u00e1 definida), cosa que en la declaraci\u00f3n de funci\u00f3n no ocurre gracias a la precarga de las declaraciones al inicio.</p> <p>IMPORTANTE</p> <p>En las expresiones de funciones darle nombre a la funci\u00f3n es opcional. En cambio para las declaraciones es obligatorio.</p> <p>No hay una forma mejor o peor de declarar funciones, lo bueno es conocer las herramientas que tenemos, sus implicaciones y saber cuando podemos usarlas para crear c\u00f3digo legible y limpio.</p> <p>Veamos un ejemplo mas completo:</p> ejemplo.js<pre><code>// Expresion de funcion\nlet edad = 32;\nlet entradaCasino;\n\nif (edad &gt;= 18) {\n    entradaCasino = function() {\n        console.log('Puedes entrar al casino');\n    };\n}\nelse {\n    entradaCasino = function() {\n        console.log('No puedes entrar al casino');\n    };\n}\n\nentradaCasino(); // Salida: Puedes entrar al casino\n</code></pre> <p>Con la expresion de funcion, podemos llamar a cualquier funci\u00f3n este donde este. Gracias a la variable entradaCasino, nos permite ver la funci\u00f3n an\u00f3nima dentro del bloque if desde el exterior.  </p>"},{"location":"devcamp/checkpoint-07/introduccion-js/","title":"1. \u00bfQu\u00e9 diferencia a Javascript de cualquier otro lenguaje de programaci\u00f3n?","text":"<p>JavaScript es un lenguaje de programaci\u00f3n b\u00e1sico para la creaci\u00f3n de sitios web din\u00e1micos e interactivos. Se usa en navegadores, servidores y aplicaciones para mejorar la experiencia del usuario. Aunque se llama JavaScript, no debe confundirse con Java.</p> <p>Su principal ventaja es que se ejecuta directamente en el navegador del usuario, sin necesidad de compilar el c\u00f3digo previamente.</p> <p>El flujo de ejecuci\u00f3n es la siguiente:</p> <ol> <li>El navegador carga el c\u00f3digo JavaScript en una web</li> <li>El motor de JavaScript lo interpreta y ejecuta</li> <li>Interact\u00faa con el DOM (Document Object Model), que modifica elementos HTML en tiempo real</li> <li>Puede comunicarse con servidores mediante AJAX o Fetch API para obtener y enviar datos sin recargar la p\u00e1gina</li> <li>Maneja eventos como clics de botones para mejorar la interactividad  </li> </ol> <p>Veamos el siguiente ejemplo:</p> <ol> <li>Pulsa el bot\u00f3n</li> <li>Escucha el evento click</li> <li>Ejecuta la funci\u00f3n</li> <li>Cambia el texto del bot\u00f3n</li> </ol> ejemplo.html<pre><code>&lt;!-- crea un boton que pone Start --&gt;\n&lt;button class=\"btn-start\"&gt;Start&lt;/button&gt;\n</code></pre> ejemplo.js<pre><code>// captura el elemento DOM\nconst btnStart = document.querySelector('.btn-start');\n\n// captura el evento\nbtnStart.addEventListener('click', changeText);\n\n// funci\u00f3n para cambiar el texto del boton\nfunction changeText() {\n    btnStart.innerHTML = 'Texto cambiado';\n}\n</code></pre> <p>An\u00e1lisis del c\u00f3digo:</p> <p>Revisa lo que hace el c\u00f3digo, desde ejemplo.js captura el objeto DOM del ejemplo.html y para ello, hace referencia a la clase \"btn-start\". Una vez capturado el objeto DOM, lo guarda en una variable llamada btnStart para luego poner en escucha y capturar el evento 'click', para llamar a la funci\u00f3n changeText.  </p> <p>Cuando se aprende JavaScript, es esencial entender la relaci\u00f3n entre HTML, CSS y JavaScript, y c\u00f3mo se unen para mostrar un sitio web. Aunque la mayor\u00eda de las aplicaciones de JavaScript son del lado del cliente (FRONTEND), este lenguaje tambi\u00e9n es \u00fatil en aplicaciones del lado del servidor (BACKEND), como la creaci\u00f3n de servidores web.</p> <p>Caracter\u00edsticas de JavaScript:</p> <ul> <li>Multiparadigma: Soporta programaci\u00f3n orientada a objetos, funcional e imperativa</li> <li>Din\u00e1mico y flexible: No requiere declaraci\u00f3n expl\u00edcita de tipos de datos</li> <li>Basado en eventos: Responde a interacciones del usuario</li> <li>Compatible con todos los navegadores: Funciona en cualquier navegador moderno</li> <li>As\u00edncrono y concurrente: Permite manejar tareas en paralelo con promesas y async/await</li> </ul> <p>Ventajas</p> <ul> <li>Es f\u00e1cil de aprender y usar.</li> <li>Se ejecuta en el navegador, sin necesidad de compilaci\u00f3n</li> <li>Amplia compatibilidad con diferentes plataformas</li> <li>Ecosistema extenso con miles de librer\u00edas y frameworks</li> <li>Soporte para desarrollo full-stack con Node.js</li> </ul> <p>Desventajas</p> <ul> <li>Manejo de errores menos estricto comparado con otros lenguajes</li> <li>Uso excesivo puede afectar el rendimiento de una p\u00e1gina web</li> </ul> <p></p>"},{"location":"devcamp/checkpoint-07/introduccion-js/#11-sintaxis-de-javascript","title":"1.1. Sintaxis de JavaScript","text":"<p>JavaScript tiene una serie de normas b\u00e1sicas de sintaxis que debemos seguir.</p> <p>Variables:</p> <p>puedes declarar variables usando las palabras clave <code>var</code>, <code>const</code> o <code>let</code>.</p> <ul> <li><code>let</code> Permite declarar variables limitando su alcance al bloque, fuera de ella no tiene efecto</li> <li><code>const</code> Son como las <code>let</code>, solo que su valor no cambiara a lo largo del programa</li> <li><code>var</code> Permite declarar variables con alcance dentro y fuera del bloque, se entienden como globales.</li> </ul> <p>IMPORTANTE</p> <p>No se recomienda el uso de <code>var</code> en Javascript, porque puede dar lugar a problemas y confusiones.</p> <p>Punto y coma para finalizar sentencias:</p> <p>En JavaScript, cada instrucci\u00f3n generalmente termina con un <code>;</code> punto y coma. Es una buena pr\u00e1ctica usar el punto y coma siempre. De lo contrario, puede dar errores.</p> <p>Instrucciones y ejecuci\u00f3n secuencial:</p> <p>En JavaScript, el c\u00f3digo est\u00e1 compuesto por instrucciones que se ejecutan de forma secuencial. Esto significa que las instrucciones se ejecutan una tras otra, de arriba hacia abajo, en el orden en que aparecen.</p> <p>Llaves para delimitar bloques de c\u00f3digo:</p> <p>Las llaves <code>{}</code> en JavaScript se utilizan para definir bloques de c\u00f3digo, especialmente en estructuras de control como funciones, bucles o condiciones.</p> <p>Sensibilidad a may\u00fasculas y min\u00fasculas:</p> <p>JavaScript es un lenguaje que diferencia entre may\u00fasculas y min\u00fasculas (case-sensitive). Esto significa que distingue entre nombre, Nombre y NOMBRE, consider\u00e1ndolos variables diferentes.</p>"},{"location":"devcamp/checkpoint-07/introduccion-js/#buenas-practicas-al-nombrar-variables","title":"<p>Buenas pr\u00e1cticas al nombrar variables:</p>","text":"<ul> <li>Aunque JavaScript no lo exige, es de buena pr\u00e1ctica utilizar camelCase para nombrar variables</li> <li>Una variable no puede comenzar con un n\u00famero.</li> <li>Un nombre de variable no puede contener espacios.</li> <li>No pueden incluir s\u00edmbolos especiales como (!, @, #, %) a excepci\u00f3n del guion bajo (_) y el s\u00edmbolo de d\u00f3lar ($).</li> </ul>"},{"location":"devcamp/checkpoint-07/introduccion-js/#algunas-palabras-reservadas","title":"<p>Algunas palabras reservadas:</p>","text":"<ul> <li>Control de flujo: if, else, switch, case, default</li> <li>Ciclos: for, while, do, break, continue</li> <li>Declaraci\u00f3n de variables y funciones: var, let, const, function, return</li> <li>Manipulaci\u00f3n de objetos y clases: class, extends, constructor, super</li> <li>Valores especiales: null, undefined, true, false</li> <li>Operaciones asincr\u00f3nicas: async, await</li> <li>Operadores de importaci\u00f3n/exportaci\u00f3n: import, export</li> <li>Operadores l\u00f3gicos y aritm\u00e9ticos: new, delete, typeof, instanceof</li> </ul> <p>PRECAUCI\u00d3N</p> <p>Estas palabras son utilizadas por el lenguaje para funciones espec\u00edficas y su uso como nombres provocar\u00e1 errores.</p> <p></p>"},{"location":"devcamp/checkpoint-07/introduccion-js/#12-comentarios-en-javascript","title":"1.2. Comentarios en JavaScript","text":"<p>Su prop\u00f3sito es proporcionar explicaciones o notas para los desarrolladores que leen el c\u00f3digo. En JavaScript, los comentarios pueden ser de dos tipos.</p> <ul> <li>Comentarios de una sola l\u00ednea</li> <li>Comentarios de varias l\u00edneas </li> </ul>"},{"location":"devcamp/checkpoint-07/introduccion-js/#comentarios-de-una-sola-linea","title":"Comentarios de una sola l\u00ednea:","text":"<p>Los comentarios de una sola l\u00ednea comienzan con dos barras inclinadas (<code>//</code>). Todo el texto que sigue a estas barras en la misma l\u00ednea es considerado un comentario y es ignorado por el int\u00e9rprete de JavaScript.</p> ejemplo.js<pre><code>// Este es un comentario de una sola l\u00ednea\nlet nombre = \"Roberto\"; // Tambi\u00e9n se puede usar al final de una l\u00ednea de c\u00f3digo\n</code></pre>"},{"location":"devcamp/checkpoint-07/introduccion-js/#comentarios-de-varias-lineas","title":"Comentarios de varias l\u00edneas:","text":"<p>Los comentarios de varias l\u00edneas se encierran entre <code>/*</code> y <code>*/</code>. Todo el texto dentro de estos delimitadores es considerado un comentario y es ignorado por el int\u00e9rprete.</p> <p>ejemplo.js<pre><code>/*\nEste es un comentario de varias l\u00edneas.\nPuede abarcar m\u00faltiples l\u00edneas.\nEs \u00fatil para explicaciones m\u00e1s largas o para desactivar bloques de c\u00f3digo.\n*/\nlet edad = 36;\n</code></pre> </p>"},{"location":"devcamp/checkpoint-07/introduccion-js/#13-como-usar-la-consola-en-javascript","title":"1.3. C\u00f3mo usar la consola en JavaScript","text":"<p>En JavaScript la consola se usa cont\u00ednuamente. El m\u00e9todo mas utilizado es <code>console.log</code>. Su prop\u00f3sito principal es imprimir informaci\u00f3n en la consola.</p> <p>Veamos el siguiente ejemplo:</p> ejemplo.js<pre><code>let mensaje = '\u00a1Hola mundo!';\n\n// varios ejemplos de salida:\nconsole.log(mensaje); // \u00a1Hola mundo!\nconsole.log(`Este es mi primer ${mensaje}`); // Este es mi primer \u00a1Hola mundo!\n</code></pre> <p>Esto es \u00fatil para verificar que las variables contienen los valores esperados y que el flujo de ejecuci\u00f3n es el correcto. </p>"},{"location":"devcamp/checkpoint-07/introduccion-js/#14-como-usar-la-ventana-emergente-en-javascript","title":"1.4. C\u00f3mo usar la ventana emergente en JavaScript","text":"<p>En JavaScript la ventana emergente se usa cont\u00ednuamente. El m\u00e9todo mas utilizado es <code>alert</code>. Su prop\u00f3sito principal es imprimir informaci\u00f3n en la ventana emergente.</p> <p>Veamos el siguiente ejemplo:</p> ejemplo.js<pre><code>let mensaje = '\u00a1Hola mundo!';\n\n// varios ejemplos de salida:\nalert(mensaje) // \u00a1Hola mundo!\nalert(`Este es mi primer ${mensaje}`); // Este es mi primer \u00a1Hola mundo!\n</code></pre> <p>Esto es \u00fatil para verificar que las variables contienen los valores esperados y que el flujo de ejecuci\u00f3n es el correcto. </p>"},{"location":"devcamp/checkpoint-07/introduccion-js/#15-indentacion-de-codigo","title":"1.5. Indentaci\u00f3n de c\u00f3digo","text":"<p>A medida que escribimos l\u00edneas de c\u00f3digo en nuestro programa, este se ir\u00e1 complicando y nos tomar\u00e1 m\u00e1s tiempo leer lo que hemos hecho y comprobar si hay errores o buscar como solucionarlos. Sin embargo, para mejorar la rapidez con la que leemos y entendemos el c\u00f3digo, una buena pr\u00e1ctica es usar la indentaci\u00f3n.</p> <p>A la hora de indentar c\u00f3digo hay dos opciones:</p> <ul> <li>Usar espacios</li> <li>Usar tabuladores</li> </ul> <p>Utilizar una u otra estrategia de tabulaci\u00f3n depende del programador, pero lo importante es siempre utilizar la misma. En mis ejemplos, suelo utilizar indentaci\u00f3n a 4 espacios porque me resulta m\u00e1s pr\u00e1ctico leer.  </p>"},{"location":"devcamp/checkpoint-07/operador-ternario-js/","title":"5. \u00bfQu\u00e9 es un operador ternario?","text":"<p>El operador ternario es una forma abreviada de la estructura if...else y es \u00fatil cuando queremos tomar decisiones basadas en una condici\u00f3n.</p> <p>Se compone de tres partes:</p> <ul> <li>Una expresi\u00f3n condicional</li> <li>Una expresi\u00f3n que se eval\u00faa si la condici\u00f3n es verdadera</li> <li>Una expresi\u00f3n que se eval\u00faa si la condici\u00f3n es falsa</li> </ul> <p>La sintaxis b\u00e1sica del operador ternario es la siguiente:</p> ejemplo.js<pre><code>condicion ? expresion_verdadera : expresion_falsa\n</code></pre> <ul> <li>condicion: Una expresi\u00f3n que se eval\u00faa como verdadera o falsa</li> <li>expresion_verdadera: La expresi\u00f3n que se ejecutar\u00e1 si condicion es verdadera</li> <li>expresion_falsa: La expresi\u00f3n que se ejecutar\u00e1 si condicion es falsa</li> </ul> ejemplo.js<pre><code>const edad = 36;\n\nconst mensaje = edad &gt;= 18 ? 'Eres mayor de edad' : 'Eres menor de edad';\n\nconsole.log(mensaje); // Salida: Eres mayor de edad\n</code></pre>"},{"location":"devcamp/checkpoint-07/operador-ternario-js/#51-anidamiento-de-operadores-ternarios","title":"5.1. Anidamiento de operadores ternarios","text":"<p>Es posible anidar operadores ternarios para expresiones condicionales m\u00e1s complejas. Los operadores ternarios encadenados (o anidados) hacen que el c\u00f3digo sea imposible de leer en algunos casos. Lo ideal seria usar switch/case o if/else en su lugar.</p> <p>Veamos un ejemplo:</p> ejemplo.js<pre><code>const calificacion = 8;\n\nconst resultado = calificacion &lt;   5 ? 'Suspenso' :\n                  calificacion &lt;   7 ? 'Aprobado' :\n                  calificacion &lt;   9 ? 'Notable' :\n                  calificacion &lt;  10 ? 'sobresaliente' :\n                  calificacion == 10 ? 'Matr\u00edcula de honor' :\n                                       'Introduzca un n\u00famero del 0 al 10';\n\nconsole.log(resultado); // Salida: Notable\n</code></pre> <p>IMPORTANTE</p> <p>Es importante mantener la legibilidad del c\u00f3digo al hacerlo.</p> <p> </p>"},{"location":"devcamp/checkpoint-07/que-es-this-js/","title":"7. \u00bfQu\u00e9 es la palabra clave \"this\" en JS?","text":"<p>Una de las caracter\u00edsticas de JavaScript que m\u00e1s confusi\u00f3n genera es la palabra clave this. M\u00e1s concretamente a qu\u00e9 o qui\u00e9n hace referencia y en qu\u00e9 circunstancias.</p> <p>this es una palabra clave que se utiliza mucho dentro de las clases para hacer referencia al objeto instanciado. Cuando se crea una funci\u00f3n dentro de una clase, esta funci\u00f3n  pasa a llamarse m\u00e9todo. El primer m\u00e9todo siempre sera el constructor, se encarga de declarar atributos, el this hace referencia a cualquier atributo que se le pase dentro de esa misma clase. si se utilizara fuera de \u00e9sta clase, ar\u00eda referencia a otra cosa.</p> <p>Veamos un ejemplo de clase:</p> <p>ejemplo.js<pre><code>class Cliente {\n\n    provincia = 'Guipuzcoa'; // atributo global / variable de clase\n\n    constructor(nombre, apellido, telefono) {\n        this.nombre = nombre;\n        this.apellido = apellido;\n        this.telefono = telefono;\n    }\n\n    datos() {\n        return 'Nombre: ' + this.nombre + '\\n' +\n               'Apellido: ' + this.apellido + '\\n' +\n               'Tel\u00e9fono: ' + this.telefono + '\\n' +\n               'Provincia: ' + this.provincia;\n    }\n}\n\nconst cli_1 = new Cliente('Nerea', 'Zelaieta', '666-666-666');\nconst cli_2 = new Cliente('Roberto', 'Mendiburu', '333-666-666');\n\nconsole.log(cli_1.datos());\nconsole.log(cli_2.datos());\n\n/*\nSalida: Nombre: Nerea\n        Apellido: Zelaieta\n        Tel\u00e9fono: 666-666-666\n        Provincia: Guipuzcoa\n        Nombre: Roberto\n        Apellido: Mendiburu\n        Tel\u00e9fono: 333-666-666\n        Provincia: Guipuzcoa\n*/\n</code></pre> </p> <p>Veamos un ejemplo de objeto:</p> ejemplo.js<pre><code>const usuario = {\n    nombre: 'Roberto',\n    apellido: 'Mendiburu',\n    telefono: '333-666-666',\n\n    mostrar() {\n        console.log(this);\n    }\n};\n\nusuario.mostrar();\n\n/*\nSalida: Nombre: Roberto\n        Apellido: Mendiburu\n        Tel\u00e9fono: 333-666-666\n        mostrar: [Function: mostrar]\n*/\n</code></pre> <p>Cuando se crea una funci\u00f3n dentro de un objeto, esta funci\u00f3n  pasa a llamarse m\u00e9todo. El this hace referencia al objeto que lo envuelve. La ejecuci\u00f3n de este c\u00f3digo nos imprime el objeto completo que el this hace referencia.  </p> <p>Veamos un ejemplo simple:</p> ejemplo.js<pre><code>function usuario() {\n    console.log(this);\n}\n\nconsole.log(usuario()); // Object [global]\n\n/*\nSalida: Object [global]\n*/\n</code></pre> <p>Hace referencia al objeto global.</p> <p> </p>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/","title":"2. \u00bfCu\u00e1les son algunos tipos de datos JS?","text":"<p>Los tipos de datos en JavaScript son atributos que determinan el tipo de valor que puede contener una variable. Estos tipos de datos son utilizados para representar diferentes tipos de informaci\u00f3n.</p> <p>JavaScript es un lenguaje de programaci\u00f3n de tipado din\u00e1mico, lo que significa que no es necesario declarar expl\u00edcitamente el tipo de una variable al momento de su creaci\u00f3n. Pero eso no significa que JavaScript no tenga tipos. Simplemente el tipo se determina autom\u00e1ticamente cuando se asigna un valor. </p>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/#21-tipos-de-datos-primitivos","title":"2.1. Tipos de datos primitivos","text":"<p>Los tipos de datos primitivos son aquellos que representan valores individuales y no tienen m\u00e9todos o propiedades. Son inmutables, lo que significa que no se pueden cambiar una vez que se han creado.</p> <ul> <li>Cadena de texto (string)</li> <li>N\u00fameros (number)</li> <li>Booleano (boolean)</li> <li>Valor null</li> <li>Valor undefined </li> </ul>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/#string","title":"string:","text":"<p>El tipo de datos <code>string</code> representa una secuencia de caracteres, como texto o palabras. Las cadenas se deben encerrar entre comillas simples <code>' '</code> o dobles <code>\" \"</code>.</p> <pre><code>let nombre = 'Roberto';\nlet mensaje = \"\u00a1Hola mundo!\";\n</code></pre>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/#number","title":"number:","text":"<p>El tipo de datos <code>number</code> en JavaScript representa tanto n\u00fameros enteros como de punto flotante.</p> <pre><code>let edad = 36;\nlet precio = 99.95;\n</code></pre>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/#boolean","title":"boolean:","text":"<p>El tipo de datos <code>boolean</code> representa un valor de verdad, que puede ser <code>true</code> (verdadero) o <code>false</code> (falso). Es \u00fatil en expresiones condicionales y l\u00f3gicas.</p> <pre><code>let esHombre = true;\nlet esMujer = false;\n</code></pre>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/#null","title":"null:","text":"<p>En JavaScript, <code>null</code> es un valor especial que representa la ausencia intencional de cualquier objeto o valor.</p> <pre><code>let Unidades = null;\n</code></pre>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/#undefined","title":"undefined:","text":"<p>El valor <code>undefined</code> indica que una variable ha sido declarada pero a\u00fan no se le ha asignado ning\u00fan valor.</p> <p><pre><code>let unidades;\nconsole.log(unidades); // Salida: undefined\n</code></pre> </p>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/#22-tipos-de-datos-compuestos","title":"2.2. Tipos de datos compuestos","text":"<p>Los tipos de datos compuestos en JavaScript son aquellos que pueden contener m\u00faltiples valores y tienen m\u00e9todos y propiedades. Son mutables, lo que significa que pueden cambiar despu\u00e9s de su creaci\u00f3n.</p> <ul> <li>Arrays (array)</li> <li>Objetos (object) </li> </ul>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/#array","title":"array:","text":"<p>Los arrays en JavaScript son objetos especiales que permiten almacenar m\u00faltiples valores en una sola variable, indexados num\u00e9ricamente.</p> <pre><code>let animales = ['perro', 'oveja', 'caballo'];\n</code></pre>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/#object","title":"object:","text":"<p>Los objetos en JavaScript son colecciones de pares clave-valor, donde la clave es una cadena (o s\u00edmbolo) y el valor puede ser cualquier tipo de dato, incluidos otros objetos.</p> <p><pre><code>let persona = {\n    nombre: 'Roberto',\n    edad: 36,\n    casado: true\n};\n</code></pre> </p>"},{"location":"devcamp/checkpoint-07/tres-funciones-de-string-js/","title":"3. \u00bfCu\u00e1les son las tres funciones de String en JS?","text":"<p>JavaScript ofrece numerosas funciones predefinidas que facilitan el trabajo con cadenas de texto (string). Entre las posibilidades que ofrecen estas funciones tenemos el <code>replace()</code>, <code>toLowerCase()</code>, <code>toUpperCase()</code>, etc.</p>"},{"location":"devcamp/checkpoint-07/tres-funciones-de-string-js/#replace","title":"replace():","text":"<p>El m\u00e9todo .replace acepta dos argumentos: la cadena que se reemplazar\u00e1 y con qu\u00e9 se reemplazar\u00e1 la cadena. Las cadenas en JavaScript son inmutables, el m\u00e9todo <code>replace()</code> no cambia el valor de la cadena especificada, nos devuelve un nuevo valor.</p> ejemplo.js<pre><code>let nombre = 'Roberto@gmail.com';\n\nlet resultado = nombre.replace('@gmail.com', '');\n\nconsole.log(resultado); // Salida: Roberto\nconsole.log(nombre); // Salida: Roberto@gmail.com\n</code></pre>"},{"location":"devcamp/checkpoint-07/tres-funciones-de-string-js/#tolowercase","title":"toLowerCase():","text":"<p>Las cadenas en JavaScript son inmutables, el m\u00e9todo <code>toLowerCase()</code> no cambia el valor de la cadena especificada, nos devuelve un nuevo valor.</p> ejemplo.js<pre><code>let nombre = 'Roberto';\n\nlet resultado = nombre.toLowerCase();\n\nconsole.log(resultado); // Salida: roberto\nconsole.log(nombre); // Salida: Roberto\n</code></pre>"},{"location":"devcamp/checkpoint-07/tres-funciones-de-string-js/#touppercase","title":"toUpperCase():","text":"<p>Las cadenas en JavaScript son inmutables, el m\u00e9todo <code>toUpperCase()</code> no cambia el valor de la cadena especificada, nos devuelve un nuevo valor.</p> <p>ejemplo.js<pre><code>let nombre = 'Roberto';\n\nlet resultado = nombre.toUpperCase();\n\nconsole.log(resultado); // Salida: ROBERTO\nconsole.log(nombre); // Salida: Roberto\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/","title":"Checkpoint 08","text":""},{"location":"devcamp/checkpoint-08/#documentacion-javascript","title":"Documentaci\u00f3n JavaScript","text":"<p>\u00cdNDICE CHECKPOINT 08</p> <ol> <li>\u00bfQu\u00e9 tipo de bucles hay en JS?</li> <li>\u00bfCu\u00e1les son las diferencias entre const, let y var?</li> <li>\u00bfQu\u00e9 es una funci\u00f3n de flecha?</li> <li>\u00bfQu\u00e9 es la deconstrucci\u00f3n de variables?</li> <li>\u00bfQu\u00e9 hace el operador de extensi\u00f3n en JS?</li> <li>\u00bfQu\u00e9 es la programaci\u00f3n orientada a objetos?</li> <li>\u00bfQu\u00e9 es una promesa en JS?</li> <li>\u00bfQu\u00e9 hacen async y await por nosotros? </li> </ol>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/","title":"3. \u00bfQu\u00e9 es una funci\u00f3n de flecha?","text":"<p>Las funciones flecha permiten escribir funciones de manera m\u00e1s concisa y legible, especialmente cuando se trata de funciones cortas o funciones de una sola l\u00ednea.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#sintaxis-de-una-funcion-flecha","title":"Sintaxis de una funci\u00f3n flecha:","text":"<ul> <li> <p>La sintaxis b\u00e1sica de una funci\u00f3n flecha es la siguiente: () =&gt; {}</p> <ul> <li>() Se utiliza para pasarle atributos a una funci\u00f3n</li> <li>=&gt; Se define como funci\u00f3n flecha, es una funci\u00f3n an\u00f3nima sin nombre</li> <li>{} Se utiliza para envolver el cuerpo de la funci\u00f3n  </li> </ul> </li> <li> <p>Las funci\u00f3nes flecha, pueden ser de varios tipos:</p> <ul> <li>Multil\u00ednea</li> <li>Monol\u00ednea</li> </ul> </li> </ul> <p> Una funci\u00f3n flecha es simplemente una expresi\u00f3n de funci\u00f3n compacta frente a una expresi\u00f3n de funci\u00f3n tradicional. A diferencia de una declaraci\u00f3n de funci\u00f3n, las de expresi\u00f3n de funci\u00f3n siempre deben acabar en punto y coma.</p> <p></p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#31-tipos-de-funciones","title":"3.1. Tipos de funci\u00f3nes:","text":"<p>Antes de nada, veamos una comparativa entre diferentes tipos de funciones, esto es de vital importancia para entender como funciona cada uno, en que se relacionan y en que situaciones es conveniente utilizar uno u otro.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-1","title":"Ejemplo 1","text":"<p>En este ejemplo, vamos a comparar 4 tipos de funci\u00f3n equivalentes y ver en que se diferencian. Para ello, hemos utilizado una declaraci\u00f3n de funci\u00f3n, una expresi\u00f3n de funci\u00f3n, una expresi\u00f3n de funci\u00f3n flecha y una expresi\u00f3n de funci\u00f3n flecha conciso. Ninguno incluye atributos.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#declaracion-de-funcion-multilinea-llamada","title":"Declaraci\u00f3n de funci\u00f3n (multil\u00ednea) + llamada:","text":"<ul> <li>Si no contiene atributos, los par\u00e9ntesis estar\u00e1n vac\u00edos, pero deben estar presentes.</li> <li>Al ser una funci\u00f3n multil\u00ednea, las llaves deben estar presentes.</li> <li>Al ser una declaraci\u00f3n de funci\u00f3n, no lleva punto y coma al final.</li> </ul> <pre><code>function cliente() {\n    console.log('\u00a1Bienvenido!');\n}\n\ncliente(); // Salida: \u00a1Bienvenido!\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#expresion-de-funcion-multilinea-llamada","title":"Expresi\u00f3n de funci\u00f3n (multil\u00ednea) + llamada:","text":"<ul> <li>Si no contiene atributos, los par\u00e9ntesis estar\u00e1n vac\u00edos, pero deben estar presentes.</li> <li>Al ser una funci\u00f3n multil\u00ednea, las llaves deben estar presentes.</li> <li>Al ser una expresi\u00f3n de funci\u00f3n, lleva punto y coma al final.</li> </ul> <pre><code>const cliente = function() {\n    console.log('\u00a1Bienvenido!');\n};\n\ncliente(); // Salida: \u00a1Bienvenido!\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#expresion-de-funcion-flecha-multilinea-llamada","title":"Expresi\u00f3n de funci\u00f3n flecha (multil\u00ednea) + llamada:","text":"<ul> <li>Si no contiene atributos, los par\u00e9ntesis estar\u00e1n vac\u00edos, pero deben estar presentes.</li> <li>Al ser una funci\u00f3n multil\u00ednea, las llaves deben estar presentes.</li> <li>Al ser una expresi\u00f3n de funci\u00f3n, lleva punto y coma al final.</li> </ul> <pre><code>const cliente = () =&gt; {\n    console.log('\u00a1Bienvenido!');\n};\n\ncliente(); // Salida: \u00a1Bienvenido!\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#expresion-de-funcion-flecha-conciso-monolinea-llamada","title":"Expresi\u00f3n de funci\u00f3n flecha conciso (monol\u00ednea) + llamada:","text":"<ul> <li>Si no contiene atributos, los par\u00e9ntesis estar\u00e1n vac\u00edos, pero deben estar presentes.</li> <li>Al ser una funci\u00f3n monol\u00ednea, las llaves pueden omitirse.</li> <li>Al ser una expresi\u00f3n de funci\u00f3n, lleva punto y coma al final.</li> </ul> <pre><code>const cliente = () =&gt; console.log('\u00a1Bienvenido!');\n\ncliente(); // Salida: \u00a1Bienvenido!\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-2","title":"Ejemplo 2","text":"<p>Veamos el segundo ejemplo, esta vez, le pasamos 1 atributo en la funci\u00f3n.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-multilinea-1-atributo","title":"Funci\u00f3n flecha (multil\u00ednea) + 1 atributo:","text":"<ul> <li>Las funciones flecha con un solo atributo, los par\u00e9ntesis pueden omitirse.</li> <li>Al ser una funci\u00f3n multil\u00ednea, las llaves deben estar presentes.</li> <li>Al ser una expresi\u00f3n de funci\u00f3n, lleva punto y coma al final.</li> </ul> <pre><code>const cliente = (nombre) =&gt; { // antes\n    console.log(`${nombre}`);\n};\n\nconst cliente = nombre =&gt; { // despues\n    console.log(`${nombre}`);\n};\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-conciso-monolinea-1-atributo","title":"Funci\u00f3n flecha conciso (monol\u00ednea) + 1 atributo:","text":"<ul> <li>Las funciones flecha con un solo atributo, los par\u00e9ntesis pueden omitirse.</li> <li>Al ser una funci\u00f3n monol\u00ednea, las llaves pueden omitirse.</li> <li>Al ser una expresi\u00f3n de funci\u00f3n, lleva punto y coma al final.</li> </ul> <pre><code>const cliente = (nombre) =&gt; { console.log(`${nombre}`) }; // antes\n\nconst cliente = nombre =&gt; console.log(`${nombre}`); // despues\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-3","title":"Ejemplo 3","text":"<p>Veamos el tercer ejemplo, esta vez, le pasamos 1 argumento en la llamada.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-multilinea-1-argumento-en-la-llamada","title":"Funci\u00f3n flecha (multil\u00ednea) + 1 argumento en la llamada:","text":"<pre><code>const cliente = nombre =&gt; {\n    console.log(`${nombre}`);\n};\n\ncliente('Roberto'); // Salida: Roberto\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-conciso-monolinea-1-argumento-en-la-llamada","title":"Funci\u00f3n flecha conciso (monol\u00ednea) + 1 argumento en la llamada:","text":"<pre><code>const cliente = nombre =&gt; console.log(`${nombre}`);\n\ncliente('Roberto'); // Salida: Roberto\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-4","title":"Ejemplo 4","text":"<p>Veamos el cuarto ejemplo, a diferencia del segundo ejemplo, aqui le pasamos 2 atributos en la funci\u00f3n y 2 argumentos en la llamada a la funci\u00f3n.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-2-atributos-2-argumentos","title":"Funci\u00f3n flecha + 2 atributos + 2 argumentos:","text":"<ul> <li>Las funciones flecha con mas de un atributo, los par\u00e9ntesis deben estar presentes.</li> <li>Al ser una funci\u00f3n multil\u00ednea, las llaves deben estar presentes.</li> <li>Al ser una expresi\u00f3n de funci\u00f3n, lleva punto y coma al final.</li> </ul> <pre><code>const cliente = (nombre, apellido) =&gt; {\n    console.log(`${nombre} ${apellido}`);\n};\n\ncliente('Roberto', 'Mendiburu'); // Salida: Roberto Mendiburu\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-conciso-2-atributos-2-argumentos","title":"Funci\u00f3n flecha conciso + 2 atributos + 2 argumentos:","text":"<ul> <li>Las funciones flecha con mas de un atributo, los par\u00e9ntesis deben estar presentes.</li> <li>Al ser una funci\u00f3n monol\u00ednea, las llaves pueden omitirse.</li> <li>Al ser una expresi\u00f3n de funci\u00f3n, lleva punto y coma al final.</li> </ul> <pre><code>const cliente = (nombre, apellido) =&gt; console.log(`${nombre} ${apellido}`);\n\ncliente('Roberto', 'Mendiburu'); // Salida: Roberto Mendiburu\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#32-tipos-de-funciones-flecha","title":"3.2. Tipos de funci\u00f3nes flecha:","text":"<p>Las funciones flecha (arrow functions) son indudablemente una de las caracter\u00edsticas m\u00e1s populares de ES6 (EcmaScript 6). Ellas introducen una nueva forma de escribir funciones concisas. Es importante notar que las funciones flecha son an\u00f3nimas, lo que significa que no tienen nombre y no se pueden utilizar como metodos ni constructores dentro de una clase.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#caracteristicas","title":"Caracter\u00edsticas:","text":"<ul> <li>Siempre son expresiones.</li> <li>Siempre deberemos asignar la expresi\u00f3n a una variable.</li> <li>Pueden ser de varios tipos:<ul> <li>Expresi\u00f3n de funci\u00f3n flecha (multil\u00ednea)</li> <li>Expresi\u00f3n de funci\u00f3n flecha conciso (monol\u00ednea) </li> </ul> </li> </ul>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#expresion-de-funcion-flecha-multilinea","title":"Expresi\u00f3n de funci\u00f3n flecha (multil\u00ednea):","text":"<p>Esta funci\u00f3n, esta construido en bloque. Al no estar toda la funci\u00f3n en una misma l\u00ednea, se trataria de una expresi\u00f3n de funci\u00f3n flecha (multil\u00ednea) y no obtendria las caracter\u00edsticas de un (monol\u00ednea).</p> <ul> <li>Al ser una expresi\u00f3n de funci\u00f3n, debe asignarse a una variable.</li> <li>La expresi\u00f3n de funci\u00f3n flecha elimina la palabra clave function.</li> <li>Una funci\u00f3n flecha con mas de un atributo, los par\u00e9ntesis deben estar presentes.</li> <li>Al ser una funci\u00f3n multil\u00ednea, las llaves deben estar presentes.</li> <li>Al ser una funci\u00f3n multil\u00ednea, el return debe estar presente.</li> <li>Al ser una expresi\u00f3n de funci\u00f3n, lleva punto y coma al final.</li> </ul>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-2-atributos-2-argumentos_1","title":"Funci\u00f3n flecha + 2 atributos + 2 argumentos:","text":"<pre><code>const sumar = (a, b) =&gt; {\n    return a + b;\n};\n\nconst resultado = sumar(2, 6);\nconsole.log(resultado); // Salida: 8\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-3-atributos-3-argumentos","title":"Funci\u00f3n flecha + 3 atributos + 3 argumentos:","text":"<p><pre><code>const cliente = (nombre, apellido, telefono) =&gt; {\n    return `${nombre} ${apellido} ${telefono}`;\n};\n\nconst resultado = cliente('Roberto', 'Mendiburu', '666-666-666');\nconsole.log(resultado); // Salida: Roberto Mendiburu 666-666-666\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#expresion-de-funcion-flecha-conciso-monolinea","title":"Expresi\u00f3n de funci\u00f3n flecha conciso (monol\u00ednea):","text":"<p>En este ejemplo, podemos observar c\u00f3mo la expresi\u00f3n de funci\u00f3n flecha conciso elimina la necesidad de escribir la palabra clave function, las llaves {} y la declaraci\u00f3n return, resultando en una expresi\u00f3n m\u00e1s compacta.</p> <ul> <li>Al ser una expresi\u00f3n de funci\u00f3n, debe asignarse a una variable.</li> <li>La expresi\u00f3n de funci\u00f3n flecha elimina la palabra clave function.</li> <li>Una funci\u00f3n flecha con mas de un atributo, los par\u00e9ntesis deben estar presentes.</li> <li>Al ser una funci\u00f3n monol\u00ednea, las llaves pueden omitirse.</li> <li>Al ser una funci\u00f3n monol\u00ednea, el return puede omitirse.</li> <li>Al ser una expresi\u00f3n de funci\u00f3n, lleva punto y coma al final.</li> </ul>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-conciso-2-atributos-2-argumentos_1","title":"Funci\u00f3n flecha conciso + 2 atributos + 2 argumentos:","text":"<pre><code>const sumar = (a, b) =&gt; a + b;\n\nconst resultado = sumar(2, 6);\nconsole.log(resultado); // Salida: 8\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-conciso-3-atributos-3-argumentos","title":"Funci\u00f3n flecha conciso + 3 atributos + 3 argumentos:","text":"<pre><code>const cliente = (nombre, apellido, telefono) =&gt; `${nombre} ${apellido} ${telefono}`;\n\nconst resultado = cliente('Roberto', 'Mendiburu', '666-666-666');\nconsole.log(resultado); // Salida: Roberto Mendiburu 666-666-666\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#33-analisis-de-funciones","title":"3.3. An\u00e1lisis de funciones:","text":"<p>Veamos una comparativa entre 3 tipos de funciones \ud83d\udc47</p> <ul> <li>Opci\u00f3n 1: Funci\u00f3n tradicional</li> <li>Opci\u00f3n 2: Funci\u00f3n flecha</li> <li>Opci\u00f3n 3: Funci\u00f3n flecha conciso</li> </ul> ejemplo.js<pre><code>// Opci\u00f3n 1:\n// Declaraci\u00f3n de funci\u00f3n + 3 atributos - multil\u00ednea\nfunction cliente(nombre, apellido, telefono) {\n    return `${nombre} ${apellido} ${telefono}`;\n}\n\nconst resultado_1 = cliente('Roberto', 'Mendiburu', '666-666-666');\nconsole.log(resultado_1); // Salida: Roberto Mendiburu 666-666-666\n\n\n\n// Opci\u00f3n 2:\n// Expresi\u00f3n de funci\u00f3n flecha + 3 atributos - multil\u00ednea\nconst cliente = (nombre, apellido, telefono) =&gt; {\n    return `${nombre} ${apellido} ${telefono}`;\n};\n\nconst resultado_2 = cliente('Roberto', 'Mendiburu', '666-666-666');\nconsole.log(resultado_2); // Salida: Roberto Mendiburu 666-666-666\n\n\n\n// Opci\u00f3n 3:\n// Expresi\u00f3n de funci\u00f3n flecha conciso + 3 atributos - monol\u00ednea\nconst cliente = (nombre, apellido, telefono) =&gt; `${nombre} ${apellido} ${telefono}`;\n\nconst resultado_3 = cliente('Roberto', 'Mendiburu', '666-666-666');\nconsole.log(resultado_3); // Salida: Roberto Mendiburu 666-666-666\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#diferencias-entre-funciones","title":"Diferencias entre funciones:","text":"<p> Las funciones flecha pueden componerse de m\u00e1s de una l\u00ednea, lo cual ya nos obligar\u00e1 a emplear las llaves y el return.</p> <p></p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#34-funciones-con-this","title":"3.4. Funciones con \"this\":","text":"<p>La palabra clave \"this\" tendra efecto dentro de una funci\u00f3n o clase que la envuelve. Utilizamos \"this\" para acceder a las distintas propiedades de una funci\u00f3n o clase.</p> <p>Veamos el uso de \"this\" con diferentes tipos de funciones:</p> <ul> <li>Ejemplo 1: Funci\u00f3n de expresi\u00f3n (multil\u00ednea)</li> <li>Ejemplo 2: Funci\u00f3n flecha (multil\u00ednea)</li> <li>Ejemplo 3: Funci\u00f3n flecha conciso (monol\u00ednea)</li> </ul>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-1_1","title":"Ejemplo 1","text":"<p>En este ejemplo, se crea una declaraci\u00f3n de funci\u00f3n llamada Factura y se le pasa 1 atributo. Dentro de esta funci\u00f3n, se crea una funci\u00f3n de expresi\u00f3n referenciando a la variable total pasado por \"this\".</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#declaracion-de-funcion-funcion-de-expresion-this-1-atributo-1-argumento","title":"Declaraci\u00f3n de funci\u00f3n + funci\u00f3n de expresi\u00f3n + this + 1 atributo + 1 argumento:","text":"<p><pre><code>function Factura(subTotal) {\n  this.iva = 0.21;\n  this.subTotal = subTotal;\n\n  this.total = function() {\n    return ((this.iva * this.subTotal) + this.subTotal);\n  };\n}\n\nconst totalFactura = new Factura(200);\nconsole.log(totalFactura.total()); // Salida: 242\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-2_1","title":"Ejemplo 2","text":"<p>Veamos el segundo ejemplo, se crea una declaraci\u00f3n de funci\u00f3n llamada Factura y se le pasa 1 atributo. Dentro de esta funci\u00f3n, (aqui viene la diferencia respecto al ejempo 1) se crea una funci\u00f3n flecha referenciando a la variable total pasado por \"this\".</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#declaracion-de-funcion-funcion-flecha-this-1-atributo-1-argumento","title":"Declaraci\u00f3n de funci\u00f3n + funci\u00f3n flecha + this + 1 atributo + 1 argumento:","text":"<p><pre><code>function Factura(subTotal) {\n    this.iva = 0.21;\n    this.subTotal = subTotal;\n\n    this.total = () =&gt; {\n        return ((this.iva * this.subTotal) + this.subTotal);\n    };\n}\n\nconst totalFactura = new Factura(200);\nconsole.log(totalFactura.total()); // Salida: 242\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-3_1","title":"Ejemplo 3","text":"<p>Veamos el tercer ejemplo, se crea una declaraci\u00f3n de funci\u00f3n llamada Factura y se le pasa 1 atributo. Dentro de esta funci\u00f3n, se crea una funci\u00f3n flecha conciso referenciando a la variable total pasado por \"this\".</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#declaracion-de-funcion-funcion-flecha-conciso-this-1-atributo-1-argumento","title":"Declaraci\u00f3n de funci\u00f3n + funci\u00f3n flecha conciso + this + 1 atributo + 1 argumento:","text":"<p><pre><code>function Factura(subTotal) {\n    this.iva = 0.21;\n    this.subTotal = subTotal;\n\n    this.total = () =&gt; ((this.iva * this.subTotal) + this.subTotal);\n}\n\nconst totalFactura = new Factura(200);\nconsole.log(totalFactura.total()); // Salida: 242\n</code></pre> El uso de funci\u00f3n flecha es limitada, no se puede utilizar como metodo ni constructor dentro de una clase.</p> <p></p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#35-objetos-y-metodos-con-this","title":"3.5. Objetos y m\u00e9todos con \"this\":","text":"<p>Cuando se crea una funci\u00f3n dentro de un objeto, esta funci\u00f3n pasa a llamarse m\u00e9todo. El m\u00e9todo, no incorpora la palabra clave function ni tampoco hace falta referenciarla a una variable como ocurre en la expresi\u00f3n de funci\u00f3n. Un m\u00e9todo debe tener nombre, no puede ser an\u00f3nimo.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-1_2","title":"Ejemplo 1","text":"<p>En este ejemplo, incorpora un m\u00e9todo al objeto.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#objeto-metodo-this","title":"Objeto + m\u00e9todo + \"this\":","text":"<p><pre><code>const usuario = {\n    nombre: 'Roberto',\n    apellido: 'Mendiburu',\n    telefono: '333-666-666',\n\n    mostrar() {\n        console.log(this);\n    }\n};\n\nusuario.mostrar();\n\n/* Salida:\n\n{\nNombre: Roberto\nApellido: Mendiburu\nTel\u00e9fono: 333-666-666\nmostrar: [Function: mostrar]\n}\n\n*/\n</code></pre> </p> <p>Ve\u00e1mos que ocurre si cambiamos el m\u00e9todo por una funci\u00f3n flecha: <pre><code>const usuario = {\n    nombre: 'Roberto',\n    apellido: 'Mendiburu',\n    telefono: '333-666-666',\n\n    () =&gt; {\n        console.log(this);\n    };\n};\n\nusuario; // no podemos llamar al m\u00e9todo flecha porque no tiene nombre.\n\n/* Salida:\n\nSyntaxError\n\n*/\n</code></pre> Lo que ocurre aqu\u00ed es que, al tratarse de una funci\u00f3n an\u00f3nima, no podemos llamarla de ninguna manera, por eso nos devuelve un error de sintaxis.</p> <ul> <li>Las funci\u00f3nes flecha, no pueden ser usados como m\u00e9todos, dentro de un objeto o clase.</li> </ul> <p></p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#36-objetos-y-funciones-con-this","title":"3.6. Objetos y funciones con \"this\":","text":"<p>Mostremos la diferencia en cuanto al uso de \"this\" en las funciones tradicionales y las funciones flecha.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-1_3","title":"Ejemplo 1","text":"<p>En este ejemplo, incorpora una funci\u00f3n como propiedad del objeto.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#objeto-funcion-de-expresion-this","title":"Objeto + funci\u00f3n de expresi\u00f3n + \"this\":","text":"<p><pre><code>const cliente = { \n    nombre: 'Roberto',\n    apellido: 'Mendiburu',\n\n    nombreCompleto: function() {\n        console.log(\"this es: \", this); \n        console.log(`Cliente: ${this.nombre} ${this.apellido}`);\n    }\n};\n\n\ncliente.nombreCompleto();\n\n/* Salida:\n\nthis es: {\n    nombre: 'Roberto',\n    apellido: 'Mendiburu',\n    nombreCompleto: [Function: nombreCompleto]\n}   \nCliente: Roberto Mendiburu\n\n*/\n</code></pre> </p> <p>Ve\u00e1mos que ocurre si sacamos a la funci\u00f3n fuera del objeto: <pre><code>const cliente = { \n    nombre: 'Roberto',\n    apellido: 'Mendiburu'\n};\n\nconst nombreCompleto = function() {\n    console.log(\"this es: \", this); \n    console.log(`Cliente: ${this.nombre} ${this.apellido}`);\n};\n\n\nnombreCompleto(cliente);\n\n/* Salida:\n\nthis es:  Object [global] {etc.}\nCliente: undefined undefined\n\n*/\n</code></pre> Nos devuelve un resultado distinto.</p> <ul> <li>El \"this\" hace referencia al objeto global (window) ya que no tiene al objeto anterior envolviendolo.</li> </ul> <p></p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-2_2","title":"Ejemplo 2","text":"<p>En este ejemplo, incorpora una funci\u00f3n flecha como propiedad del objeto.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#objeto-funcion-de-expresion-flecha-this","title":"Objeto + funci\u00f3n de expresi\u00f3n flecha + \"this\":","text":"<p><pre><code>const cliente = { \n    nombre: 'Roberto',\n    apellido: 'Mendiburu',\n\n    nombreCompleto: () =&gt; {\n        console.log(\"this es: \", this); \n        console.log(`Cliente: ${this.nombre} ${this.apellido}`);\n    }\n};\n\n\ncliente.nombreCompleto();\n\n/* Salida:\n\nthis es:  {}\nCliente: undefined undefined\n\n*/\n</code></pre> El comportamiento del \"this\" en expresi\u00f3n de funci\u00f3n flecha es distinto al de expresi\u00f3n de funci\u00f3n cuando quiere referenciar al objeto.</p> <ul> <li>El \"this\" queda atrapado dentro de la funci\u00f3n flecha sin valor.</li> </ul> <p></p> <p>Ve\u00e1mos de nuevo que ocurre si sacamos a la funci\u00f3n fuera del objeto: <pre><code>const cliente = { \n    nombre: 'Roberto',\n    apellido: 'Mendiburu'\n};\n\nconst nombreCompleto = () =&gt; {\n    console.log(\"this es: \", this); \n    console.log(`Cliente: ${this.nombre} ${this.apellido}`);\n};\n\n\nnombreCompleto(cliente);\n\n/* Salida:\n\nthis es:  {}\nCliente: undefined undefined\n\n*/\n</code></pre> \u00c9sta vez nos devuelve el mismo resultado.</p> <ul> <li>El \"this\" vuelve a quedarse atrapado dentro de la funci\u00f3n flecha sin valor.</li> </ul> <p></p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-3_2","title":"Ejemplo 3","text":"<p>LLegado aqu\u00ed, te preguntaras si es posible acceder a las propiedades del objeto desde fuera de ella utilizando \"this\". La respuesta es que si, hay un m\u00e9todo para las funciones que se llama (funci\u00f3n de enlace) \"bind()\" que permite enlazar el \"this\" con el objeto mediante argumento.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#1-objeto-funcion-de-expresion-this-bind","title":"1 Objeto + funci\u00f3n de expresi\u00f3n  + \"this\" + bind():","text":"<p><pre><code>const cliente = {\n    nombre: 'Roberto',\n    apellido: 'Mendiburu'\n};\n\nconst nombreCompleto = function() {\n    alert(`Cliente: ${this.nombre} ${this.apellido}`);\n};\n\nconst enlaceCliente = nombreCompleto.bind(cliente);\n\nenlaceCliente(); // Cliente: Roberto Mendiburu\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#2-objetos-funcion-de-expresion-this-bind","title":"2 Objetos + funci\u00f3n de expresi\u00f3n  + \"this\" + bind():","text":"<p><pre><code>const cliente_1 = {\n    nombre: 'Roberto',\n    apellido: 'Mendiburu'\n};\n\nconst cliente_2 = {\n    nombre: 'Julen',\n    apellido: 'Mendoza'\n};\n\nconst nombreCompleto = function() {\n    alert(`Cliente: ${this.nombre} ${this.apellido}`);\n};\n\nconst enlaceCliente_1 = nombreCompleto.bind(cliente_1);\nconst enlaceCliente_2 = nombreCompleto.bind(cliente_2);\n\nenlaceCliente_1(); // Cliente: Roberto Mendiburu\nenlaceCliente_2(); // Cliente: Julen Mendoza\n</code></pre> </p> <p>Ve\u00e1mos que ocurre con la funci\u00f3n flecha:  <pre><code>const cliente = {\n    nombre: 'Roberto',\n    apellido: 'Mendiburu'\n};\n\nconst nombreCompleto = () =&gt; {\n    alert(`Cliente: ${this.nombre} ${this.apellido}`);\n};\n\nconst enlaceCliente = nombreCompleto.bind(cliente);\n\nenlaceCliente(); // Cliente: undefined undefined\n</code></pre> Cabe recordar, que el \"this\" tampoco funciona con el m\u00e9todo \"bind()\" en funci\u00f3n flecha.</p> <ul> <li>El \"this\" queda atrapado dentro de la funci\u00f3n flecha sin valor.</li> </ul> <p>La \u00fanica manera de enlazar el \"this\" con el objeto desde fuera de ella es con el uso de funci\u00f3n de expresi\u00f3n + \"bind()\". As\u00ed es como trabaja el m\u00e9todo (funci\u00f3n de enlace).</p> <p></p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#editor-de-codigo-utilizado","title":"Editor de c\u00f3digo utilizado:","text":"<ul> <li>Programiz - JavaScript Online Compiler  </li> </ul>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/","title":"6. \u00bfQu\u00e9 es la programaci\u00f3n orientada a objetos?","text":"<p>La programaci\u00f3n orientada a objetos (POO) es un paradigma de la programaci\u00f3n en el que se crean objetos para la manipulaci\u00f3n de datos y donde, por lo general, cada objeto ofrece una funcionalidad especial.</p> <ul> <li>La idea b\u00e1sica de la POO es el uso de objetos para modelar cosas del mundo real.</li> <li>POO nos ayuda a la reutilizaci\u00f3n del c\u00f3digo.</li> </ul> <p>Imagina que tienes un colegio o escuela con 1000 estudiantes y 100 profesores, ser\u00eda il\u00f3gico estar construyendo objetos para cada uno de ellos. Las clases son, como una especie de m\u00e1quina constructora de objetos al momento segun demanda.</p> <p>Hay de varios tipos:</p> <ul> <li>Funci\u00f3n constructora (antiguo)</li> <li>Clase (actual)</li> </ul> <p></p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#61-funciones-constructoras","title":"6.1. Funciones constructoras:","text":"<ul> <li>Un nombre de funci\u00f3n constructora generalmente comienza con una letra may\u00fascula. Esta convenci\u00f3n se utiliza para hacer que la funci\u00f3n constructora sean m\u00e1s f\u00e1cil de reconocer en el c\u00f3digo.</li> <li>La palabra clave new se usa para crear una nueva instancia del objeto (crear un nuevo objeto)</li> </ul>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#declaracion-de-funcion-1-atributo-instancia","title":"Declaraci\u00f3n de funci\u00f3n + 1 atributo + instancia:","text":"<pre><code>function Persona(nombre) {\n    this.nombre = nombre;\n    this.saludar = function() {\n        return (`${this.nombre} dice, \u00a1hola!`);\n    };\n}\n\nconst persona_1 = new Persona('Markel');\nconst persona_2 = new Persona('Nerea');\n\nconsole.log(persona_1.saludar());\nconsole.log(persona_2.saludar());\n\n/* Salida:\n\nMarkel dice, \u00a1hola!\nNerea dice, \u00a1hola!\n\n*/\n</code></pre>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#el-constructor-object","title":"El constructor Object():","text":"<pre><code>const persona_1 = new Object();\npersona_1.nombre = \"Markel\";\npersona_1.saludar = function() {\n    return (`${this.nombre} dice, \u00a1hola!`);\n};\n\nconsole.log(persona_1.saludar());\n\n/* Salida:\n\nMarkel dice, \u00a1hola!\n\n*/\n</code></pre>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#62-clases","title":"6.2. Clases:","text":"<p>Con la llegada de ES6 (ECMAScript 2015), se introducen las clases en JavaScript que proveen una sintaxis mucho m\u00e1s clara y simple para crear objetos y lidiar con la herencia. Es una mejora sint\u00e1ctica de las funciones constructoras que se basaban en prototipos, \u00e9sto no cambi\u00f3 ni agreg\u00f3 funcionalidad, pero trajo una mejor organizaci\u00f3n del c\u00f3digo.</p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#existen-2-formas-para-definir-una-clase-y-2-tipos-de-expresion-de-clase","title":"Existen 2 formas para definir una clase y 2 tipos de expresi\u00f3n de clase:","text":"<ul> <li>Declaraci\u00f3n de clase</li> <li>Expresi\u00f3n de clase<ul> <li>An\u00f3nima: No tiene un nombre.</li> <li>Nombrada: Tiene un nombre interno que solo es accesible dentro de la clase.</li> </ul> </li> </ul>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#declaracion-de-clase","title":"Declaraci\u00f3n de clase:","text":"<pre><code>class Persona {\n    constructor(nombre) {\n        this.nombre = nombre;\n    }\n}\n</code></pre>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#expresion-de-clase","title":"Expresi\u00f3n de clase:","text":"<p><pre><code>const Persona = class {\n    constructor(nombre) {\n        this.nombre = nombre;\n    }\n};\n</code></pre> Ambos enfoques crean una clase llamada Persona, pero con las expresiones de clases se tiene m\u00e1s flexibilidad para definirlas de forma din\u00e1mica.</p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#expresion-de-clase_1","title":"Expresi\u00f3n de clase:","text":"<p>En el siguiente ejemplo, la clase se define sin un nombre espec\u00edfico (an\u00f3nima) y se asigna a la constante Persona. A partir de ah\u00ed, se puede utilizar de la misma manera que una clase declarada.</p> <pre><code>const Persona = class {\n  constructor(nombre, edad) {\n    this.nombre = nombre;\n    this.edad = edad;\n  }\n\n  saludar() {\n    console.log(`Hola, soy ${this.nombre} y tengo ${this.edad} a\u00f1os.`);\n  }\n};\n\nconst persona_1 = new Persona('Roberto', 34);\n\npersona_1.saludar(); // Hola, soy Roberto y tengo 34 a\u00f1os.\n</code></pre>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#expresion-de-clase-nombrada","title":"Expresi\u00f3n de clase nombrada:","text":"<p>En este ejemplo, la clase PersonaInterna es accesible solo dentro del bloque de la expresi\u00f3n pero no fuera de \u00e9l. Esta caracter\u00edstica permite encapsular el nombre de la clase y evitar conflictos de nombres.</p> <pre><code>const Persona = class PersonaInterna {\n  constructor(nombre) {\n    this.nombre = nombre;\n  }\n\n  saludar() {\n    console.log(`Hola, soy ${this.nombre}.`);\n  }\n};\n\nconst persona_1 = new Persona('Nerea');\npersona_1.saludar(); // Hola, soy Nerea.\n\n// El nombre interno \"PersonaInterna\" no es accesible fuera de la clase\nconsole.log(typeof PersonaInterna); // undefined\n</code></pre>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#cuando-usar-expresion-de-clase","title":"Cu\u00e1ndo usar expresi\u00f3n de clase:","text":"<ul> <li>Clases din\u00e1micas: Cuando necesitas definir clases de forma condicional o dentro de funciones.</li> <li>Mantener el c\u00f3digo limpio: Usa clases an\u00f3nimas si no necesitas referenciar el nombre fuera del bloque.</li> </ul>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#sintaxis-de-una-clase","title":"Sintaxis de una clase:","text":"<p><pre><code>class NombreClase {                       // declaraci\u00f3n de clase + nombre de clase\n    constructor(atributo_1, atributo_2) { // constructor + atributos\n        this.propiedad_1 = atributo_1;    // propiedad de una clase\n        this.propiedad_2 = atributo_2;    // propiedad de una clase\n    }\n\n    metodo_1() { // se nombra un m\u00e9todo\n        return (`Devuelve ${this.propiedad_1} y ${this.propiedad_2}`); // cuerpo de m\u00e9todo\n    }\n}\n\nconst objeto_1 = new NombreClase('argumento_1', 'argumento_2'); // se crea un objeto pasando argumentos\nconsole.log(objeto_1.metodo_1()); // Salida: Devuelve argumento_1 y argumento_2\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-constructor","title":"Clase + constructor:","text":"<p><pre><code>class Persona {\n\n    constructor(nombre) {\n        this.nombre = nombre;\n    }\n}\n\nconst persona_1 = new Persona('Nerea');\nconsole.log(persona_1.nombre); // Salida: Nerea\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-constructor-1-metodo","title":"Clase + constructor + 1 m\u00e9todo:","text":"<p><pre><code>class Persona {\n\n    constructor(nombre) {\n        this.nombre = nombre;\n    }\n\n    nombrePersona() {\n        return (`${this.nombre}`);  \n    }\n}\n\nconst persona_1 = new Persona('Nerea');\nconsole.log(persona_1.nombrePersona()); // Salida: Nerea\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-con-llaves-en-atributos-y-argumentos","title":"Clase con llaves en atributos y argumentos:","text":"<p><pre><code>class Persona {\n\n    constructor({nombre, apellido}) {\n        this.nombre = nombre;\n        this.apellido = apellido;\n    }\n\n    nombreCompleto() {\n        console.log(`${this.nombre} ${this.apellido}`);\n    }\n}\n\nconst persona_1 = new Persona({nombre: 'Markel', apellido:'Mart\u00ednez'});\nconst persona_2 = new Persona({apellido: 'Medina', nombre: 'Gorka'});\n\npersona_1.nombreCompleto();\npersona_2.nombreCompleto();\n\n/* Salida:\n\nMarkel Mart\u00ednez\nGorka Medina\n\n*/\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-sin-llaves-en-atributos-y-argumentos","title":"Clase sin llaves en atributos y argumentos:","text":"<pre><code>class Persona {\n\n    constructor(nombre, apellido) {\n        this.nombre = nombre;\n        this.apellido = apellido;\n    }\n\n    nombreCompleto() {\n        console.log(`${this.nombre} ${this.apellido}`);\n    }\n}\n\nconst persona_1 = new Persona('Markel', 'Mart\u00ednez');\nconst persona_2 = new Persona('Gorka', 'Medina');\n\npersona_1.nombreCompleto();\npersona_2.nombreCompleto();\n\n/* Salida:\n\nMarkel Mart\u00ednez\nGorka Medina\n\n*/\n</code></pre>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#621-metodo-de-instancia","title":"6.2.1. M\u00e9todo de instancia:","text":""},{"location":"devcamp/checkpoint-08/que-es-poo-js/#ejemplo-1","title":"Ejemplo 1","text":"<p>En este ejemplo, el uso de llaves en atributos como en argumentos es necesario para poder renombrar el valor predeterminado del atributo tipo si diese el caso.</p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-constructor-1-valor-de-atributo-predeterminado","title":"Clase + constructor + 1 valor de atributo predeterminado:","text":"<ul> <li>Se declara una clase llamado Persona</li> <li>Se crea un constructor, se le pasa 1 atributo llamado tipo con valor predeterminado, el resto sin valores</li> <li>Se crea un m\u00e9todo llamado descripcion</li> <li>Se crean 2 objetos llamados persona_1, persona_2 y se le pasan argumentos a cada uno.</li> </ul> <p><pre><code>class Persona {\n\n    constructor({tipo = 'alumno', nombre, apellido, edad}) {\n        this.tipo = tipo;\n        this.nombre = nombre;\n        this.apellido = apellido;\n        this.edad = edad;\n    }\n\n    descripcion() {\n        return (`${this.nombre} ${this.apellido} tiene ${this.edad} a\u00f1os y es ${this.tipo}.`);\n    }\n}\n\nconst persona_1 = new Persona({nombre: 'Markel', apellido:'Mart\u00ednez', edad: 36});\nconst persona_2 = new Persona({nombre: 'Gorka', apellido: 'Medina', edad: 45, tipo: 'profesor'});\n\nconsole.log(persona_1.descripcion());\nconsole.log(persona_2.descripcion());\n\n/* Salida:\n\nMarkel Mart\u00ednez tiene 36 a\u00f1os y es alumno.\nGorka Medina tiene 45 a\u00f1os y es profesor.\n\n*/\n</code></pre> </p> <p>Veamos \u00e9ste otro ejemplo con la misma l\u00f3gica: <pre><code>class Coche {\n    constructor({anio, marca, motorizadoPor = 'gasolina'}) {\n        this.anio = anio;\n        this.marca = marca;\n        this.motorizadoPor = motorizadoPor;\n    }\n\n    caracteristicas() {\n        return (`El ${this.marca} ${this.anio} funciona con ${this.motorizadoPor}`)\n    }\n}\n\nconst model3 = new Coche({anio: 2025, marca: 'Tesla', motorizadoPor: 'electricidad'});\n\nconsole.log(model3.caracteristicas());\n\n/* Salida:\n\nEl Tesla 2025 funciona con electricidad\n\n*/\n</code></pre> </p> <p>Veamos una clase sin m\u00e9todo con la misma l\u00f3gica. No se recomienda, esto implica tener que construir la respuesta completa en cada llamada a la clase, se recomienda crear un m\u00e9todo dentro de la clase y llamarlo.</p> <pre><code>class Coche {\n\n    constructor({marca='Tesla', anio, motorizadoPor = 'gasolina'}) {\n        this.marca = marca;\n        this.anio = anio;\n        this.motorizadoPor = motorizadoPor;\n    }\n}\n\nconst model3 = new Coche({anio: 2025, motorizadoPor: 'electricidad'});\n\nconsole.log(`El ${model3.marca} ${model3.anio} funciona con ${model3.motorizadoPor}`);\n\n/* Salida:\n\nEl Tesla 2025 funciona con electricidad\n\n*/\n</code></pre> <p></p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#622-metodo-estatico","title":"6.2.2. M\u00e9todo est\u00e1tico:","text":"<p>Con un m\u00e9todo est\u00e1tico, no requiere crear un objeto mediante instancia para que funcione.</p> <ul> <li> <p>Acceso global: pueden utilizarse en cualquier lugar del c\u00f3digo sin necesidad de crear una instancia de la clase. Esto hace que sean accesibles de manera global y f\u00e1cil de usar.</p> </li> <li> <p>Optimizaci\u00f3n de recursos: al no requerir la creaci\u00f3n de instancias, los m\u00e9todos est\u00e1ticos pueden ser m\u00e1s eficientes en t\u00e9rminos de recursos.</p> </li> <li> <p>Mantenimiento simplicado: cuando un m\u00e9todo no necesita acceder a propiedades de instancia, es recomendable definirlo como est\u00e1tico, lo que simplifica el mantenimiento y reduce la complejidad del c\u00f3digo.</p> </li> </ul>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-metodo-estatico","title":"Clase + m\u00e9todo est\u00e1tico:","text":"<pre><code>class Persona {\n\n    static saludo(nombre) {\n        return (`${nombre} est\u00e1 saludando`);\n    }\n}\n\nconsole.log(Persona.saludo(\"Gorka\"));\n\n/* Salida:\n\nGorka est\u00e1 saludando\n\n*/\n</code></pre>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-metodo-de-instancia-metodo-estatico","title":"Clase + m\u00e9todo de instancia + m\u00e9todo est\u00e1tico:","text":"<p>Supongamos que estamos construyendo un sistema de gesti\u00f3n de usuarios y necesitamos generar un ID \u00fanico para cada usuario.</p> <p>En este caso, el m\u00e9todo est\u00e1tico generarID se utiliza para crear ID \u00fanicos sin necesidad de crear una instancia de la clase Usuario.</p> <pre><code>class Usuario {\n    constructor(nombre) {\n        this.nombre = nombre;\n        this.id = Usuario.generarID();\n\n    } static generarID() {\n        return Math.floor(Math.random() * 1000);\n    }\n}\n\nconst usuario_1 = new Usuario('Nerea');\nconsole.log(usuario_1.id);\n\n/* Salida:\n\nSe genera un n\u00famero (id) \u00fanico de forma aleatoria.\n\n*/\n</code></pre> <p></p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#623-propiedad-estatica","title":"6.2.3. Propiedad est\u00e1tica:","text":"<p>Adem\u00e1s de los m\u00e9todos est\u00e1ticos, las clases en JavaScript tambi\u00e9n pueden tener propiedades est\u00e1ticas, que son variables que pertenecen a la clase en su totalidad y no a las instancias individuales. A partir de ES2022 JavaScript permite definir propiedades est\u00e1ticas de manera m\u00e1s sencilla dentro de la clase. Esto se hace utilizando la palabra clave static antes de la definici\u00f3n de la propiedad.</p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-propiedad-estatica","title":"Clase + propiedad est\u00e1tica:","text":"<p><pre><code>class MiClase {\n    static miPropiedadEstatica = \"Soy una propiedad est\u00e1tica\";\n}\n\nconsole.log(MiClase.miPropiedadEstatica); // Salida: Soy una propiedad est\u00e1tica\n</code></pre> </p> <p>En este caso usuariosMax es una propiedad est\u00e1tica que pertenece a la clase Configuracion. Al ser est\u00e1tica, no puede ser accedida a trav\u00e9s de m\u00e9todos de instancias de la clase. <pre><code>class Configuracion {\n    static usuariosMax = 100;\n}\n\nconsole.log(Configuracion.usuariosMax); // Salida: 100\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#acceso-a-propiedades-estaticas-desde-metodos-estaticos","title":"Acceso a propiedades est\u00e1ticas desde m\u00e9todos est\u00e1ticos:","text":"<p>Los m\u00e9todos est\u00e1ticos pueden acceder a otras propiedades y m\u00e9todos est\u00e1ticos usando this, que en este contexto se refiere a la clase.</p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-propiedad-estatica-metodo-estatico-alcance","title":"Clase + propiedad est\u00e1tica + m\u00e9todo est\u00e1tico + alcance:","text":"<p><pre><code>class Calcular {\n    static iva = 1.21;\n\n    static calcularIva(precioNeto) {\n        return (precioNeto * this.iva) + '\u20ac iva incluido';\n    }\n}\n\nconsole.log(Calcular.calcularIva(100)); // Salida: 121\u20ac\n</code></pre> </p> <p>Veamos un ejemplo donde combinamos m\u00e9todos y propiedades est\u00e1ticas para modelar un sistema de configuraci\u00f3n.</p> <p>version y conexionesMaximas son propiedades est\u00e1ticas de la clase Sistema y el m\u00e9todo obtenerInfo() proporciona informaci\u00f3n relevante sobre el sistema</p> <pre><code>class Sistema {\n    static version = '1.0.0';\n    static conexionesMaximas = 10;\n\n    static obtenerInfo() {\n        return `Versi\u00f3n: ${this.version}, Conexiones m\u00e1ximas: ${this.conexionesMaximas}`;\n    }\n}\n\nconsole.log(Sistema.obtenerInfo()); // Salida: Versi\u00f3n: 1.0.0, Conexiones m\u00e1ximas: 10\n</code></pre>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#buenas-practicas","title":"Buenas pr\u00e1cticas:","text":"<ul> <li>Usa m\u00e9todos est\u00e1ticos para l\u00f3gica no espec\u00edfica de instancias: Ideal para funciones utilitarias, c\u00e1lculos compartidos o valores constantes.</li> <li>Evita abusar de los m\u00e9todos est\u00e1ticos: Usa instancias y m\u00e9todos de instancia cuando necesites trabajar con datos espec\u00edficos de objetos.</li> <li>Organiza las propiedades est\u00e1ticas: Col\u00f3calas al inicio de la clase para mayor claridad.</li> <li>Documenta el prop\u00f3sito de los m\u00e9todos est\u00e1ticos: Deja claro en los comentarios cu\u00e1ndo y por qu\u00e9 un m\u00e9todo debe ser est\u00e1tico.</li> </ul>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#conclusion","title":"Conclusi\u00f3n:","text":"<p>Las propiedades y m\u00e9todos est\u00e1ticos son herramientas poderosas para agregar funcionalidades compartidas a las clases en JavaScript. Son \u00fatiles para crear funciones utilitarias, mantener valores constantes y manejar estados compartidos. Sin embargo, deben usarse con moderaci\u00f3n y no como sustituto de la l\u00f3gica basada en instancias.</p> <p></p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#63-nombres-de-propiedad-computadas","title":"6.3. Nombres de propiedad computadas:","text":"<p>Los nombres de propiedad computadas permiten utilizar una expresi\u00f3n dentro de corchetes ([ ]) para definir el nombre de una propiedad. Esto significa que el nombre de la propiedad se calcula en tiempo de ejecuci\u00f3n en lugar de ser un valor literal. En el contexto de las clases, estas pueden usarse para definir tanto m\u00e9todos como propiedades.</p> <p>Al definir m\u00e9todos en una clase, los nombres de propiedad son \u00fatiles cuando el nombre del m\u00e9todo no se conoce hasta tiempo de ejecuci\u00f3n.</p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#ejemplo-1_1","title":"Ejemplo 1","text":"<p>En este ejemplo, el nombre del m\u00e9todo se calcula a partir del valor de la variable metodoDinamico, lo que permite definir m\u00e9todos de manera m\u00e1s din\u00e1mica.</p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-1-metodo-con-nombre-computado","title":"Clase + 1 m\u00e9todo con nombre computado:","text":"<p><pre><code>const metodoDinamico = 'mostrarNombre';\n\nclass Usuario {\n  constructor(nombre) {\n    this.nombre = nombre;\n  }\n\n  [metodoDinamico]() {\n    console.log(`Nombre del usuario: ${this.nombre}`);\n  }\n}\n\nconst usuario1 = new Usuario('Kristine');\n\nusuario1.mostrarNombre(); // Salida: Nombre del usuario: Kristine\n</code></pre> </p> <p>Los nombres de propiedad computadas son especialmente \u00fatiles en los siguientes escenarios:</p> <ol> <li>Asignaci\u00f3n Din\u00e1mica de Propiedades o M\u00e9todos: Cuando el nombre de una propiedad o m\u00e9todo depende de una entrada del usuario o de otra l\u00f3gica que se ejecuta en tiempo de ejecuci\u00f3n.</li> <li>Configuraci\u00f3n Basada en Datos Externos: Si necesitas definir propiedades basadas en un conjunto de datos din\u00e1mico, los nombres de propiedad computados facilitan este proceso.</li> <li>Evitar Redundancia en C\u00f3digo Repetitivo: Puedes crear m\u00faltiples m\u00e9todos o propiedades usando un patr\u00f3n com\u00fan sin tener que escribir cada uno manualmente.</li> </ol> <p></p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#ejemplo-2","title":"Ejemplo 2","text":"<p>En este ejemplo, los m\u00e9todos se definen usando los valores almacenados en el array acciones, lo que evita la repetici\u00f3n de c\u00f3digo y facilita la creaci\u00f3n de m\u00e9todos con nombres similares.</p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-metodos-con-prefijos-comunes","title":"clase + m\u00e9todos con prefijos comunes:","text":"<p><pre><code>const acciones = ['Iniciar', 'Detener', 'Reiniciar']; // array\n\nclass Maquina {\n  constructor(nombre) {\n    this.nombre = nombre;\n  }\n\n  [acciones[0]]() {\n    console.log(`${this.nombre} est\u00e1 iniciando.`);\n  }\n\n  [acciones[1]]() {\n    console.log(`${this.nombre} se ha detenido.`);\n  }\n\n  [acciones[2]]() {\n    console.log(`${this.nombre} est\u00e1 reiniciando.`);\n  }\n}\n\nconst servidor = new Maquina('Servidor A');\n\nservidor.Iniciar();   // Salida: Servidor A est\u00e1 iniciando.\nservidor.Detener();   // Salida: Servidor A se ha detenido.\nservidor.Reiniciar(); // Salida: Servidor A est\u00e1 reiniciando.\n</code></pre>  Aunque las propiedad computados son una caracter\u00edstica poderosa, hay algunas consideraciones importantes a tener en cuenta:</p> <ol> <li>Legibilidad del C\u00f3digo: El uso excesivo puede afectar la legibilidad del c\u00f3digo. Es importante usarlos cuando realmente agreguen valor.</li> <li>Errores de Tipo: Aseg\u00farate de que la expresi\u00f3n utilizada para calcular el nombre de la propiedad sea v\u00e1lida y retorne un string. De lo contrario se lanzar\u00e1 un error.</li> </ol>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#conclusion_1","title":"Conclusi\u00f3n:","text":"<p>Los nombres de propiedad computadas en clases son una caracter\u00edstica \u00fatil de JavaScript que permite definir m\u00e9todos y propiedades de forma din\u00e1mica. Cuando se usan adecuadamente pueden simplificar la configuraci\u00f3n de objetos y clases, evitar redundancias y hacer que el c\u00f3digo sea m\u00e1s flexible. Sin embargo, es importante no abusar de esta t\u00e9cnica para mantener la claridad del c\u00f3digo.</p> <p></p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#64-herencia","title":"6.4. Herencia:","text":"<p>La herencia en JavaScript permite que una clase hija adquiera las propiedades y m\u00e9todos de una clase base, lo cual facilita la creaci\u00f3n de jerarqu\u00edas de clases. La clase hija puede ampliar o modificar la funcionalidad heredada para adaptarla a necesidades espec\u00edficas.</p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#sintaxis-de-la-herencia","title":"Sintaxis de la herencia:","text":"<p>Para crear una clase que extienda otra clase, se utiliza la palabra clave extends:</p> <p>En este ejemplo, la clase Perro extiende la clase Animal, lo que le permite acceder al m\u00e9todo hacerSonido() de la clase base. <pre><code>class Animal {\n  constructor(nombre) {\n    this.nombre = nombre;\n  }\n\n  hacerSonido() {\n    console.log(`${this.nombre} est\u00e1 haciendo un sonido.`);\n  }\n}\n\nclass Perro extends Animal {\n  ladrar() {\n    console.log(`${this.nombre} est\u00e1 ladrando.`);\n  }\n}\n\nconst miPerro = new Perro('Rex');\n\nmiPerro.hacerSonido(); // Salida: Rex est\u00e1 haciendo un sonido.\nmiPerro.ladrar();      // Salida: Rex est\u00e1 ladrando.\n</code></pre></p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#beneficios-de-la-herencia","title":"Beneficios de la Herencia:","text":"<ol> <li>Reutilizaci\u00f3n del C\u00f3digo: Se evita la duplicaci\u00f3n al reutilizar el comportamiento com\u00fan definido en la clase base.</li> <li>Extensi\u00f3n de Funcionalidades: La clase hija puede a\u00f1adir caracter\u00edsticas o cambiar el comportamiento de los m\u00e9todos heredados.</li> <li>Organizaci\u00f3n y Mantenimiento: Ayuda a estructurar el c\u00f3digo en niveles jer\u00e1rquicos, haciendo m\u00e1s f\u00e1cil comprender y mantener la l\u00f3gica.</li> </ol>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#editor-de-codigo-utilizado","title":"Editor de c\u00f3digo utilizado:","text":"<ul> <li>Programiz - JavaScript Online Compiler </li> </ul>"},{"location":"javascript/","title":"JavaScript","text":""},{"location":"javascript/#aprende-javascript","title":"Aprende JavaScript","text":"<p>Aqu\u00ed te guiaremos a trav\u00e9s de los conceptos y funcionalidades esenciales de JavaScript, un vers\u00e1til lenguaje de programaci\u00f3n ampliamente utilizado para crear p\u00e1ginas web interactivas y aplicaciones web din\u00e1micas.</p> <p></p> <p>Tanto si acabas de empezar como si buscas profundizar en tus conocimientos, estos tutoriales ser\u00e1n tu recurso de referencia para dominar este lenguaje de script.</p>"},{"location":"javascript/#01-primeros-pasos-con-javascript","title":"01. Primeros pasos con JavaScript","text":"<p>En las primeras etapas de la profundizaci\u00f3n en JavaScript, es crucial comprender los conceptos fundamentales que forman los bloques de construcci\u00f3n de este vers\u00e1til lenguaje de programaci\u00f3n.</p> 1.1. \u00bfQu\u00e9 es JavaScript?        Descubre JavaScript. Lenguaje de programaci\u00f3n clave para la interactividad web y el desarrollo...      1.2. Primeros pasos        JavaScript es un lenguaje de programaci\u00f3n interpretado, orientado a objetos y de alto..."},{"location":"javascript/#02-conceptos-basicos","title":"02. Conceptos b\u00e1sicos","text":"<p>Los conceptos b\u00e1sicos de JavaScript son los bloques de construcci\u00f3n fundamentales que todo desarrollador debe comprender al iniciar su viaje con este vers\u00e1til lenguaje de programaci\u00f3n. Comprender los conceptos b\u00e1sicos como variables, tipos de datos y funciones es crucial para escribir c\u00f3digo eficiente y f\u00e1cil de mantener.</p> 2.1. Sintaxis de JavaScript: Fundamentos y Elementos Clave        En este tutorial, aprender\u00e1 sobre la sintaxis de JavaScript, incluidos espacios en blanco...      2.2. Variables        En este tutorial, aprender\u00e1 sobre las variables de JavaScript y c\u00f3mo usarlas para almacenar...      2.3. Variables: Diferencias entre var, let y const        En JavaScript existen tres formas principales de declarar variables: var, let y const. Cada una...      2.4. Tipos de datos        En JavaScript los tipos de datos son fundamentales para gestionar y manipular la...      2.5. Los N\u00fameros        En JavaScript el tipo de dato number se utiliza para representar tanto n\u00fameros enteros como...      2.6. Booleanos        En JavaScript, los booleanos son un tipo de dato fundamental que representa uno de dos...      2.7. Strings: Cadena de Caracteres        En el mundo de la programaci\u00f3n las cadenas de caracteres o strings son una de las estructuras...      2.8. Valores Primitivos vs. Valores de Referencia        En JavaScript existen dos tipos principales de valores: valores primitivos y valores de...      2.9. Introducci\u00f3n a los Objetos        En JavaScript, los objetos son una de las estructuras de datos m\u00e1s importantes y...      2.10. Arrays        Los arrays son estructuras de datos fundamentales que permiten almacenar m\u00faltiples..."},{"location":"javascript/#03-operadores","title":"03. Operadores","text":"<p>En JavaScript, los operadores son fundamentales para manipular datos y realizar c\u00e1lculos. Entender los diferentes tipos de operadores disponibles es clave para escribir c\u00f3digo eficiente. Desde operadores aritm\u00e9ticos hasta operadores l\u00f3gicos, el conjunto diverso de herramientas en JavaScript ofrece soluciones para una variedad de tareas.</p> 3.1. Operadores Aritm\u00e9ticos        Los operadores aritm\u00e9ticos en JavaScript permiten realizar c\u00e1lculos matem\u00e1ticos b\u00e1sicos u...              - \u00a0 * \u00a0 / \u00a0 +      3.2. Operador de Resto        En JavaScript, el operador de resto, utilizado mediante el s\u00edmbolo (%) se usa com\u00fanmente para...              %      3.3. Operador de Exponenciaci\u00f3n        Introducido en ES6, el operador de exponenciaci\u00f3n (**) en JavaScript permite elevar un n\u00famero a...              **      3.4. Operadores de Asignaci\u00f3n        Los operadores de asignaci\u00f3n en JavaScript son esenciales para almacenar y actualizar valores en...              -= \u00a0 **= \u00a0 *= \u00a0 /= \u00a0 %= \u00a0 += \u00a0 =      3.5. Operadores Unarios        En JavaScript, los operadores unarios son herramientas que permiten realizar transformaciones y...              - \u00a0 -- \u00a0 + \u00a0 ++      3.6. Operadores de Comparaci\u00f3n        Los operadores de comparaci\u00f3n en JavaScript permiten comparar valores para evaluar condiciones...              != \u00a0 &gt; \u00a0 &gt;= \u00a0 &lt; &lt;= \u00a0 ==      3.7. Operadores l\u00f3gicos        Los operadores l\u00f3gicos en JavaScript permiten combinar y evaluar condiciones, facilitando la toma...              ! \u00a0 &amp;&amp; \u00a0 ||      3.8. Operadores de Asignaci\u00f3n L\u00f3gica        Los operadores de asignaci\u00f3n l\u00f3gica combinan una operaci\u00f3n l\u00f3gica (AND, OR o fusi\u00f3n de nulos)...              ??= \u00a0 &amp;&amp;= \u00a0 ||=      3.9. Operador de Fusi\u00f3n de Nulos        Introducido en ES2020, el operador de fusi\u00f3n de nulos (??) es una soluci\u00f3n elegante para asignar...              ??"},{"location":"javascript/#04-metodos-de-strings","title":"04. M\u00e9todos de Strings","text":"<p>Los m\u00e9todos de strings en proporcionan herramientas para trabajar con texto de manera eficiente y flexible. Desde la b\u00fasqueda de subcadenas hasta la modificaci\u00f3n y comparaci\u00f3n de texto, estos permiten manipular los strings con facilidad. Conocer c\u00f3mo utilizarlos es esencial para resolver problemas comunes y optimizar el manejo de datos textuales en aplicaciones modernas.</p> 4.1. M\u00e9todos de B\u00fasqueda en Strings        Los m\u00e9todos de b\u00fasqueda en JavaScript son importantes porque nos ayudan a localizar textos dentro...              includes() \u00a0 indexOf() \u00a0 lastIndexOf() \u00a0 search()      4.2. M\u00e9todos de Reemplazo en Strings        Reemplazar texto en JavaScript es una operaci\u00f3n com\u00fan y poderosa que permite modificar strings...              replace() \u00a0 replaceAll()      4.3. M\u00e9todos de Acceso a Caracteres        Los m\u00e9todos de acceso a caracteres en JavaScript nos permiten trabajar con las posiciones...              at \u00a0 charAt \u00a0 charCodeAt \u00a0 codePointAt      4.4. M\u00e9todos de Extracci\u00f3n y Corte        La manipulaci\u00f3n de cadenas de texto o strings es una tarea muy recurrida en JavaScript, y los...              slice() \u00a0 split() \u00a0 substring()      4.5. M\u00e9todos de Concatenaci\u00f3n y Relleno en Strings        En JavaScript, los m\u00e9todos de concatenaci\u00f3n y relleno no solo son herramientas \u00fatiles, sino que...              concat() \u00a0 padEnd() \u00a0 padStart() \u00a0 repeat()      4.6. M\u00e9todos de Transformaci\u00f3n de Caso        Trabajar con cadenas de texto en JavaScript a menudo implica ajustar el formato de may\u00fasculas y...              toLocaleLowerCase() \u00a0 toLocaleUpp \u00a0 toLowerCase() \u00a0 toUpperCase()      4.7. M\u00e9todos de Limpieza en Strings        Al trabajar con strings en JavaScript, es com\u00fan encontrarse con espacios en blanco al inicio o al...              trim() \u00a0 trimEnd() \u00a0 trimStart()      4.8. M\u00e9todos de Divisi\u00f3n y Uni\u00f3n en Strings        En la manipulaci\u00f3n de datos en JavaScript, los m\u00e9todos de divisi\u00f3n y uni\u00f3n split y join juegan...              join() \u00a0 split()"},{"location":"javascript/#05-sentencias-de-flujo-de-control","title":"05. Sentencias de flujo de control","text":"<p>Las sentencias de flujo de control son esenciales en la programaci\u00f3n, ya que determinan el orden en que un programa ejecuta su c\u00f3digo. Al comprender c\u00f3mo funcionan las sentencias de flujo de control, los desarrolladores pueden crear una l\u00f3gica que gu\u00ede al programa por diferentes caminos en funci\u00f3n de las condiciones.</p> 5.1. Declaraci\u00f3n if\u2026else        La declaraci\u00f3n if...else en JavaScript es una de las estructuras de control que se utilizan para...      5.2. Operador ternario        El operador ternario en JavaScript es una herramienta que sirve para simplificar...      5.3. Estructura switch case        La declaraci\u00f3n switch case es una herramienta eficiente en JavaScript que permite tomar...      5.4. Bucle While        El bucle while en JavaScript es una herramienta esencial cuando necesitas ejecutar un bloque...      5.5. Bucle do\u2026while        El bucle do\u2026while es una estructura repetitiva en JavaScript que nos garantiza que un bloque...      5.6. Bucle for        El bucle for es una herramienta en JavaScript que nos permite manejar tareas repetitivas...      5.7. Instrucci\u00f3n break        La instrucci\u00f3n break se utiliza para terminar de manera abrupta un bucle, una instrucci\u00f3n...      5.8. Instrucci\u00f3n continue        La instrucci\u00f3n continue se utiliza para omitir la iteraci\u00f3n actual de un bucle y pasar a la..."},{"location":"javascript/#06-funciones","title":"06. Funciones","text":"<p>En el vasto mundo de JavaScript, las funciones desempe\u00f1an un papel crucial al permitir a los desarrolladores encapsular bloques de c\u00f3digo para su reutilizaci\u00f3n y organizaci\u00f3n. Son entidades vers\u00e1tiles que pueden invocarse en cualquier punto del c\u00f3digo, facilitando la ejecuci\u00f3n de tareas espec\u00edficas.</p> 6.1. Funciones        En JavaScript, las funciones son una de las piezas clave del lenguaje. Estas nos permiten...      6.2. Funciones \u201cCiudadanos de Primera clase\u201d        En JavaScript, las funciones son ciudadanos de primera clase. Este concepto significa que las...      6.3. Funciones An\u00f3nimas        Las funciones an\u00f3nimas son un concepto fundamental en JavaScript, que permite a los...      6.4. Funciones Recursivas        Las funciones recursivas son una herramienta fundamental en programaci\u00f3n, En JavaScript...      6.5. Closures y \u00c1mbito L\u00e9xico        En JavaScript, uno de los conceptos m\u00e1s potentes y utilizado es el de los closure. Estos...      6.6. Par\u00e1metros por Defecto        En JavaScript, los par\u00e1metros por defecto permiten asignar valores iniciales a los...      6.7. Arrow Functions        Las arrow functions fueron introducidas en la especificaci\u00f3n ES6 y ofrecen una forma m\u00e1s...      6.8. M\u00e9todos avanzados para el contexto de funciones        En JavaScript, el contexto de una funci\u00f3n (representado por la palabra clave this) es un...      6.9. Rest Parameter        El Rest Parameter (par\u00e1metro rest) en JavaScript, introducido en ES6, es una herramienta \u00fatil del...      6.10. Funciones de Callback        Las funciones de callback son una parte fundamental de JavaScript, especialmente..."},{"location":"javascript/#07-arrays","title":"07. Arrays","text":"<p>Los arrays son una de las estructuras de datos m\u00e1s importantes y utilizadas en JavaScript. Permiten a los desarrolladores almacenar m\u00faltiples valores en una sola variable, facilitando la manipulaci\u00f3n y acceso a conjuntos de datos. Los arrays no solo son \u00fatiles para agrupar informaci\u00f3n, sino que tambi\u00e9n ofrecen una amplia variedad de m\u00e9todos y propiedades que permiten modificar, ordenar, buscar y recorrer los elementos de forma eficiente.</p> 7.1. Introducci\u00f3n a los Arrays        Los arrays son una de las estructuras de datos m\u00e1s vers\u00e1tiles y esenciales en JavaScript...      7.2. M\u00e9todos B\u00e1sicos de los Arrays        Los arrays en JavaScript no solo nos permiten almacenar m\u00faltiples valores de diferentes tipos en...              pop() \u00a0 push() \u00a0 shift() \u00a0 unshift()      7.3. M\u00e9todos de Corte y Pegado Arrays        Manipular arrays es una tarea com\u00fan en JavaScript. M\u00e1s all\u00e1 de agregar o eliminar elementos, a...              concat() \u00a0 slice() \u00a0 splice()      7.4. M\u00e9todos de B\u00fasqueda y Acceso Arrays        Cuando trabajamos con arrays en JavaScript, una de las tareas m\u00e1s comunes es localizar elementos...              find() \u00a0 findIndex() \u00a0 includes() \u00a0 indexOf()      7.5. Ordenar Arrays        Ordenar arrays es una tarea fundamental en cualquier lenguaje de programaci\u00f3n, y JavaScript no es...              reverse() \u00a0 sort()      7.6. Desestructuraci\u00f3n de Arrays y Spread Operator        Introducidos en ES6, la desestructuraci\u00f3n de arrays y el operador de propagaci\u00f3n spread..."},{"location":"javascript/#08-metodos-de-alto-orden-en-arrays","title":"08. M\u00e9todos de Alto Orden en Arrays","text":"<p>Los m\u00e9todos de alto orden o Higher Order Array Methods en JavaScript permiten manipular arrays de forma m\u00e1s declarativa y eficiente. Estos m\u00e9todos trabajan aplicando funciones a los elementos del array, ofreciendo una manera m\u00e1s concisa y clara de procesar y transformar datos sin recurrir a bucles tradicionales. Este concepto es clave en la programaci\u00f3n funcional y su uso es muy com\u00fan en JavaScript.</p> 8.1. Introducci\u00f3n a los M\u00e9todos de Alto Orden en Arrays        Los m\u00e9todos de alto orden en JavaScript son herramientas que permiten trabajar con arrays...      8.2. Iterando sobre Arrays de Forma Eficiente con ForEach        Dentro de los m\u00e9todos de alto orden en arrays, el m\u00e9todo forEach es uno de los m\u00e1s comunes y...              forEach()      8.3. Transformando Arrays con el m\u00e9todo Map        El m\u00e9todo map() en JavaScript es uno de los m\u00e1s \u00fatiles y flexibles entre los m\u00e9todos de alto...              map()      8.4. Filtrando Arrays con el M\u00e9todo Filter        En JavaScript, filter() es uno de los m\u00e9todos de alto orden m\u00e1s potentes cuando se trata de...              filter()      8.5. Reducci\u00f3n de Arrays con el M\u00e9todo Reduce        El m\u00e9todo reduce() es uno de los m\u00e9todos m\u00e1s potentes y vers\u00e1tiles en JavaScript. A diferencia...              reduce()      8.6. Verificaciones Condicionales en Arrays con some y every        En JavaScript, los m\u00e9todos some() y every() son dos m\u00e9todos de alto orden muy \u00fatiles para...              every() \u00a0 some()      8.7. B\u00fasqueda Eficiente en Arrays con find y findIndex        En una secci\u00f3n anterior, discutimos los M\u00e9todos de B\u00fasqueda y Acceso en Arrays en JavaScript...              find() \u00a0 findIndex()"},{"location":"javascript/#09-objetos-y-prototipos","title":"09. Objetos y prototipos","text":"<p>Comprender el concepto de objetos y prototipos es fundamental para dominar JavaScript. Los objetos sirven como bloques de construcci\u00f3n que encapsulan tanto datos como funcionalidad dentro de una \u00fanica entidad. Por su parte, los prototipos desempe\u00f1an un papel crucial en la herencia y en los paradigmas de programaci\u00f3n orientada a objetos en JavaScript.</p> 9.1. M\u00e9todos de Objetos: Operaciones Comunes        Los objetos son una de las estructuras de datos fundamentales en JavaScript, no solo permiten...              Object.assign() \u00a0 Object.entries() \u00a0 Object.freeze() \u00a0 Object.keys() \u00a0 Object.seal() \u00a0 Object.values()      9.2. Funciones Constructoras: Creaci\u00f3n de Objetos Personalizados        Las funciones constructoras en JavaScript son una t\u00e9cnica esencial para la creaci\u00f3n de...      9.3. Prototipo: Fundamentos        El concepto de prototipo en JavaScript es uno de los pilares fundamentales del lenguaje. Gracias...      9.4. Patr\u00f3n Constructor/Prototipo        El desarrollo de aplicaciones escalables y eficientes en JavaScript requiere un uso...      9.5. Patr\u00f3n Herencia Protot\u00edpica: Herencia Basada en Objetos        En JavaScript, la herencia se logra a trav\u00e9s de un sistema basado en prototipos, conocido como...      9.6. El this: C\u00f3mo Funciona en Diferentes Contextos        El valor de this en JavaScript es una de las caracter\u00edsticas m\u00e1s potentes y a veces, confus...      9.7. GlobalThis: Accede al Objeto Global en Diferentes Entornos        El concepto del objeto global en JavaScript es importante, ya que act\u00faa como el contenedor...      9.8. Propiedades de los Objetos        En JavaScript los objetos son colecciones de propiedades y cada propiedad tiene un conjunt...      9.9. Propiedades Enumerables y Propiedades Propias: Diferencias Clave        En JavaScript los objetos pueden tener diferentes tipos de propiedades y es important...      9.10. Ciclo for\u2026in: C\u00f3mo Iterar sobre las Propiedades de un Objeto        El ciclo for...in es una de las herramientas m\u00e1s comunes en JavaScript para iterar sobre las...      9.11. Funciones F\u00e1brica: Creando Objetos de Forma Flexible        En JavaScript una funci\u00f3n f\u00e1brica (o factory function) es una funci\u00f3n que retorna un objeto...      9.12. Desestructuraci\u00f3n de Objetos: Asigna Propiedades a Variables        La desestructuraci\u00f3n de objetos es una de las caracter\u00edsticas m\u00e1s \u00fatiles introducidas en ES6...      9.13. Operador de Encadenamiento Opcional (?.)        El operador de encadenamiento opcional (?.) es una caracter\u00edstica introducida en ES2020 que...      9.14. Crear Objetos con un Prototipo Espec\u00edfico con Object.create()        El m\u00e9todo Object.create() es una poderosa herramienta en JavaScript que permite crear un..."},{"location":"javascript/#10-clases","title":"10. Clases","text":"<p>En el \u00e1mbito de la programaci\u00f3n en JavaScript, las clases desempe\u00f1an un papel vital en la estructuraci\u00f3n y organizaci\u00f3n del c\u00f3digo. Las clases act\u00faan como planos para crear objetos con propiedades y m\u00e9todos predefinidos, lo que permite una reutilizaci\u00f3n y un mantenimiento eficaces del c\u00f3digo.</p> 10.1. Introducci\u00f3n a las Clases        Las clases en JavaScript, introducidas con ES6 (ECMAScript 2015), ofrecen una forma m\u00e1s clar...      10.2. Constructor de Clase: Configuraci\u00f3n de Objetos        El constructor de clase en JavaScript es un m\u00e9todo especial que se ejecuta...      10.3. M\u00e9todos de Instancia en Clases        Los m\u00e9todos de instancia en JavaScript son funciones definidas dentro de una clase que...      10.4. Propiedades y M\u00e9todos Est\u00e1ticos en Clases        En JavaScript, las propiedades y m\u00e9todos est\u00e1ticos pertenecen a la clase misma, no a sus...      10.5. Expresiones de Clase        Las Class Expressions (Expresiones de Clase) en JavaScript son una forma alternativa de definir...      10.6. Nombres de Propiedad Computadas en Clases        Los nombres de propiedad computadas o Computed Property Names permiten definir...      10.7. Extensi\u00f3n de Clases (Herencia)        La herencia es un concepto fundamental en la programaci\u00f3n orientada a objetos que permite...      10.8. Uso de super en Clases        La palabra clave super en JavaScript se utiliza en clases derivadas para acceder al constructor o...      10.9. Encapsulaci\u00f3n con Propiedades Privadas en Clases        La encapsulaci\u00f3n es un concepto clave en la programaci\u00f3n orientada a objetos que permite...      10.10. Getters y Setters en Clases        Los getters y setters en JavaScript son funciones especiales que se utilizan para controlar el...      10.11. Mixins        Los Mixins en JavaScript son una t\u00e9cnica en la programaci\u00f3n orientada a objetos que permite..."},{"location":"javascript/#11-promesas-y-asyncawait","title":"11. Promesas y Async/Await","text":"<p>En el \u00e1mbito de JavaScript, dominar las promesas y Async/Await puede mejorar significativamente tus habilidades de codificaci\u00f3n. Estas t\u00e9cnicas avanzadas proporcionan una forma m\u00e1s eficaz de manejar las operaciones as\u00edncronas, permitiendo una ejecuci\u00f3n m\u00e1s fluida de las funciones.</p> 11.1. Introducci\u00f3n a la Programaci\u00f3n As\u00edncrona        La programaci\u00f3n as\u00edncrona es una t\u00e9cnica que permite que los programas realicen m\u00faltiples...      11.2. Promesas        Las promesas en JavaScript son una herramienta esencial para manejar operaciones as\u00edncronas...      11.3. Encadenamiento de Promesas        El encadenamiento de promesas es una t\u00e9cnica que permite ejecutar operaciones as\u00edncronas...      11.4. Promise.all: Promesas en Paralelo        El m\u00e9todo Promise.all en JavaScript es una herramienta poderosa para manejar m\u00faltiples...              Promise.all      11.5. Promise.race: Resolviendo la Promesa M\u00e1s R\u00e1pida        El m\u00e9todo Promise.race en JavaScript permite manejar varias promesas ejecutadas en paralelo y...              Promise.race      11.6. Promise.allSettled: Manejo Completo de Promesas        El m\u00e9todo Promise.allSettled en JavaScript es una herramienta dise\u00f1ada para manejar m\u00faltiples...              Promise.allSettled      11.7. Promise.any: Esperando la Primera Promesa Resuelta con \u00c9xito        Promise.any es un m\u00e9todo en JavaScript que devuelve la primera promesa que se resuelve con \u00e9xito...              Promise.any      11.8. Manejo de Errores en Promesas        Trabajar con promesas en JavaScript permite manejar operaciones as\u00edncronas de manera fluida, pero...              catch() \u00a0 finally()      11.9. Async/Await        La introducci\u00f3n de async/await en JavaScript transform\u00f3 la manera de manejar el c\u00f3digo...      11.10. Manejo de Errores con Async/Await        El uso de async y await ha hecho que trabajar con c\u00f3digo as\u00edncrono sea m\u00e1s claro y legible..."},{"location":"javascript/#12-iteradores-y-generadores","title":"12. Iteradores y Generadores","text":"<p>Los Iteradores y Generadores desempe\u00f1an un papel importante en JavaScript, estos proporcionan un enfoque optimizado para recorrer y manejar estructuras de datos. Estas estructuras facilitan la iteraci\u00f3n de manera m\u00e1s controlada y eficiente, mejorando tanto la legibilidad como el mantenimiento del c\u00f3digo y simplificando tareas complejas de procesamiento secuencial.</p> 12.1. Introducci\u00f3n a los Iteradores        Los iteradores en JavaScript proporcionan una manera eficiente y controlada de recorrer...      12.2. Iterables y el Bucle for\u2026of        Los iterables en JavaScript son estructuras que permiten recorrer sus elementos de manera...      12.3. Generadores        Los generadores en JavaScript son un tipo especial de funci\u00f3n que permite pausar y reanudar su...              function* \u00a0 next() \u00a0 yield      12.4. Iteradores As\u00edncronos        Con el auge de aplicaciones que manejan datos en tiempo real y operaciones as\u00edncronas como...      12.5. Generadores As\u00edncronos        Los generadores as\u00edncronos en JavaScript permiten producir y consumir valores de..."},{"location":"javascript/#13-modulos","title":"13. M\u00f3dulos","text":"<p>Los m\u00f3dulos desempe\u00f1an un papel importante en la organizaci\u00f3n y estructuraci\u00f3n del c\u00f3digo JavaScript, permitiendo a los desarrolladores dividir sus programas en piezas m\u00e1s peque\u00f1as y reutilizables. Al encapsular funciones, variables y objetos relacionados dentro de m\u00f3dulos, el c\u00f3digo es m\u00e1s f\u00e1cil de mantener y gestionar.</p> 13.1. Introducci\u00f3n a los M\u00f3dulos        Los m\u00f3dulos en JavaScript son fundamentales para organizar y estructurar c\u00f3digo de manera...      13.2. Exportaci\u00f3n        La exportaci\u00f3n en JavaScript permite compartir variables, funciones y clases entre m\u00f3dulos...      13.3. Importaci\u00f3n        La importaci\u00f3n en JavaScript permite que un m\u00f3dulo use funciones, variables o clases de...      13.4. Reexportaci\u00f3n de M\u00f3dulos        La reexportaci\u00f3n en JavaScript permite agrupar y redistribuir m\u00f3dulos desde un solo punto de...      13.5. M\u00f3dulos Din\u00e1micos        Los m\u00f3dulos din\u00e1micos en JavaScript permiten cargar c\u00f3digo de manera as\u00edncrona durante la..."},{"location":"javascript/#14-colecciones","title":"14. Colecciones","text":"<p>En el \u00e1mbito de la programaci\u00f3n en JavaScript comprender las colecciones es un aspecto fundamental. Estas son una estructura de datos que permite almacenar y organizar m\u00faltiples elementos. Al profundizar en las colecciones, los desarrolladores pueden manipular y gestionar los datos de manera eficiente, mejorando la funcionalidad y el rendimiento general de sus aplicaciones web.</p> 14.1. Map        El objeto Map en JavaScript, introducido en ES6, es una estructura de datos dise\u00f1ada para...      14.2. Set        El objeto Set es una estructura de datos que permite almacenar valores \u00fanicos de cualquier..."},{"location":"javascript/#15-gestion-de-errores","title":"15. Gesti\u00f3n de errores","text":"<p>La gesti\u00f3n de errores en JavaScript es un aspecto crucial de la programaci\u00f3n para garantizar el buen funcionamiento de tu c\u00f3digo. Cuando se producen errores durante la ejecuci\u00f3n de un programa, los mecanismos de gesti\u00f3n adecuados pueden evitar que la aplicaci\u00f3n se bloquee y proporcionar a los usuarios informaci\u00f3n significativa.</p> 15.1. try catch        El manejo de errores en JavaScript es importante al momento de construir aplicaciones confiable...      15.2. try catch finally        El bloque try catch finally en JavaScript ampl\u00eda la funcionalidad de la estructura...      15.3. Lanzar Excepciones con throw        El manejo de errores en JavaScript no solo implica capturar problemas con try\u2026catch, sino...      15.4. Optional Catch Binding        La introducci\u00f3n del optional catch binding (Manejo Opcional del Error en Catch) en..."},{"location":"javascript/#16-runtime-tiempo-de-ejecucion","title":"16. Runtime (tiempo de ejecuci\u00f3n)","text":"<p>El JavaScript Runtime es el entorno en el cual se ejecuta el c\u00f3digo JavaScript. Es el \u201cescenario\u201d donde ocurren todas las acciones de nuestro c\u00f3digo. Durante la ejecuci\u00f3n, el tiempo de ejecuci\u00f3n se encarga de interpretar y ejecutar el c\u00f3digo JavaScript l\u00ednea por l\u00ednea, gestionando tareas como la asignaci\u00f3n de memoria, la ejecuci\u00f3n de funciones, la manipulaci\u00f3n de objetos, y la interacci\u00f3n con el entorno donde se est\u00e9 ejecutando.</p> 16.1. Contexto de Ejecuci\u00f3n        El contexto de ejecuci\u00f3n es uno de los conceptos clave para entender c\u00f3mo JavaScript procesa y...      16.2. Call Stack: Entendiendo la Pila de Llamadas        La pila de llamadas o call stack es un mecanismo en el cual se utiliza el motor de JavaScript para...      16.3. Event Loop        El event loop (bucle de eventos) es un componente fundamental del tiempo de...      16.4. Hoisting: Entendiendo la Elevaci\u00f3n en el C\u00f3digo        El hoisting (o elevaci\u00f3n) es un comportamiento en JavaScript que ocurre durante la fase de...      16.5. Variable Scope: Alcances de las Variables        El alcance (scope) de una variable en JavaScript define d\u00f3nde es visible y accesible dentro del..."},{"location":"javascript/#17-tipos-de-envoltura-primitivos","title":"17. Tipos de Envoltura Primitivos","text":"<p>Los (Primitive Wrapper Types) en JavaScript son objetos especiales que envuelven los tipos de datos primitivos (como n\u00fameros, cadenas, booleanos y s\u00edmbolos) para permitirles comportarse como objetos. Estos tipos de envoltura proporcionan m\u00e9todos y propiedades adicionales que no est\u00e1n presentes en los tipos primitivos, permitiendo que trabajemos con ellos como si fueran objetos.</p> <p></p> <p>Aprende JavaScript </p> <p>Programiz - JavaScript Online Compiler </p> <p></p>"},{"location":"javascript/async-await/","title":"Async/Await","text":""},{"location":"javascript/async-await/#asyncawait","title":"Async/Await","text":"<p>La introducci\u00f3n de async/await en JavaScript transform\u00f3 la manera de manejar el c\u00f3digo as\u00edncrono, haci\u00e9ndolo m\u00e1s legible y f\u00e1cil de seguir. Estas palabras clave permiten trabajar con promesas de forma m\u00e1s fluida, logrando que el c\u00f3digo se parezca al flujo s\u00edncrono. Esto no solo mejora la comprensi\u00f3n del c\u00f3digo, sino que tambi\u00e9n facilita su depuraci\u00f3n.</p> <p>En este art\u00edculo, aprenderemos c\u00f3mo funcionan <code>async</code> y <code>await</code>, sus ventajas, y c\u00f3mo usarlos para simplificar operaciones as\u00edncronas complejas.</p>"},{"location":"javascript/async-await/#que-son-async-y-await","title":"\u00bfQu\u00e9 son async y await?","text":"<p><code>async</code> y <code>await</code> son palabras clave introducidas en ES2017 que permiten manejar c\u00f3digo as\u00edncrono de manera m\u00e1s clara. Estas herramientas convierten el trabajo con promesas en un proceso m\u00e1s lineal, facilitando la escritura y lectura del c\u00f3digo.</p> <ul> <li>async: Convierte autom\u00e1ticamente una funci\u00f3n utilitaria en una funci\u00f3n as\u00edncrona que devuelve una promesa.</li> <li>await: Pausa la ejecuci\u00f3n de una funci\u00f3n <code>async</code> hasta que la promesa asociada sea resuelta o rechazada.</li> </ul> <p>Ejemplo b\u00e1sico de una funci\u00f3n async:</p> javascript<pre><code>async function saludo() {\n    return \"Hola, Async/Await\";\n}\n\nsaludo().then(mensaje =&gt; console.log(mensaje));\n</code></pre> <p>Al usar <code>async</code>, la funci\u00f3n <code>saludo</code> devuelve autom\u00e1ticamente una promesa.El valor <code>\"Hola, Async/Await\"</code> se convierte en el resultado de la promesa.</p> <p>Uso de await para manejar promesas:</p> <p>La palabra clave <code>await</code> permite pausar la ejecuci\u00f3n de una funci\u00f3n <code>async</code> hasta que la promesa asociada se resuelva. Esto elimina la necesidad de usar <code>.then()</code> para manejar resultados, logrando un flujo m\u00e1s natural.</p> <p>Ejemplo b\u00e1sico de await:</p> javascript<pre><code>async function obtenerDatos() {\n    const respuesta = await fetch('https://api.example.com/datos');\n    const datos = await respuesta.json();\n    return datos;\n}\n</code></pre> <p>La funci\u00f3n <code>fetch</code> devuelve una promesa. <code>await</code> espera a que esta se resuelva. El flujo no contin\u00faa hasta que se obtienen y procesan los datos.</p>"},{"location":"javascript/async-await/#ejecucion-secuencial-con-asyncawait","title":"Ejecuci\u00f3n secuencial con async/await","text":"<p><code>async/await</code> tambi\u00e9n permite ejecutar operaciones de manera secuencial, en caso de que cada tarea dependa de la finalizaci\u00f3n de la anterior. Esta secuencia asegura que el flujo de datos sea correcto y elimina la necesidad de anidar m\u00faltiples <code>.then()</code> en una cadena.</p> <p>Ejemplo de Ejecuci\u00f3n Secuencial:</p> javascript<pre><code>async function procesoSecuencial() {\n    const paso1 = await Promise.resolve(\"Paso 1 completado\");\n    console.log(paso1);\n\n    const paso2 = await Promise.resolve(\"Paso 2 completado\");\n    console.log(paso2);\n\n    const paso3 = await Promise.resolve(\"Paso 3 completado\");\n    console.log(paso3);\n}\n\nprocesoSecuencial();\n</code></pre> <p>En el ejemplo anterior, cada <code>await</code> asegura que el paso anterior est\u00e9 completo antes de continuar. Esta funci\u00f3n as\u00edncrona produce lo que ser\u00eda una cadena de promesas en un flujo de c\u00f3digo f\u00e1cil de entender y sin necesidad de anidaci\u00f3n.</p>"},{"location":"javascript/async-await/#ejecucion-paralela-con-promiseall-y-asyncawait","title":"Ejecuci\u00f3n paralela con Promise.all y async/await","text":"<p>Aunque <code>async/await</code> es ideal para flujos secuenciales, tambi\u00e9n puedes usarlo con <code>Promise.all</code> para ejecutar tareas en paralelo. Esto mejora el rendimiento en operaciones independientes.</p> <p>Ejemplo de Ejecuci\u00f3n Paralela:</p> javascript<pre><code>async function obtenerDatosParalelo() {\n    try {\n        const [usuario, pedidos] = await Promise.all([\n        fetch('https://api.example.com/usuario/1').then(res =&gt; res.json()),\n        fetch('https://api.example.com/pedidos/1').then(res =&gt; res.json())\n        ]);\n\n        return { usuario, pedidos }; // Devuelve ambos resultados como un objeto\n    } catch (error) {\n        return { error: error.message }; // Devuelve el error capturado\n    }\n}\n\nobtenerDatosParalelo().then(resultado =&gt; {\n    // Manejo de resultado o error\n});\n</code></pre> <p>En el ejemplo anterior las dos solicitudes se ejecutan en paralelo. <code>Promise.all</code> espera a que ambas operaciones finalicen, pero sin depender una de la otra, mejorando el rendimiento de la aplicaci\u00f3n.</p>"},{"location":"javascript/async-await/#manejo-de-errores-con-trycatch","title":"Manejo de errores con try/catch","text":"<p>El manejo de errores es m\u00e1s limpio con <code>try/catch</code> dentro de funciones <code>async</code>, ya que centraliza la gesti\u00f3n de errores en un solo bloque. Esto asegura que todos los errores de la funci\u00f3n <code>async</code> se gestionen en un solo bloque.</p> <p>Ejemplo de manejo de errores:</p> javascript<pre><code>async function obtenerDatosSeguro() {\n    try {\n        const respuesta = await fetch('https://api.example.com/datos');\n        if (!respuesta.ok) throw new Error(\"Error en la solicitud\");\n\n        const datos = await respuesta.json();\n        return datos; // Devuelve los datos obtenidos\n    } catch (error) {\n        return { error: error.message }; // Devuelve el error capturado\n    }\n}\n\nobtenerDatosSeguro().then(resultado =&gt; {\n    // Manejo de resultado o error\n});\n</code></pre> <p><code>try</code> protege el bloque donde pueden ocurrir errores. <code>catch</code> captura y maneja cualquier error, como fallos de red o datos inv\u00e1lidos.</p>"},{"location":"javascript/async-await/#buenas-practicas-con-asyncawait","title":"Buenas pr\u00e1cticas con async/await","text":"<p>Para aprovechar al m\u00e1ximo <code>async/await</code>, es importante tener en cuenta algunas buenas pr\u00e1cticas que aseguran un manejo eficiente y ordenado de las operaciones as\u00edncronas.</p> <ol> <li>Usa <code>Promise.all</code> para operaciones paralelas: Cuando varias tareas no dependen unas de otras, ejec\u00fatalas simult\u00e1neamente para mejorar el rendimiento.</li> <li>Utiliza <code>try/catch</code> para capturar errores: Centraliza el manejo de errores para evitar fallos inesperados y mejorar la depuraci\u00f3n.</li> <li>Evita bloqueos innecesarios: No uses <code>await</code> en operaciones que no necesitan ser pausadas. Esto puede ralentizar el flujo del programa.</li> <li>Manejo eficiente de errores: En flujos complejos, combina <code>try/catch</code> con funciones reutilizables para reducir la redundancia.</li> </ol>"},{"location":"javascript/async-await/#conclusion","title":"Conclusi\u00f3n","text":"<p><code>async</code> y <code>await</code> han revolucionado la forma de manejar la asincron\u00eda en JavaScript, haciendo que el c\u00f3digo sea m\u00e1s limpio, legible y f\u00e1cil de mantener. Al comprender su funcionamiento y seguir buenas pr\u00e1cticas, puedes optimizar tus aplicaciones y simplificar el desarrollo de tareas as\u00edncronas.</p> <p>En el pr\u00f3ximo art\u00edculo, exploraremos c\u00f3mo manejar errores con async/await, asegurando que tu c\u00f3digo sea robusto y eficiente.</p> <p></p>"},{"location":"javascript/booleanos/","title":"Booleanos","text":""},{"location":"javascript/booleanos/#booleanos","title":"Booleanos","text":"<p>En JavaScript, los booleanos son un tipo de dato fundamental que representa uno de dos valores: <code>true</code> o <code>false</code> (verdadero/falso). Este tipo se utiliza principalmente en estructuras de control, condiciones l\u00f3gicas y bucles que determinan el flujo de ejecuci\u00f3n de un programa.</p> <p>En este art\u00edculo aprenderemos qu\u00e9 son los booleanos, c\u00f3mo se utilizan y exploraremos algunos casos comunes para trabajarlos con condiciones y operadores l\u00f3gicos.</p>"},{"location":"javascript/booleanos/#que-es-un-booleano","title":"\u00bfQu\u00e9 es un Booleano?","text":"<p>Un booleano es un tipo de dato primitivo en JavaScript que representa un valor de verdad. Los \u00fanicos valores posibles son <code>true</code> (verdadero) o <code>false</code> (falso). En la programaci\u00f3n se utilizan para evaluar expresiones y controlar el flujo del programa mediante decisiones basadas en condiciones.</p> javascript<pre><code>const esMayor = 10 &gt; 5;\nconst esIgual = 10 === \"10\";\n\nconsole.log(esMayor);\nconsole.log(esIgual);\n</code></pre> <p>En el ejemplo anterior <code>esMayor</code> es <code>true</code> porque 10 es mayor que 5, mientras que <code>esIgual</code> es <code>false</code> debido a la no diferencia en el tipo de dato.</p> <p> Los valores literales del booleano distinguen entre may\u00fasculas y min\u00fasculas. Esto significa que Truey False son identificadores v\u00e1lidos pero no son valores boolean.</p> <p></p> <p>Este tipo de datos denominado as\u00ed en honor a George Boole, un matem\u00e1tico ingl\u00e9s conocido por su trabajo en l\u00f3gica algebraica, se convirti\u00f3 en una herramienta fundamental en las estructuras l\u00f3gicas de los programas.</p>"},{"location":"javascript/booleanos/#valores-falsos-y-verdaderos","title":"Valores Falsos y Verdaderos","text":"<p>En JavaScript algunos valores se consideran \u201cverdaderos\u201d (truthy) y otros \u201cfalsos\u201d (falsy) cuando se eval\u00faan en un contexto booleano. Es importante conocer cu\u00e1les son estos valores para evitar errores al trabajar con condiciones.</p>"},{"location":"javascript/booleanos/#valores-falsy-en-javascript","title":"Valores Falsy en JavaScript","text":"<p>Los siguientes valores son considerados falsos en un contexto booleano:</p> <ul> <li><code>false</code></li> <li><code>0</code></li> <li><code>\"\"</code> (cadena vac\u00eda)</li> <li><code>null</code></li> <li><code>undefined</code></li> <li><code>NaN</code> (Not a Number)</li> </ul> <p>Cualquier otro valor se considera \u201cverdadero\u201d (truthy), lo que significa que se eval\u00faa como <code>true</code>.</p> <p>Ejemplos de Valores Falsy y Truthy</p> javascript<pre><code>if (0) {\n    console.log(\"Esto no se ejecutar\u00e1.\");\n}\n\nif (\"Hola\") {\n    console.log(\"Esto s\u00ed se ejecutar\u00e1.\");\n}\n</code></pre> <p>En el ejemplo anterior <code>0</code> es un valor falsy y no activa el bloque <code>if</code>, mientras que la cadena <code>\"Hola\"</code> es truthy y activa el bloque.</p>"},{"location":"javascript/booleanos/#conversion-de-valores-booleanos","title":"Conversi\u00f3n de Valores Booleanos","text":"<p>JavaScript permite convertir los valores de otros tipos a valores booleanos. Para convertir un valor no booleano en un valor booleano, utilizamos la funci\u00f3n incorporada <code>Boolean()</code></p> javascript<pre><code>const error = 'An error occurred';\nconst hasError = Boolean(error);\n\nconsole.log(hasError);\n</code></pre> <p>En el ejemplo anterior declaramos una variable <code>error</code> que contiene el string \u2018<code>An error occurred</code>\u2018. Luego utilizando la funci\u00f3n <code>Boolean()</code>, convertimos el valor de la variable <code>error</code> a un booleano y lo almacenamos en la variable <code>hasError</code>. Al imprimir <code>hasError</code> en la consola, obtendremos <code>true</code> debido a que la variable <code>error</code> contiene un string no vac\u00edo, lo que hace que la funci\u00f3n <code>Boolean()</code> lo eval\u00fae como verdadero.</p> <p>La siguiente tabla muestra c\u00f3mo la funci\u00f3n <code>Boolean()</code> convierte los valores de otros tipos en valores booleanos:</p> Tipo de datos Valores convertidos a verdaderos Valor convertido a falso <code>string</code> Cualquier cadena no vac\u00eda \u201c\u201d (string vac\u00edo) <code>number</code> Cualquier n\u00famero distinto de cero 0, NaN <code>object</code> cualquier objeto nulo <code>undefined</code> (Irrelevante) indefinido <p>Ejemplos de Conversi\u00f3n a Booleano:</p> javascript<pre><code>console.log(Boolean(1));\nconsole.log(Boolean(0));\nconsole.log(Boolean(\"\"));\nconsole.log(Boolean(\"Hola\"));\n\n// Uso del doble operador de negaci\u00f3n\nconsole.log(!!123);\nconsole.log(!!\"\");\n</code></pre>"},{"location":"javascript/booleanos/#coercion-implicita-a-booleano","title":"Coerci\u00f3n Impl\u00edcita a Booleano","text":"<p>En JavaScript se genera de manera impl\u00edcita la coerci\u00f3n de tipos a booleano. Por ejemplo, la declaraci\u00f3n <code>if</code> ejecuta un bloque si una condici\u00f3n es <code>true</code>. Si usa un valor no booleano usar\u00e1 la funci\u00f3n <code>Boolean()</code> para convertir impl\u00edcitamente ese valor a un valor booleano. Es decir, JavaScript convierte el valor a booleano autom\u00e1ticamente. Por ejemplo:</p> javascript<pre><code>const error = \"An error occurred\";\n\nif (error) {\n  console.log(error);\n}\n</code></pre> <p>En cambio, si cambia el valor de la variable <code>error</code> a una cadena vac\u00eda (<code>\"\"</code>), no imprimir\u00e1 nada en la consola porque la declaraci\u00f3n <code>if</code> lo eval\u00faa como <code>false</code>:</p>"},{"location":"javascript/booleanos/#operadores-booleanos-en-javascript","title":"Operadores Booleanos en JavaScript","text":"<p>JavaScript cuenta con una variedad de operadores booleanos que permiten realizar operaciones l\u00f3gicas y de comparaci\u00f3n en el c\u00f3digo. Estos operadores son esenciales para tomar decisiones basadas en condiciones y controlar el flujo del programa.</p> <p>Hay seis tipos principales de operadores booleanos en JavaScript, cada uno con su funci\u00f3n espec\u00edfica:</p> <ol> <li>AND l\u00f3gico: Representado por <code>&amp;&amp;</code>.</li> <li>OR l\u00f3gico: Representado por <code>||</code>.</li> <li>Comparaci\u00f3n: Incluye operadores como <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> y <code>&gt;=</code>.</li> <li>Comparaci\u00f3n estricta: Representado por <code>===</code> y <code>!==</code>.</li> <li>NOT l\u00f3gico: Representado por <code>!</code>.</li> <li>Operadores l\u00f3gicos bitwise: Incluye <code>&amp;</code> para AND, <code>|</code> para OR, <code>^</code> para XOR, <code>~</code> para NOT y <code>&lt;&lt;</code>, <code>&gt;&gt;</code> y <code>&gt;&gt;&gt;</code> para desplazamiento de bits.</li> </ol> <p>Mas adelante profundizamos en cada uno de los operadores.</p>"},{"location":"javascript/booleanos/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los booleanos en JavaScript son esenciales para la toma de decisiones y el control del flujo de los programas. Conocer los operadores l\u00f3gicos, los valores truthy y falsy y c\u00f3mo utilizar los booleanos en condiciones te permitir\u00e1 escribir c\u00f3digo m\u00e1s robusto y eficiente.</p> <p>En el siguiente art\u00edculo profundizaremos en el uso de las cadenas de caracteres (strings) en JavaScript, abordando sus m\u00e9todos y aplicaciones comunes.</p> <p></p>"},{"location":"javascript/bucle-for-of/","title":"Iterables y el Bucle for\u2026of","text":""},{"location":"javascript/bucle-for-of/#iterables-y-el-bucle-forof","title":"Iterables y el Bucle for\u2026of","text":"<p>Los iterables en JavaScript son estructuras que permiten recorrer sus elementos de manera secuencial mediante el protocolo de iteraci\u00f3n. Este protocolo define c\u00f3mo se accede a los elementos de un objeto, haci\u00e9ndolo compatible con el bucle <code>for...of</code>, lo que simplifica la iteraci\u00f3n sobre datos como arrays, strings y estructuras personalizadas.</p> <p>En este art\u00edculo exploraremos c\u00f3mo funcionan los iterables, c\u00f3mo implementar el protocolo de iteraci\u00f3n y c\u00f3mo el bucle <code>for...of</code> aprovecha estas capacidades.</p>"},{"location":"javascript/bucle-for-of/#que-es-un-objeto-iterable","title":"\u00bfQu\u00e9 es un objeto iterable?","text":"<p>Un objeto iterable es cualquier estructura de datos que implemente el m\u00e9todo <code>Symbol.iterator</code>. Este m\u00e9todo devuelve un iterador que permite acceder secuencialmente a los elementos del objeto.</p> <p>Los tipos de datos nativos como arrays, strings, maps y sets ya son iterables por defecto, pero tambi\u00e9n puedes convertir tus propios objetos en iterables implementando <code>Symbol.iterator</code>.</p> <p>Ejemplo b\u00e1sico de un iterable:</p> javascript<pre><code>const objetoIterable = {\n    [Symbol.iterator]() {\n        let paso = 0;\n        return {\n            next() {\n                paso++;\n                return paso &lt;= 3 ? { value: paso, done: false } : { done: true };\n            }\n        };\n    }\n};\n\nfor (const valor of objetoIterable) {\n    console.log(valor);\n}\n</code></pre> <p>En este ejemplo: Cada llamada al iterador devuelve el siguiente valor de la secuencia. El m\u00e9todo <code>Symbol.iterator</code> devuelve un iterador.</p>"},{"location":"javascript/bucle-for-of/#el-bucle-forof-en-javascript","title":"El bucle for\u2026of en JavaScript","text":"<p>El bucle <code>for...of</code> es una herramienta que simplifica la iteraci\u00f3n sobre objetos iterables. A diferencia de <code>for...in</code>, que recorre las propiedades de un objeto, <code>for...of</code> accede directamente a los valores de las estructuras iterables.</p> <p>sintaxis basica:</p> javascript<pre><code>for (const elemento of iterable) {\n    // Acceso al elemento actual en cada iteraci\u00f3n\n}\n</code></pre> <p>En el siguiente ejemplo el bucle <code>for...of</code> accede a cada elemento del array <code>numeros</code> y lo imprime, sin requerir el uso de \u00edndices.</p> javascript<pre><code>const numeros = [1, 2, 3];\n\nfor (const numero of numeros) {\n    console.log(numero);\n}\n</code></pre> <p>Este bucle es especialmente \u00fatil porque elimina la necesidad de manejar \u00edndices manualmente y ofrece una sintaxis m\u00e1s limpia para trabajar con iterables.</p>"},{"location":"javascript/bucle-for-of/#comparacion-entre-forof-y-forin","title":"Comparaci\u00f3n entre for..of y for..in","text":"<p>Aunque ambos son bucles, <code>for...of</code> y <code>for...in</code> tienen prop\u00f3sitos muy diferentes:</p> <ul> <li><code>for...of</code>: Itera sobre los valores de un objeto iterable (como arrays, strings o mapas).</li> <li><code>for...in</code>: Itera sobre las propiedades de un objeto, tanto las propias como las heredadas.</li> </ul> javascript<pre><code>const objeto = { a: 1, b: 2, c: 3 };\n\nfor (const propiedad in objeto) {\n    console.log(propiedad);  // Output: \"a\", \"b\", \"c\"\n}\n\nconst array = [10, 20, 30];\nfor (const valor of array) {\n    console.log(valor);  // Output: 10, 20, 30\n}\n</code></pre>"},{"location":"javascript/bucle-for-of/#iteracion-de-strings-con-forof","title":"Iteraci\u00f3n de Strings con for\u2026of","text":"<p>En JavaScript, las cadenas de texto son iterables, lo que significa que cada car\u00e1cter se trata como un elemento separado en la iteraci\u00f3n.</p> <p>Ejemplo de <code>for...of</code> con un String</p> javascript<pre><code>const saludo = \"Hola\";\n\nfor (const letra of saludo) {\n    console.log(letra);\n}\n</code></pre> <p>Esto es particularmente \u00fatil para manipular texto, como verificar caracteres o construir nuevas cadenas basadas en ciertas condiciones.</p>"},{"location":"javascript/bucle-for-of/#creacion-de-iterables-personalizados","title":"Creaci\u00f3n de iterables personalizados","text":"<p>Para hacer que un objeto sea iterable, simplemente se le agrega el m\u00e9todo <code>Symbol.iterator</code>. Esto es \u00fatil cuando se trabaja con estructuras de datos personalizadas, permitiendo definir la l\u00f3gica de iteraci\u00f3n para acceder a sus elementos.</p> javascript<pre><code>const rango = {\n    inicio: 1,\n    fin: 5,\n    [Symbol.iterator]() {\n        let actual = this.inicio;\n        const fin = this.fin;\n        return {\n            next() {\n                if (actual &lt;= fin) {\n                return { value: actual++, done: false };\n                } else {\n                return { done: true };\n                }\n            }\n        };\n    }\n};\n\nfor (const numero of rango) {\n    console.log(numero);\n}\n</code></pre> <p>En el anterior c\u00f3digo el objeto <code>rango</code> se convierte en iterable al implementar <code>Symbol.iterator</code>, la l\u00f3gica de iteraci\u00f3n se define dentro del m\u00e9todo <code>next()</code>.</p>"},{"location":"javascript/bucle-for-of/#buenas-practicas-al-usar-forof","title":"Buenas pr\u00e1cticas al usar <code>for...of</code>","text":"<ol> <li>Usa <code>for...of</code> para estructuras iterables: Es ideal para recorrer arrays, strings y estructuras personalizadas.</li> <li>Evita <code>for...in</code> en arrays o strings: Como <code>for...in</code> recorre propiedades en lugar de valores, puede no funcionar correctamente con estructuras iterables.</li> <li>Define iterables personalizados seg\u00fan sea necesario: Implementa <code>Symbol.iterator</code> solo si necesitas un control avanzado sobre la iteraci\u00f3n.</li> </ol>"},{"location":"javascript/bucle-for-of/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los iterables y el bucle <code>for...of</code> son herramientas esenciales para manejar colecciones de datos de manera eficiente y legible en JavaScript. Al entender el protocolo iterable y c\u00f3mo implementar iteradores personalizados, puedes optimizar la interacci\u00f3n con estructuras de datos, tanto nativas como personalizadas.</p> <p>En el pr\u00f3ximo art\u00edculo, exploraremos los Generadores en JavaScript, que ofrecen una forma avanzada de crear y gestionar iteraciones con pausas controladas.</p> <p></p>"},{"location":"javascript/call-stack/","title":"Call Stack - Entendiendo la Pila de Llamadas","text":""},{"location":"javascript/call-stack/#call-stack-entendiendo-la-pila-de-llamadas","title":"Call Stack: Entendiendo la Pila de Llamadas","text":"<p>La pila de llamadas o call stack es un mecanismo en el cual se utiliza el motor de JavaScript para gestionar la ejecuci\u00f3n de funciones. Entender c\u00f3mo funciona te ayudar\u00e1 a escribir c\u00f3digo m\u00e1s eficiente y depurar problemas con mayor facilidad.</p> <p>En este art\u00edculo exploraremos c\u00f3mo funciona la pila de llamadas, c\u00f3mo gestiona los contextos de ejecuci\u00f3n y qu\u00e9 sucede cuando ocurre un desbordamiento de pila.</p>"},{"location":"javascript/call-stack/#que-es-la-pila-de-llamadas-en-javascript","title":"\u00bfQu\u00e9 es la Pila de Llamadas en JavaScript?","text":"<p>La pila de llamadas es una estructura de datos que sigue el principio de LIFO (Last In, First Out, el \u00faltimo en entrar es el primero en salir). Se utiliza para rastrear qu\u00e9 funci\u00f3n se est\u00e1 ejecutando actualmente y qu\u00e9 funciones han sido llamadas desde esa funci\u00f3n.</p>"},{"location":"javascript/call-stack/#como-funciona-la-pila-de-llamadas","title":"C\u00f3mo funciona la pila de llamadas","text":"<ol> <li>Cuando se ejecuta un script, el motor de JavaScript crea un contexto de ejecuci\u00f3n global y lo coloca en la pila.</li> <li>Cada vez que se llama a una funci\u00f3n, se crea un contexto de ejecuci\u00f3n de funci\u00f3n y se coloca en la parte superior de la pila.</li> <li>Cuando una funci\u00f3n termina, su contexto de ejecuci\u00f3n se elimina de la pila, y el control vuelve al contexto anterior.</li> <li>El script se detiene cuando la pila est\u00e1 vac\u00eda.</li> </ol>"},{"location":"javascript/call-stack/#ejemplo-basico-pila-de-llamadas-en-accion","title":"Ejemplo b\u00e1sico: Pila de Llamadas en acci\u00f3n","text":"<p>Para entender c\u00f3mo funciona el Call Stack, analicemos un ejemplo simple:</p> javascript<pre><code>function add(a, b) {\n    return a + b;\n}\n\nfunction average(a, b) {\n    return add(a, b) / 2;\n}\n\nlet result = average(10, 20);\n\nconsole.log(result);\n</code></pre>"},{"location":"javascript/call-stack/#paso-a-paso-en-la-pila-de-llamadas","title":"Paso a paso en la pila de llamadas","text":"<ol> <li>Inicio del programa: Se crea el contexto de ejecuci\u00f3n global y se coloca en la pila.</li> <li>Llamada a <code>average(10, 20)</code>: Se crea un nuevo contexto de ejecuci\u00f3n para <code>average</code> y se coloca en la parte superior de la pila.</li> <li>Dentro de <code>average</code>, llamada a la funci\u00f3n <code>add(10, 20)</code>: Se crea un contexto de ejecuci\u00f3n para <code>add</code> y se coloca en la pila.</li> <li><code>add</code> termina su ejecuci\u00f3n: Se elimina su contexto de la pila, y el control regresa a <code>average</code>.</li> <li><code>average</code> termina su ejecuci\u00f3n: Se elimina su contexto de la pila, y el control regresa al contexto global.</li> <li>El programa finaliza: Se muestra el resultado en consola, y la pila queda vac\u00eda.</li> </ol> <p>Aqu\u00ed est\u00e1 la representaci\u00f3n de c\u00f3mo la pila de llamadas evoluciona durante la ejecuci\u00f3n del c\u00f3digo anterior:</p> <p></p> <p></p> <p></p> <p>La pila crece de abajo hacia arriba (LIFO \u2013 Last In First Out) El Global Execution Context siempre permanece en la base de la pila Las nuevas llamadas se apilan encima de las existentes.</p>"},{"location":"javascript/call-stack/#desbordamiento-de-pila-stack-overflow","title":"Desbordamiento de Pila (Stack Overflow)","text":"<p>La pila de llamadas tiene un tama\u00f1o limitado, definido por el entorno de ejecuci\u00f3n (navegador o Node.js). Si se crean demasiados contextos de ejecuci\u00f3n sin completarlos, ocurre un stack overflow, y el programa se detiene.</p> javascript<pre><code>function recursive() {\n    recursive();\n}\n\nrecursive();\n\n// RangeError: Maximum call stack size exceeded\n</code></pre> <p>En el ejemplo anterior la funci\u00f3n <code>recursive</code> se llama a s\u00ed misma indefinidamente. La pila sigue creciendo con cada llamada sin eliminar contextos de ejecuci\u00f3n, eventualmente, el tama\u00f1o m\u00e1ximo de la pila se alcanza, y se lanza un error.</p>"},{"location":"javascript/call-stack/#javascript-es-un-lenguaje-de-un-solo-hilo","title":"JavaScript es un lenguaje de un solo hilo","text":"<p>JavaScript es un lenguaje de programaci\u00f3n de un solo hilo, lo que significa que solo puede ejecutar una tarea a la vez dentro de su proceso principal. Esto se debe a que utiliza un \u00fanico hilo de ejecuci\u00f3n para procesar operaciones, siguiendo un modelo basado en eventos. Esta caracter\u00edstica, aunque puede parecer una limitaci\u00f3n, est\u00e1 dise\u00f1ada para mantener el lenguaje ligero y eficiente, especialmente para aplicaciones web.</p> <p>Considera el siguiente ejemplo, que muestra c\u00f3mo JavaScript maneja las tareas de manera secuencial:</p> javascript<pre><code>console.log(\"Inicio del programa\");\n\nfunction tareaPesada() {\n    for (let i = 0; i &lt; 1e9; i++) {} // Simula una operaci\u00f3n pesada\n    console.log(\"Tarea pesada completada\");\n}\n\ntareaPesada();\n\nconsole.log(\"Fin del programa\");\n</code></pre> <p>En este caso, ninguna otra tarea puede ejecutarse mientras <code>tareaPesada</code> est\u00e1 en progreso, porque JavaScript solo tiene un hilo principal para manejar todo.</p>"},{"location":"javascript/call-stack/#implicaciones-del-modelo-de-un-solo-hilo","title":"Implicaciones del modelo de un solo hilo","text":"<p>El modelo de un solo hilo tiene ventajas y desaf\u00edos:</p>"},{"location":"javascript/call-stack/#ventajas","title":"Ventajas:","text":"<ol> <li>Facilidad para manejar estados: Dado que solo se ejecuta una tarea a la vez, no tienes que preocuparte por condiciones de carrera ni problemas de concurrencia que ocurren en lenguajes multihilo.</li> <li>Eficiencia en aplicaciones web: JavaScript est\u00e1 dise\u00f1ado para interactuar con el DOM de manera r\u00e1pida y efectiva, y el modelo de un solo hilo evita conflictos en la manipulaci\u00f3n de elementos.</li> </ol>"},{"location":"javascript/call-stack/#desafios","title":"Desaf\u00edos:","text":"<ol> <li>Bloqueos del hilo principal: Si una tarea toma mucho tiempo (como tareaPesada en el ejemplo), el navegador no puede procesar eventos, lo que provoca una mala experiencia de usuario.</li> <li>Gesti\u00f3n de operaciones concurrentes: Aunque JavaScript maneja bien las tareas asincr\u00f3nicas, requiere una comprensi\u00f3n del event loop y las colas de tareas.</li> </ol> <p> Para evitar bloquear el hilo principal, puedes delegar tareas intensivas a operaciones asincr\u00f3nicas utilizando funciones como setTimeout, promesas o async/await. Este enfoque permite mantener el hilo principal libre para procesar otras tareas, mejorando la respuesta de la aplicaci\u00f3n.</p> <p></p>"},{"location":"javascript/call-stack/#conclusion","title":"Conclusi\u00f3n","text":"<p>El Call Stack o Pila de llamada es fundamental para entender c\u00f3mo JavaScript ejecuta el c\u00f3digo y gestiona los contextos de ejecuci\u00f3n. Conocer c\u00f3mo funciona y c\u00f3mo manejar errores como el desbordamiento de pila es esencial para escribir c\u00f3digo eficiente y depurar problemas complejos.</p> <p>En el pr\u00f3ximo art\u00edculo exploraremos el event loop, que es clave para entender c\u00f3mo JavaScript maneja tareas asincr\u00f3nicas.</p> <p></p>"},{"location":"javascript/contexto-de-ejecucion/","title":"Contexto de Ejecuci\u00f3n","text":""},{"location":"javascript/contexto-de-ejecucion/#contexto-de-ejecucion","title":"Contexto de Ejecuci\u00f3n","text":"<p>El contexto de ejecuci\u00f3n es uno de los conceptos clave para entender c\u00f3mo JavaScript procesa y ejecuta el c\u00f3digo. Todo lo que ocurre en JavaScript, desde la ejecuci\u00f3n de una l\u00ednea de c\u00f3digo hasta la llamada de una funci\u00f3n, ocurre dentro de un contexto de ejecuci\u00f3n.</p> <p>En este art\u00edculo exploraremos qu\u00e9 es el contexto de ejecuci\u00f3n, sus fases principales (creaci\u00f3n y ejecuci\u00f3n), y c\u00f3mo afecta al comportamiento de tu c\u00f3digo.</p>"},{"location":"javascript/contexto-de-ejecucion/#que-es-el-contexto-de-ejecucion","title":"\u00bfQu\u00e9 es el Contexto de Ejecuci\u00f3n?","text":"<p>Cuando el motor de JavaScript ejecuta el c\u00f3digo crea un espacio llamado contexto de ejecuci\u00f3n. Este espacio es el entorno donde se eval\u00faan y ejecutan las instrucciones del programa. Existen dos tipos principales:</p> <ol> <li>Contexto de ejecuci\u00f3n global: Es el entorno base que se crea cuando el c\u00f3digo comienza a ejecutarse.</li> <li>Contexto de ejecuci\u00f3n de funci\u00f3n: Se crea cada vez que se invoca una funci\u00f3n.</li> </ol> javascript<pre><code>let x = 10;\n\nfunction timesTen(a) {\n    return a * 10;\n}\n\nlet y = timesTen(x);\n\nconsole.log(y);\n</code></pre> <p>En el ejemplo anterior pasa lo siguiente:</p> <ol> <li>Se declara la variable <code>x</code> y se inicializa con el valor <code>10</code>.</li> <li>Se define la funci\u00f3n <code>timesTen</code> que toma un argumento y lo multiplica por <code>10</code>.</li> <li>Se llama a <code>timesTen</code> con el valor de <code>x</code> y el resultado se almacena en <code>y</code>.</li> <li>Finalmente, se imprime el valor de <code>y</code>.</li> </ol> <p>Detr\u00e1s de escena, el motor de JavaScript crea y gestiona diferentes contextos de ejecuci\u00f3n para llevar a cabo estas acciones.</p>"},{"location":"javascript/contexto-de-ejecucion/#fases-del-contexto-de-ejecucion","title":"Fases del Contexto de Ejecuci\u00f3n","text":"<p>Cada contexto de ejecuci\u00f3n tiene dos fases principales:</p>"},{"location":"javascript/contexto-de-ejecucion/#1-fase-de-creacion","title":"1. Fase de Creaci\u00f3n","text":"<p>En esta fase, el motor de JavaScript prepara todo lo necesario para ejecutar el c\u00f3digo. Esto incluye:</p> <ul> <li>Crear el objeto global: En el navegador, esto es <code>window</code>, mientras que en Node.js es <code>global</code>.</li> <li>Crear el objeto <code>this</code>: En el contexto global, <code>this</code> se enlaza al objeto global.</li> <li>Configurar el espacio de memoria: El motor establece un \u00e1rea para almacenar variables y referencias a funciones.</li> <li>Inicializar variables y funciones: Las variables se inicializan con el valor <code>undefined</code>, y las declaraciones de funciones se almacenan completas.</li> </ul> javascript<pre><code>let x = 10;\n\nfunction timesTen(a) {\n    return a * 10;\n}\n\nlet y;\n</code></pre> <p>Durante esta fase: Se declara <code>x</code> y <code>y</code>, pero ambas se inicializan como <code>undefined</code>. La funci\u00f3n <code>timesTen</code> se almacena en memoria como una referencia completa.</p>"},{"location":"javascript/contexto-de-ejecucion/#2-fase-de-ejecucion","title":"2. Fase de Ejecuci\u00f3n","text":"<p>En esta fase el motor de JavaScript ejecuta el c\u00f3digo l\u00ednea por l\u00ednea: Asigna valores a las variables, eval\u00faa expresiones, llama a funciones y gestiona sus contextos de ejecuci\u00f3n.</p> javascript<pre><code>function timesTen(a) {\n    return a * 10;\n}\n\nlet x = 10; // Se asigna 10 a x\nlet y = timesTen(x); // Llama a timesTen con x como argumento\nconsole.log(y); // Muestra 100 en la consola\n</code></pre> <p>Cuando se llama a <code>timesTen</code>, se crea un nuevo contexto de ejecuci\u00f3n de funci\u00f3n, donde:</p> <ol> <li>Se crea un objeto <code>arguments</code> que referencia los par\u00e1metros pasados.</li> <li>Se inicializa el par\u00e1metro <code>a</code> con el valor <code>10</code>.</li> <li>Se ejecuta el cuerpo de la funci\u00f3n, devolviendo el resultado <code>100</code>.</li> </ol>"},{"location":"javascript/contexto-de-ejecucion/#el-papel-de-la-pila-de-llamadas-call-stack","title":"El Papel de la Pila de Llamadas (Call Stack)","text":"<p>El motor de JavaScript utiliza una estructura llamada call stack (pila de llamadas) para realizar un seguimiento de los contextos de ejecuci\u00f3n. Cada vez que se invoca una funci\u00f3n, su contexto de ejecuci\u00f3n se agrega a la pila. Una vez que se completa, se elimina de la pila.</p> <p>Ejemplo del call stack: Teniendo en cuenta el c\u00f3digo del ejemplo anterior, consideremos la siguiente secuencia:</p> <ol> <li>El contexto global se coloca en la pila.</li> <li>Cuando se llama a <code>timesTen</code>, su contexto de ejecuci\u00f3n se apila.</li> <li>Al finalizar la ejecuci\u00f3n de <code>timesTen</code>, su contexto se elimina y el control regresa al contexto global.</li> </ol>"},{"location":"javascript/contexto-de-ejecucion/#ejemplo-multiples-contextos-de-ejecucion","title":"Ejemplo: M\u00faltiples contextos de ejecuci\u00f3n","text":"<p>El contexto de ejecuci\u00f3n no se limita a un solo nivel, en un programa real m\u00faltiples funciones pueden interactuar y llamarse entre s\u00ed. Cada vez que se invoca una funci\u00f3n, se crea un nuevo contexto de ejecuci\u00f3n que se agrega a la pila de llamadas. En este ejemplo, veremos c\u00f3mo JavaScript gestiona estos contextos de ejecuci\u00f3n y c\u00f3mo la pila organiza el flujo del programa.</p> javascript<pre><code>function first() {\n    console.log(\"Primera funci\u00f3n\");\n    second();\n}\n\nfunction second() {\n    console.log(\"Segunda funci\u00f3n\");\n}\n\nconsole.log(\"Inicio del programa\");\nfirst();\nconsole.log(\"Fin del programa\");\n</code></pre> <p>En el c\u00f3digo anterior pasa lo siguiente:</p> <ol> <li>El programa comienza con el contexto global, donde se ejecuta el primer <code>console.log</code>.</li> <li>Al llamar a <code>first()</code>, se crea un nuevo contexto de ejecuci\u00f3n y se agrega a la pila.</li> <li>Dentro de <code>first</code>, se invoca <code>second()</code>, creando un tercer contexto de ejecuci\u00f3n.</li> <li>Una vez que <code>second</code> finaliza, su contexto se elimina de la pila y el control regresa a <code>first</code>.</li> <li>Finalmente, el contexto de `first se elimina y el flujo vuelve al contexto global para completar el programa.</li> </ol>"},{"location":"javascript/contexto-de-ejecucion/#explicacion-del-flujo","title":"Explicaci\u00f3n del flujo","text":"<ol> <li>Contexto global: Se ejecuta el c\u00f3digo principal y se llama a la funci\u00f3n <code>first</code>.</li> <li>Contexto de <code>first</code>: Se registra el mensaje \u201cPrimera funci\u00f3n\u201d y se llama a la funci\u00f3n <code>second</code>.</li> <li>Contexto de <code>second</code>: Se registra \u201cSegunda funci\u00f3n\u201d, y su ejecuci\u00f3n se completa.</li> <li>Regreso al contexto de <code>first</code>: Se finaliza la ejecuci\u00f3n de <code>first</code> y se elimina su contexto.</li> <li>Regreso al contexto global: Se imprime \u201cFin del programa\u201d.</li> </ol> <p>Este flujo muestra c\u00f3mo JavaScript utiliza la pila de llamadas para gestionar m\u00faltiples contextos de ejecuci\u00f3n de manera eficiente.</p>"},{"location":"javascript/contexto-de-ejecucion/#conclusion","title":"Conclusi\u00f3n","text":"<p>El contexto de ejecuci\u00f3n es el n\u00facleo de c\u00f3mo JavaScript procesa el c\u00f3digo. Comprender c\u00f3mo se crean y manejan estos contextos, junto con sus fases, te ayuda a depurar errores, entender el flujo del programa y escribir c\u00f3digo m\u00e1s eficiente.</p> <p>En el pr\u00f3ximo art\u00edculo exploraremos la pila de llamadas (call stack) en profundidad para entender c\u00f3mo JavaScript organiza y procesa m\u00faltiples contextos de ejecuci\u00f3n.</p> <p></p>"},{"location":"javascript/encadenamiento-de-promesas/","title":"Encadenamiento de Promesas","text":""},{"location":"javascript/encadenamiento-de-promesas/#encadenamiento-de-promesas","title":"Encadenamiento de Promesas","text":"<p>El encadenamiento de promesas es una t\u00e9cnica que permite ejecutar operaciones as\u00edncronas de manera secuencial, pasando los resultados de una operaci\u00f3n a la siguiente. Este enfoque facilita la gesti\u00f3n de flujos as\u00edncronos complejos, evitando el uso de m\u00faltiples callbacks anidados (conocido como \u201cCallback Hell\u201d) y haciendo el c\u00f3digo m\u00e1s limpio y legible.</p> <p>En este art\u00edculo, aprenderemos c\u00f3mo funciona el encadenamiento de promesas, c\u00f3mo implementarlo correctamente, y las buenas pr\u00e1cticas que debes seguir para maximizar su eficacia.</p>"},{"location":"javascript/encadenamiento-de-promesas/#que-es-el-encadenamiento-de-promesas","title":"\u00bfQu\u00e9 es el encadenamiento de promesas?","text":"<p>El encadenamiento de promesas utiliza el m\u00e9todo <code>.then()</code> para conectar m\u00faltiples operaciones as\u00edncronas . Cada <code>then()</code> devuelve una nueva promesa, lo que permite que los resultados de una operaci\u00f3n se pasen a la siguiente de manera ordenada.</p> <p>Ejemplo B\u00e1sico de Encadenamiento</p> javascript<pre><code>const promesa = new Promise((resolve) =&gt; {\n    setTimeout(() =&gt; {\n        resolve(10);\n    }, 1000);\n});\n\npromesa\n    .then((resultado) =&gt; {\n        console.log(\"Primer resultado:\", resultado);\n        return resultado * 2;\n    })\n    .then((nuevoResultado) =&gt; {\n        console.log(\"Segundo resultado:\", nuevoResultado);\n        return nuevoResultado + 5;\n    })\n    .then((final) =&gt; {\n        console.log(\"Tercer resultado:\", final);\n    });\n</code></pre> <p>En el ejemplo anterior cada operaci\u00f3n se encadena con <code>then</code>, donde el resultado de una promesa se pasa a la siguiente para continuar con el flujo.</p>"},{"location":"javascript/encadenamiento-de-promesas/#como-funciona-el-encadenamiento","title":"\u00bfC\u00f3mo Funciona el Encadenamiento?","text":"<p>El m\u00e9todo <code>.then()</code> siempre devuelve una nueva promesa, lo que permite construir una cadena de operaciones. Si la funci\u00f3n pasada a <code>.then()</code>:</p> <ul> <li>Devuelve un valor: ese valor se envuelve autom\u00e1ticamente en una promesa resuelta.</li> <li>Devuelve otra promesa: el siguiente <code>.then()</code> esperar\u00e1 a que esta se resuelva.</li> </ul>"},{"location":"javascript/encadenamiento-de-promesas/#casos-practicos-en-el-encadenamiento","title":"Casos pr\u00e1cticos en el encadenamiento","text":""},{"location":"javascript/encadenamiento-de-promesas/#promesa-que-devuelve-un-valor-directo","title":"Promesa que devuelve un valor directo","text":"<p>Si el <code>then</code> devuelve un valor que no es una promesa, el valor se envuelve autom\u00e1ticamente en una promesa resuelta.</p> javascript<pre><code>const promesa = new Promise((resolve) =&gt; resolve(5));\n\npromesa\n    .then((resultado) =&gt; resultado * 2)\n    .then((doble) =&gt; console.log(doble));\n</code></pre>"},{"location":"javascript/encadenamiento-de-promesas/#promesa-que-devuelve-otra-promesa","title":"Promesa que devuelve otra promesa","text":"<p>Si <code>.then()</code> devuelve otra promesa, el encadenamiento esperar\u00e1 hasta que esta nueva promesa se resuelva.</p> javascript<pre><code>const promesa = new Promise((resolve) =&gt; resolve(10));\n\npromesa\n    .then((resultado) =&gt; {\n        return new Promise((resolve) =&gt; {\n        setTimeout(() =&gt; resolve(resultado * 3), 2000);\n        });\n    })\n    .then((resultado) =&gt; console.log(\"Resultado:\", resultado)); // (tras 2 segundos)\n</code></pre>"},{"location":"javascript/encadenamiento-de-promesas/#errores-comunes-en-el-encadenamiento","title":"Errores comunes en el encadenamiento","text":"<p>No devolver un valor en <code>.then()</code>: Es importante entender que para que el encadenamiento sea efectivo, el <code>then</code> debe devolver un valor o una promesa. Si solo se llama al <code>then</code> sin devolver nada, la cadena se interrumpe.</p> javascript<pre><code>const promesa = new Promise((resolve) =&gt; resolve(10));\n\npromesa\n    .then((resultado) =&gt; {\n        console.log(resultado); // 10\n        // No devuelve nada, el siguiente `.then()` no recibe un valor\n    })\n    .then((resultado) =&gt; {\n        console.log(\"Este c\u00f3digo no recibir\u00e1 un valor adecuado\");\n    });\n</code></pre> <p>Aseg\u00farate de devolver un valor o una promesa.</p> <p>M\u00faltiples <code>.then()</code> independientes: Si llamas a <code>.then()</code> varias veces sobre la misma promesa sin pasar valores entre ellas, estas ejecuciones no estar\u00e1n encadenadas.</p> javascript<pre><code>const promesa = new Promise((resolve) =&gt; resolve(10));\n\npromesa\n    .then((resultado) =&gt; console.log(\"Primera operaci\u00f3n:\", resultado)) // Primera operaci\u00f3n: 10\n    .then((resultado) =&gt; console.log(\"Segunda operaci\u00f3n:\", resultado)); // Segunda operaci\u00f3n: undefined\n</code></pre>"},{"location":"javascript/encadenamiento-de-promesas/#buenas-practicas-para-el-encadenamiento-de-promesas","title":"Buenas pr\u00e1cticas para el encadenamiento de promesas","text":"<p>Para aprovechar al m\u00e1ximo el encadenamiento de promesas, ten en cuenta las siguientes recomendaciones:</p> <ol> <li>Devuelve siempre un valor o promesa en <code>.then()</code>: Aseg\u00farate de devolver algo para que el flujo contin\u00fae.</li> <li>Evita anidar promesas dentro de <code>.then()</code>: En lugar de anidar, aprovecha el encadenamiento natural.</li> <li>Maneja los errores con <code>.catch()</code>: Captura errores en cualquier punto de la cadena para evitar comportamientos inesperados.</li> <li>Usa <code>.finally()</code> para tareas finales: Realiza acciones que no dependan del resultado de las promesas.</li> </ol>"},{"location":"javascript/encadenamiento-de-promesas/#conclusion","title":"Conclusi\u00f3n","text":"<p>El encadenamiento de promesas en JavaScript es una t\u00e9cnica poderosa para manejar flujos as\u00edncronos de manera ordenada y legible. Al devolver valores o promesas en cada <code>.then()</code>, puedes construir cadenas claras y evitar el caos de los callbacks anidados. Adem\u00e1s, el uso adecuado de <code>.catch()</code> y <code>.finally()</code> asegura que tu c\u00f3digo sea robusto y f\u00e1cil de mantener.</p> <p>En el pr\u00f3ximo art\u00edculo, exploraremos Promise.all en JavaScript, una herramienta para ejecutar m\u00faltiples promesas en paralelo.</p> <p></p>"},{"location":"javascript/event-loop/","title":"Event Loop","text":""},{"location":"javascript/event-loop/#event-loop","title":"Event Loop","text":"<p>El event loop (bucle de eventos) es un componente fundamental del tiempo de ejecuci\u00f3n de JavaScript que permite manejar tareas asincr\u00f3nicas y coordinar su ejecuci\u00f3n con las operaciones s\u00edncronas. Aunque JavaScript es un lenguaje de un solo hilo, gracias al event loop puede gestionar tareas concurrentes sin bloquear la ejecuci\u00f3n principal.</p> <p>En este art\u00edculo exploraremos c\u00f3mo funciona el event loop, qu\u00e9 papel desempe\u00f1an las colas de tareas y las APIs del navegador y c\u00f3mo puedes usar esta comprensi\u00f3n para optimizar el rendimiento de tus aplicaciones.</p>"},{"location":"javascript/event-loop/#que-es-el-event-loop","title":"\u00bfQu\u00e9 es el Event Loop?","text":"<p>El event loop es un proceso que constantemente verifica dos componentes principales del entorno de ejecuci\u00f3n de JavaScript:</p> <ol> <li>La pila de llamadas (call stack): Donde se procesan las funciones y contextos de ejecuci\u00f3n.</li> <li>La cola de tareas (task queue): Donde se almacenan las tareas asincr\u00f3nicas pendientes, como callbacks de temporizadores o eventos del DOM.</li> </ol> <p>Cuando la pila de llamadas est\u00e1 vac\u00eda, el event loop transfiere las tareas pendientes desde la cola de tareas a la pila de llamadas, asegurando que se ejecuten una a una en orden.</p>"},{"location":"javascript/event-loop/#como-funciona-el-event-loop","title":"C\u00f3mo funciona el Event Loop","text":"<p>El funcionamiento del event loop puede parecer complejo al principio, pero sigue un flujo claro y definido. Este mecanismo coordina la ejecuci\u00f3n de las tareas s\u00edncronas y asincr\u00f3nicas para garantizar que el c\u00f3digo se procese de manera ordenada.</p> <ol> <li>Ejecuci\u00f3n inicial: El script principal se ejecuta desde el principio hasta el final, manejando funciones y operaciones s\u00edncronas.</li> <li>Tareas asincr\u00f3nicas: Las tareas como <code>setTimeout</code>, promesas y eventos del DOM se delegan a las APIs del navegador (o Node.js en entornos de servidor).</li> <li>Cola de tareas: Cuando una tarea asincr\u00f3nica est\u00e1 lista para ejecutarse (por ejemplo, despu\u00e9s de que un temporizador expire), se coloca en la cola de tareas.</li> <li>Interacci\u00f3n del event loop: El event loop verifica constantemente la pila de llamadas. Si est\u00e1 vac\u00eda, toma la primera tarea de la cola de tareas y la coloca en la pila para ejecutarla.</li> </ol> <p></p> <p>Event Loop: Constantemente revisa si puede mover tareas de la Cola a la Pila</p>"},{"location":"javascript/event-loop/#ejemplo-basico-del-event-loop","title":"Ejemplo b\u00e1sico del Event Loop","text":"<p>Para entender un poco en la pr\u00e1ctica, veamos un ejemplo sencillo que combina operaciones s\u00edncronas y una tarea asincr\u00f3nica con <code>setTimeout</code>. Este ejemplo ilustrar\u00e1 c\u00f3mo JavaScript maneja la ejecuci\u00f3n de las tareas y cu\u00e1ndo las coloca en la cola de tareas para procesarlas.</p> javascript<pre><code>console.log(\"Inicio del programa\");\n\nsetTimeout(() =&gt; {\n    console.log(\"Tarea desde setTimeout\");\n}, 1000);\n\nconsole.log(\"Fin del programa\");\n</code></pre> <p>Explicaci\u00f3n del ejemplo anterior:</p> <ol> <li>Inicio del programa: La funci\u00f3n <code>console.log(\"Inicio del programa\")</code> se ejecuta inmediatamente.</li> <li>Tarea asincr\u00f3nica: La funci\u00f3n <code>setTimeout</code> delega su tarea a las APIs del navegador, configurando un temporizador de 1 segundo.</li> <li>Fin del programa: La \u00faltima instrucci\u00f3n s\u00edncrona, <code>console.log(\"Fin del programa\")</code>, se ejecuta inmediatamente.</li> <li>Tarea en la cola: Despu\u00e9s de 1 segundo, la callback de <code>setTimeout</code> se mueve de la cola de tareas a la pila de llamadas y se ejecuta.</li> </ol>"},{"location":"javascript/event-loop/#web-apis-y-su-interaccion-con-el-event-loop","title":"Web APIs y su interacci\u00f3n con el Event Loop","text":"<p>El event loop no opera solo; trabaja en conjunto con las Web APIs, que gestionan tareas asincr\u00f3nicas como:</p> <ul> <li>Temporizadores: (<code>setTimeout</code>, <code>setInterval</code>).</li> <li>Peticiones HTTP: (<code>fetch</code>, <code>XMLHttpRequest</code>).</li> <li>Eventos del DOM: (clics, movimientos del mouse, etc.).</li> </ul> <p>Por ejemplo, cuando llamas a <code>setTimeout</code>, el temporizador se gestiona fuera del motor de JavaScript por las APIs del navegador, y su callback se coloca en la cola de tareas una vez que expira el tiempo.</p>"},{"location":"javascript/event-loop/#colas-de-microtareas-y-macrotareas","title":"Colas de microtareas y macrotareas","text":"<p>En JavaScript, el event loop no solo maneja la ejecuci\u00f3n de las tareas de manera secuencial, sino que tambi\u00e9n organiza las tareas en diferentes colas dependiendo de su prioridad. Estas colas principales son:</p> <ul> <li>Microtareas: Tienen la m\u00e1xima prioridad y se procesan antes de las macrotareas. (Promesas resueltas (<code>Promise.then()</code> o <code>async/await</code>). <code>MutationObserver</code>)</li> <li>Macrotareas: Son tareas de menor prioridad y se ejecutan despu\u00e9s de todas las microtareas pendientes (Temporizadores como <code>setTimeout</code> y <code>setInterval</code>, eventos del DOM o Operaciones de I/O en Node.js)</li> </ul> <p>Este mecanismo asegura que las tareas cr\u00edticas (como la resoluci\u00f3n de promesas) se procesen lo antes posible, mientras que otras tareas menos urgentes (como <code>setTimeout</code>) esperan su turno.</p> <p></p>"},{"location":"javascript/event-loop/#ejemplo-prioridad-de-microtareas","title":"Ejemplo: Prioridad de microtareas","text":"javascript<pre><code>console.log(\"Inicio\");\n\nsetTimeout(() =&gt; {\n    console.log(\"Macrotarea: setTimeout\");\n}, 0);\n\nPromise.resolve().then(() =&gt; {\n    console.log(\"Microtarea: Promesa resuelta\");\n});\n\nconsole.log(\"Fin\");\n</code></pre> <p> La recomendaci\u00f3n es evitar el abuso de microtareas. si se abusa en sus encadenamientos, estas pueden bloquear temporalmente la ejecuci\u00f3n de macrotareas importantes. Por otra parte se recomienda optimizar las macrotareas. Dividir tareas grandes en fragmentos m\u00e1s peque\u00f1os para no bloquear la interfaz de usuario.</p> <p></p>"},{"location":"javascript/event-loop/#errores-comunes-relacionados-con-el-event-loop","title":"Errores comunes relacionados con el Event Loop","text":"<ol> <li>Bloqueo del hilo principal: Tareas intensivas como grandes bucles o c\u00e1lculos pueden bloquear la pila de llamadas y retrasar la ejecuci\u00f3n de tareas asincr\u00f3nicas.</li> <li>Dependencia de la prioridad de tareas: No comprender c\u00f3mo las microtareas y macrotareas se procesan puede causar comportamientos inesperados en tu aplicaci\u00f3n.</li> </ol>"},{"location":"javascript/event-loop/#conclusion","title":"Conclusi\u00f3n","text":"<p>El event loop es una pieza fundamental del runtime de JavaScript que permite la gesti\u00f3n eficiente de tareas concurrentes. Comprender su funcionamiento, junto con las colas de microtareas y macrotareas, es clave para escribir aplicaciones m\u00e1s r\u00e1pidas y reactivas.</p> <p></p>"},{"location":"javascript/exportacion-modulos/","title":"Exportaci\u00f3n","text":""},{"location":"javascript/exportacion-modulos/#exportacion","title":"Exportaci\u00f3n","text":"<p>La exportaci\u00f3n en JavaScript permite compartir variables, funciones y clases entre m\u00f3dulos, facilitando la reutilizaci\u00f3n del c\u00f3digo y mejorando la organizaci\u00f3n de aplicaciones modernas. Introducida en ES6, la exportaci\u00f3n estandariza el uso de m\u00f3dulos, haci\u00e9ndolos m\u00e1s eficientes y f\u00e1ciles de mantener. Este art\u00edculo explora los tipos de exportaciones, sus diferencias y las mejores pr\u00e1cticas para exportar c\u00f3digo en JavaScript.</p>"},{"location":"javascript/exportacion-modulos/#concepto-de-exportacion-en-javascript","title":"Concepto de Exportaci\u00f3n en JavaScript","text":"<p>Un m\u00f3dulo en JavaScript encapsula su c\u00f3digo y limita el acceso a sus elementos a menos que sean exportados expl\u00edcitamente. Esto evita conflictos de nombres y promueve un c\u00f3digo m\u00e1s modular y organizado.</p> <p>Los dos tipos principales de exportaciones son:</p> <ol> <li>Exportaci\u00f3n nombrada: Permite exportar m\u00faltiples elementos de un m\u00f3dulo.</li> <li>Exportaci\u00f3n por defecto: Designa un \u00fanico elemento principal por m\u00f3dulo.</li> </ol>"},{"location":"javascript/exportacion-modulos/#exportacion-nombrada","title":"Exportaci\u00f3n Nombrada","text":"<p>La exportaci\u00f3n nombrada se utiliza cuando se necesitan exportar m\u00faltiples valores de un mismo m\u00f3dulo. Cada elemento que se desea exportar se especifica con la palabra clave <code>export</code>, lo que permite que otros m\u00f3dulos lo importen usando su nombre exacto.</p> <p>Ejemplo B\u00e1sico de Exportaci\u00f3n Nombrada: En este ejemplo, exportamos una constante y dos funciones de forma nombrada.</p> javascript<pre><code>// matematicas.js\nexport const PI = 3.14159;\n\nexport function calcularArea(radio) {\n    return PI * radio * radio;\n}\n\nexport function calcularCircunferencia(radio) {\n    return 2 * PI * radio;\n}\n</code></pre>"},{"location":"javascript/exportacion-modulos/#exportacion-nombrada-agrupada","title":"Exportaci\u00f3n Nombrada Agrupada","text":"<p>Tambi\u00e9n es posible agrupar varias exportaciones en una sola declaraci\u00f3n al final del archivo, lo que ayuda a organizar el c\u00f3digo.</p> javascript<pre><code>const E = 2.718;\nfunction calcularExponente(x) {\n    return Math.pow(E, x);\n}\n\nexport { E, calcularExponente };\n</code></pre> <p>Esta estructura mejora la claridad en archivos con muchas exportaciones, facilitando la b\u00fasqueda de todas las exportaciones en un solo lugar al final del m\u00f3dulo.</p>"},{"location":"javascript/exportacion-modulos/#exportacion-por-defecto","title":"Exportaci\u00f3n por Defecto","text":"<p>La exportaci\u00f3n por defecto permite designar un elemento principal de un m\u00f3dulo, lo que simplifica su importaci\u00f3n. A diferencia de las exportaciones nombradas, solo puede existir una exportaci\u00f3n por defecto en cada m\u00f3dulo.</p> javascript<pre><code>// saludo.js\nexport default function saludar(nombre) {\n    return `\u00a1Hola, ${nombre}!`;\n}\n</code></pre> <p>La exportaci\u00f3n por defecto es \u00fatil cuando un m\u00f3dulo tiene una funci\u00f3n o clase principal que representa la funcionalidad esencial del archivo.</p>"},{"location":"javascript/exportacion-modulos/#diferencias-entre-exportacion-nombrada-y-por-defecto","title":"Diferencias entre exportaci\u00f3n nombrada y por defecto","text":"<p>Aunque ambos tipos de exportaci\u00f3n permiten compartir elementos entre m\u00f3dulos, existen diferencias clave en su uso y sintaxis:</p>"},{"location":"javascript/exportacion-modulos/#caracteristicas-de-la-exportacion-nombrada","title":"Caracter\u00edsticas de la Exportaci\u00f3n Nombrada","text":"<ul> <li>Permite m\u00faltiples exportaciones: Es posible exportar varias funciones, constantes o clases de un m\u00f3dulo.</li> <li>Debe usar el nombre exacto: Al importar se requiere el nombre con el que fue exportado.</li> <li>Renombrado Opcional: Se puede renombrar el elemento al importarlo, lo cual ayuda a evitar conflictos de nombres.</li> </ul> javascript<pre><code>import { calcularArea as area, calcularCircunferencia } from './matematicas.js';\n</code></pre>"},{"location":"javascript/exportacion-modulos/#caracteristicas-de-la-exportacion-por-defecto","title":"Caracter\u00edsticas de la Exportaci\u00f3n por Defecto","text":"<ul> <li>Una sola exportaci\u00f3n: Solo un valor puede ser exportado por defecto en un m\u00f3dulo.</li> <li>Sin llaves: No es necesario usar { } al importar.</li> <li>Renombrado Autom\u00e1tico: Al importarlo, se le puede asignar cualquier nombre.</li> </ul> javascript<pre><code>import cualquierNombre from './saludo.js';\ncualquierNombre(\"Ana\");  // Output: \u00a1Hola, Ana!\n</code></pre> <p>Estas diferencias permiten que las exportaciones por defecto se usen para el elemento principal de un m\u00f3dulo, mientras que las exportaciones nombradas son ideales para exportar m\u00faltiples elementos secundarios.</p>"},{"location":"javascript/exportacion-modulos/#renombrado-de-exportaciones","title":"Renombrado de exportaciones","text":"<p>Renombrar exportaciones es \u00fatil para evitar conflictos o mejorar la claridad al importar en otros m\u00f3dulos. Esto se puede hacer tanto al exportar como al importar:</p> <p>Renombrado al Exportar</p> javascript<pre><code>const velocidadLuz = 299792458;\nexport { velocidadLuz as c };\n</code></pre> <p>Renombrado al Importar</p> javascript<pre><code>import { c as velocidad } from './constantes.js';\n// velocidad;  Output: 299792458\n</code></pre>"},{"location":"javascript/exportacion-modulos/#reexportacion-de-modulos","title":"Reexportaci\u00f3n de M\u00f3dulos","text":"<p>La reexportaci\u00f3n permite exportar valores importados de otros m\u00f3dulos, creando puntos de acceso centralizados para m\u00f3dulos complejos. Esto es especialmente \u00fatil en archivos de \u00edndice (index.js) donde se desea centralizar la importaci\u00f3n de varios m\u00f3dulos.</p> javascript<pre><code>// constantes.js\nexport const GRAVEDAD = 9.81;\nexport const PI = 3.14159;\n\n// index.js\nexport { GRAVEDAD, PI } from './constantes.js';\n</code></pre> <p>Ahora puedes importar todo desde index.js:</p> javascript<pre><code>import { GRAVEDAD, PI } from './index.js';\n</code></pre>"},{"location":"javascript/exportacion-modulos/#buenas-practicas-al-exportar-en-javascript","title":"Buenas pr\u00e1cticas al exportar en JavaScript","text":"<p>Al exportar en JavaScript, es bueno mantener un c\u00f3digo organizado y seguir algunas pr\u00e1cticas recomendadas para mejorar la mantenibilidad:</p> <ol> <li>Usa exportaciones por defecto para el componente principal: Si un m\u00f3dulo tiene una funcionalidad principal, usa la exportaci\u00f3n por defecto.</li> <li>Prefiere exportaciones nombradas para m\u00f3dulos complejos: Si hay varias funciones o valores, es m\u00e1s claro usar exportaciones nombradas.</li> <li>Evita exportaciones circulares: Las dependencias circulares pueden causar errores dif\u00edciles de depurar. Dise\u00f1a tus m\u00f3dulos para evitar estas dependencias.</li> <li>Organiza las exportaciones: Agrupa todas las exportaciones al final del archivo para mejorar la legibilidad.</li> </ol>"},{"location":"javascript/exportacion-modulos/#conclusion","title":"Conclusi\u00f3n","text":"<p>La exportaci\u00f3n en JavaScript es una herramienta poderosa para organizar y compartir c\u00f3digo entre m\u00f3dulos. Usar exportaciones nombradas y por defecto de manera adecuada permite construir aplicaciones modulares y escalables, mejorando la colaboraci\u00f3n y el mantenimiento del c\u00f3digo.</p> <p></p>"},{"location":"javascript/generadores-asincronos/","title":"Generadores As\u00edncronos","text":""},{"location":"javascript/generadores-asincronos/#generadores-asincronos","title":"Generadores As\u00edncronos","text":"<p>Los generadores as\u00edncronos en JavaScript permiten producir y consumir valores de manera as\u00edncrona, haciendo uso de promesas para manejar la producci\u00f3n de datos que llegan en tiempos irregulares. Con la ayuda de <code>async function*</code> y <code>for await...of</code>, los generadores as\u00edncronos facilitan el control de secuencias de datos as\u00edncronas, ideal para leer datos de APIs, streams o cualquier fuente de datos que no est\u00e9 disponible de inmediato.</p>"},{"location":"javascript/generadores-asincronos/#que-es-un-generador-asincrono","title":"\u00bfQu\u00e9 es un Generador As\u00edncrono?","text":"<p>Un generador as\u00edncrono es similar a un generador regular, pero permite pausar su ejecuci\u00f3n y esperar a que una promesa se resuelva antes de continuar. Esto permite que el generador as\u00edncrono funcione en contextos donde los datos se obtienen en tiempo real o de fuentes as\u00edncronas.</p> <p>Sintaxis B\u00e1sica de un Generador As\u00edncrono</p> <p>Para definir un generador as\u00edncrono, usamos <code>async function*</code>:</p> javascript<pre><code>async function* nombreDelGenerador() {\n    // C\u00f3digo del generador as\u00edncrono\n}\n</code></pre> <p>La palabra clave <code>async</code> permite que la funci\u00f3n pause en <code>await</code> dentro de la funci\u00f3n generadora, mientras que <code>*</code> indica que es un generador.</p>"},{"location":"javascript/generadores-asincronos/#uso-de-yield-y-await-en-generadores-asincronos","title":"Uso de <code>yield</code> y <code>await</code> en Generadores As\u00edncronos","text":"<p>En un generador as\u00edncrono podemos utilizar <code>await</code> para esperar la resoluci\u00f3n de promesas antes de pasar al siguiente <code>yield</code>. Esto es ideal para manejar datos que tardan en llegar, como resultados de una API o respuestas de una base de datos.</p> <p>Ejemplo B\u00e1sico de un Generador As\u00edncrono</p> javascript<pre><code>async function* generadorAsincrono() {\n    const datos = [1, 2, 3];\n    for (const dato of datos) {\n        await new Promise(resolve =&gt; setTimeout(resolve, 1000));  // Espera de 1 segundo\n        yield dato;\n    }\n}\n\n(async () =&gt; {\n    for await (const valor of generadorAsincrono()) {\n        return valor;  // Output: 1, 2, 3 (con un segundo de intervalo)\n    }\n})();\n</code></pre> <p>En el c\u00f3digo anterior la funci\u00f3n generadora <code>generadorAsincrono</code> pausa un segundo antes de devolver cada valor, simulando la espera de datos as\u00edncronos en cada paso.</p>"},{"location":"javascript/generadores-asincronos/#casos-de-uso-de-los-generadores-asincronos","title":"Casos de Uso de los Generadores As\u00edncronos","text":"<p>Los generadores as\u00edncronos son \u00fatiles en situaciones en las que los datos llegan en diferentes intervalos de tiempo o donde la fuente de datos es remota. Algunos casos de uso incluyen:</p> <ul> <li>Procesamiento de Streams de Datos: Como leer un archivo grande o datos de un stream en red.</li> <li>Consultas Paginadas en APIs: Obtener datos en lotes desde un servidor sin bloquear el flujo.</li> <li>Monitoreo de Eventos en Tiempo Real: Manejar datos que llegan de manera continua, como notificaciones o mensajes de una aplicaci\u00f3n de chat.</li> </ul> <p>Ejemplo: Generador As\u00edncrono para Consultas Paginadas</p> javascript<pre><code>async function* obtenerDatosPorPagina() {\n    let pagina = 1;\n    while (true) {\n        const respuesta = await fetch(`https://api.example.com/data?page=${pagina}`);\n        const datos = await respuesta.json();\n        if (datos.length === 0) break;\n        yield datos;\n        pagina++;\n    }\n}\n\n(async () =&gt; {\n    for await (const lote of obtenerDatosPorPagina()) {\n        return lote;\n    }\n})();\n</code></pre> <p>En este ejemplo <code>obtenerDatosPorPagina</code> es un generador as\u00edncrono que recupera y devuelve datos en lotes. El bucle <code>for await...of</code> permite procesar cada lote de datos tan pronto como est\u00e1 disponible, sin esperar a que se descargue todo.</p>"},{"location":"javascript/generadores-asincronos/#ejemplo-de-generador-asincrono-con-streams-de-datos","title":"Ejemplo de Generador As\u00edncrono con Streams de Datos","text":"<p>El siguiente ejemplo demuestra c\u00f3mo usar un generador as\u00edncrono para procesar un stream de datos en fragmentos. Este m\u00e9todo es \u00fatil para manejar archivos o datos de red grandes.</p> javascript<pre><code>async function* procesarStream(lectura) {\n    const decodificador = new TextDecoderStream();\n    const stream = lectura.pipeThrough(decodificador);\n    const lector = stream.getReader();\n\n    try {\n        while (true) {\n            const { done, value } = await lector.read();\n            if (done) break;\n            yield value;\n        }\n    } finally {\n        lector.releaseLock();\n    }\n}\n\n// Ejemplo de uso con un objeto de lectura de archivo\n(async () =&gt; {\n    const respuesta = await fetch(\"https://example.com/archivoGrande.txt\");\n    for await (const fragmento of procesarStream(respuesta.body)) {\n        console.log(fragmento);  // Output: Fragmentos de texto del archivo\n    }\n})();\n</code></pre> <p>En el codigo anterior el generador <code>procesarStream</code> se encarga de leer fragmentos de un stream de datos en texto. Con <code>for await...of</code>, el archivo se procesa en trozos, ideal para manejar datos de gran tama\u00f1o sin saturar la memoria.</p>"},{"location":"javascript/generadores-asincronos/#buenas-practicas-al-usar-generadores-asincronos","title":"Buenas Pr\u00e1cticas al Usar Generadores As\u00edncronos","text":"<ol> <li>Usa Generadores As\u00edncronos para Fuentes de Datos que Llevan Tiempo: Aprovecha los generadores as\u00edncronos para obtener datos que pueden tardar en llegar, como API remotas o streams de red.</li> <li>Controla la Finalizaci\u00f3n con <code>try...finally</code>: En generadores que procesan streams o conexiones, usa <code>try...finally</code> para liberar recursos como lectores o cierres de streams.</li> <li>Utiliza <code>for await...of</code> para una Iteraci\u00f3n Limpia y Eficiente: Al iterar con <code>for await...of</code>, se puede manejar cada valor as\u00edncrono a medida que est\u00e1 disponible, sin bloquear el flujo del programa.</li> </ol>"},{"location":"javascript/generadores-asincronos/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los generadores as\u00edncronos en JavaScript son herramientas esenciales para trabajar con flujos de datos que se producen de manera as\u00edncrona y controlada. Usando <code>async function*</code>, <code>await</code> y <code>for await...of</code>, es posible procesar datos de APIs, streams y otros recursos remotos sin bloquear la aplicaci\u00f3n. Al dominar los generadores as\u00edncronos, puedes construir aplicaciones m\u00e1s eficientes y receptivas para operaciones complejas y en tiempo real.</p> <p></p>"},{"location":"javascript/generadores/","title":"Generadores","text":""},{"location":"javascript/generadores/#generadores","title":"Generadores","text":"<p>Los generadores en JavaScript son un tipo especial de funci\u00f3n que permite pausar y reanudar su ejecuci\u00f3n, devolviendo valores en m\u00faltiples etapas. Esta capacidad de \u201cpausa\u201d convierte a los generadores en una herramienta valiosa para manejar secuencias y flujos de datos complejos.</p> <p>En este art\u00edculo exploraremos c\u00f3mo funcionan los generadores, su sintaxis y el uso de las palabras clave <code>function*</code> y <code>yield</code>. Tambi\u00e9n revisaremos sus aplicaciones pr\u00e1cticas y las buenas pr\u00e1cticas para aprovechar al m\u00e1ximo esta caracter\u00edstica.</p>"},{"location":"javascript/generadores/#que-es-un-generador","title":"\u00bfQu\u00e9 es un generador?","text":"<p>Un generador es una funci\u00f3n que puede detener temporalmente su ejecuci\u00f3n y luego reanudarla desde donde se detuvo. Cada vez que un generador se \u201cpausa\u201d, puede devolver un valor sin perder su contexto. Esto se logra mediante la palabra clave <code>yield</code>, que suspende la funci\u00f3n y espera la siguiente llamada al m\u00e9todo <code>next()</code> para continuar.</p> <p>Sintaxis b\u00e1sica:</p> <p>Para definir un generador, utiliza <code>function*</code> en lugar de <code>function</code>. Esto indica a JavaScript que la funci\u00f3n es un generador.</p> javascript<pre><code>function* saludo() {\n    yield \"Hola\";\n    yield \"\u00bfC\u00f3mo est\u00e1s?\";\n    return \"\u00a1Adi\u00f3s!\";\n}\n\nconst generador = saludo();\nconsole.log(generador.next());\nconsole.log(generador.next());\nconsole.log(generador.next());\n</code></pre> <p>La palabra clave <code>yield</code> detiene la ejecuci\u00f3n del generador y devuelve un valor. El m\u00e9todo <code>next()</code> reanuda la ejecuci\u00f3n hasta encontrar el siguiente <code>yield</code> o el final de la funci\u00f3n.</p>"},{"location":"javascript/generadores/#diferencias-entre-funciones-normales-y-generadores","title":"Diferencias entre funciones normales y generadores","text":"<p>Los generadores y las funciones normales comparten la capacidad de encapsular bloques de c\u00f3digo reutilizables, pero su funcionamiento y prop\u00f3sito son distintos. Mientras que una funci\u00f3n normal sigue un flujo lineal y se ejecuta de principio a fin de una sola vez, los generadores permiten un control incremental sobre la ejecuci\u00f3n, ofreciendo pausas y reanudaciones.</p>"},{"location":"javascript/generadores/#funciones-normales","title":"Funciones normales:","text":"<ul> <li>Ejecutan todo su c\u00f3digo de una vez, de principio a fin.</li> <li>Devuelven un solo valor con <code>return</code>.</li> </ul>"},{"location":"javascript/generadores/#generadores_1","title":"Generadores:","text":"<ul> <li>Pueden pausar su ejecuci\u00f3n en cualquier punto usando <code>yield</code>.</li> <li>Devuelven m\u00faltiples valores a medida que se llama a <code>next()</code>.</li> <li>Mantienen su estado entre ejecuciones, recordando variables y contexto.</li> </ul> javascript<pre><code>// Funci\u00f3n normal\nfunction saludoNormal() {\n    return \"Hola\";\n}\n\n// Generador\nfunction* saludoGenerador() {\n    yield \"Hola\";\n    yield \"\u00bfQu\u00e9 tal?\";\n}\n\nconsole.log(saludoNormal()); // \"Hola\"\n\nconst generador = saludoGenerador();\nconsole.log(generador.next().value);\nconsole.log(generador.next().value);\n</code></pre>"},{"location":"javascript/generadores/#aplicaciones-practicas-de-los-generadores","title":"Aplicaciones pr\u00e1cticas de los generadores","text":""},{"location":"javascript/generadores/#generador-de-secuencias-numericas","title":"Generador de secuencias num\u00e9ricas","text":"<p>Los generadores son ideales para manejar secuencias infinitas o series num\u00e9ricas, permitiendo obtener valores solo cuando son necesarios.</p> javascript<pre><code>function* generadorDeNumeros() {\n    let numero = 1;\n    while (true) {\n        yield numero++;\n    }\n}\n\nconst secuencia = generadorDeNumeros();\nconsole.log(secuencia.next().value);\nconsole.log(secuencia.next().value);\nconsole.log(secuencia.next().value);\n</code></pre> <p>Este generador produce una secuencia infinita de n\u00fameros incrementales, \u00fatil para generar identificadores \u00fanicos o manejar series sin l\u00edmite.</p>"},{"location":"javascript/generadores/#ejecucion-condicional-y-controlada","title":"Ejecuci\u00f3n condicional y controlada","text":"<p>Los generadores permiten dividir procesos en pasos controlados, pausando en cada <code>yield</code> y reanudando seg\u00fan sea necesario.</p> javascript<pre><code>function* flujoDeTrabajo() {\n    console.log(\"Iniciando...\");\n    yield \"Paso 1 completo\";\n    console.log(\"En el paso 2...\");\n    yield \"Paso 2 completo\";\n    console.log(\"Finalizando...\");\n    return \"Trabajo terminado\";\n}\n\nconst proceso = flujoDeTrabajo();\n\nconsole.log(proceso.next().value);\nconsole.log(proceso.next().value);\nconsole.log(proceso.next().value);\n</code></pre> <p>En el ejemplo anterior el generador <code>flujoDeTrabajo</code> permite ejecutar el proceso en pasos controlados, pausando en cada <code>yield</code> y reanudando seg\u00fan sea necesario.</p>"},{"location":"javascript/generadores/#delegacion-con-yield","title":"Delegaci\u00f3n con <code>yield</code>*","text":"<p>A veces un generador necesita delegar la iteraci\u00f3n a otro generador o iterable. <code>yield*</code> permite incluir los valores de otro generador o iterable en la secuencia, de manera que el generador principal act\u00fae como intermediario. Esto es \u00fatil para dividir la l\u00f3gica en generadores m\u00e1s peque\u00f1os y combinarlos en uno solo.</p> javascript<pre><code>function* generadorPrincipal() {\n    yield* generadorSecundario();\n    // c\u00f3digo adicional en el generador principal\n}\n</code></pre> <p>Ejemplo de yield* con Generadores Anidados</p> javascript<pre><code>function* generador1() {\n    yield \"Primero\";\n    yield \"Segundo\";\n}\n\nfunction* generador2() {\n    yield \"Inicio Generador 2\";\n    yield* generador1();  // Delegaci\u00f3n al generador1\n    yield \"Fin Generador 2\";\n}\n\nconst iterador = generador2();\n\nconsole.log(iterador.next().value);\nconsole.log(iterador.next().value);\nconsole.log(iterador.next().value);\nconsole.log(iterador.next().value);\n</code></pre> <p>En el anterior codigo vemos que <code>generador2</code> incluye los valores de <code>generador1</code> dentro de su secuencia mediante <code>yield*</code>, permitiendo que ambos generadores act\u00faen como una \u00fanica fuente de valores.</p>"},{"location":"javascript/generadores/#comunicacion-bidireccional-con-nextvalue","title":"Comunicaci\u00f3n bidireccional con <code>next(value)</code>","text":"<p>Adem\u00e1s de avanzar el generador a la siguiente instrucci\u00f3n <code>yield</code>, el m\u00e9todo <code>next()</code> puede recibir un argumento que se pasa como resultado de la \u00faltima instrucci\u00f3n <code>yield</code>. Esto permite enviar informaci\u00f3n al generador durante la iteraci\u00f3n.</p> javascript<pre><code>const iterador = generador();\niterador.next(valor);  // Envia el valor al generador\n</code></pre> <p>Ejemplo de <code>next(value)</code> para Pasar Valores</p> javascript<pre><code>function* calculadora() {\n    const num1 = yield \"Ingresa el primer n\u00famero:\";\n    const num2 = yield \"Ingresa el segundo n\u00famero:\";\n    yield `Resultado: ${num1 + num2}`;\n}\n\nconst iterador = calculadora();\n\nconsole.log(iterador.next().value);\nconsole.log(iterador.next(5).value);\nconsole.log(iterador.next(3).value);\n</code></pre> <p>En el anterior ejemplo <code>next(5)</code> y <code>next(3)</code> env\u00edan los valores <code>5</code> y <code>3</code> al generador <code>calculadora</code>, permitiendo realizar una suma dentro del generador. Esto es \u00fatil para construir flujos en los que el generador depende de datos externos en cada paso.</p>"},{"location":"javascript/generadores/#buenas-practicas-al-usar-generadores","title":"Buenas pr\u00e1cticas al usar generadores","text":"<ol> <li>Maneja grandes secuencias de datos: Los generadores son ideales para flujos de datos continuos o secuencias infinitas.</li> <li>Evita generadores en procesos simples: Para tareas sencillas, las funciones normales son m\u00e1s eficientes.</li> <li>Usa <code>yield*</code> para dividir l\u00f3gica compleja: Mant\u00e9n tu c\u00f3digo modular delegando operaciones a generadores m\u00e1s peque\u00f1os.</li> <li>Aprovecha la comunicaci\u00f3n bidireccional: Usa <code>next(value)</code> para flujos de datos que dependen de la entrada del usuario.</li> </ol>"},{"location":"javascript/generadores/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los generadores en JavaScript son una herramienta poderosa para controlar la ejecuci\u00f3n de funciones de manera pausada y secuencial. Con <code>yield</code> y <code>next()</code>, puedes manejar secuencias de datos grandes, gestionar procesos paso a paso y optimizar el uso de memoria. Comprender c\u00f3mo funcionan y c\u00f3mo aplicarlos te permitir\u00e1 mejorar la eficiencia y flexibilidad de tu c\u00f3digo.</p> <p>En el pr\u00f3ximo art\u00edculo, exploraremos los Iteradores As\u00edncronos, una extensi\u00f3n de los generadores para manejar flujos de datos as\u00edncronos.</p> <p></p>"},{"location":"javascript/hoisting/","title":"Hoisting","text":""},{"location":"javascript/hoisting/#hoisting-entendiendo-la-elevacion-en-el-codigo","title":"Hoisting: Entendiendo la Elevaci\u00f3n en el C\u00f3digo","text":"<p>El hoisting (o elevaci\u00f3n) es un comportamiento en JavaScript que ocurre durante la fase de creaci\u00f3n del contexto de ejecuci\u00f3n. Este mecanismo permite que las declaraciones de variables y funciones sean \u201cmovidas\u201d al inicio de su \u00e1mbito (scope) antes de que se ejecute el c\u00f3digo. Aunque este fen\u00f3meno puede parecer confuso al principio, comprender c\u00f3mo funciona el hoisting es clave para evitar errores y escribir c\u00f3digo m\u00e1s predecible.</p> <p>En este art\u00edculo exploraremos qu\u00e9 es el hoisting, c\u00f3mo afecta las variables y funciones, y c\u00f3mo utilizar este conocimiento para escribir un c\u00f3digo m\u00e1s claro y eficiente.</p>"},{"location":"javascript/hoisting/#que-es-el-hoisting-en-javascript","title":"\u00bfQu\u00e9 es el Hoisting en JavaScript?","text":"<p>Cuando el motor de JavaScript ejecuta tu c\u00f3digo, este pasa por dos fases:</p> <ol> <li>Fase de creaci\u00f3n: Durante esta fase, el motor mueve las declaraciones de variables y funciones al inicio de su \u00e1mbito (scope) en memoria.</li> <li>Fase de ejecuci\u00f3n: El c\u00f3digo se ejecuta l\u00ednea por l\u00ednea, asignando valores a las variables y evaluando expresiones.</li> </ol> <p>Este proceso de mover declaraciones al principio del \u00e1mbito es lo que se conoce como hoisting.</p>"},{"location":"javascript/hoisting/#hoisting-de-variables","title":"Hoisting de Variables","text":"<p>El hoisting de variables depende del tipo de palabra clave utilizada para declararlas: <code>var</code>, <code>let</code> o <code>const</code>.</p>"},{"location":"javascript/hoisting/#variables-declaradas-con-var","title":"Variables declaradas con <code>var</code>","text":"<p>Las variables declaradas con <code>var</code> son elevadas al inicio del \u00e1mbito y se inicializan con el valor <code>undefined</code>. Esto significa que puedes referenciar la variable antes de declararla, aunque su valor ser\u00e1 <code>undefined</code> hasta que se asigne un valor expl\u00edcito.</p> javascript<pre><code>console.log(counter); // undefined\nvar counter = 10;\nconsole.log(counter); // 10\n</code></pre> <p>Durante la fase de creaci\u00f3n, <code>counter</code> es declarada e inicializada con <code>undefined</code>. Durante la fase de ejecuci\u00f3n, se asigna el valor <code>10</code> a <code>counter</code>.</p> <p>C\u00f3digo equivalente:</p> javascript<pre><code>var counter;\nconsole.log(counter); // undefined\ncounter = 10;\nconsole.log(counter); // 10\n</code></pre>"},{"location":"javascript/hoisting/#variables-declaradas-con-let-y-const","title":"Variables declaradas con let y const","text":"<p>Las variables declaradas con <code>let</code> y <code>const</code> tambi\u00e9n son elevadas, pero no se inicializan. Esto significa que si intentas acceder a ellas antes de su declaraci\u00f3n, obtendr\u00e1s un error de referencia.</p> javascript<pre><code>console.log(counter); // ReferenceError: Cannot access 'counter' before initialization\nlet counter = 10;\n</code></pre> <p>Durante la fase de creaci\u00f3n, <code>counter</code> se coloca en memoria, pero no se inicializa. Acceder a <code>counter</code> antes de su declaraci\u00f3n genera un error.</p>"},{"location":"javascript/hoisting/#hoisting-de-funciones","title":"Hoisting de Funciones","text":"<p>El hoisting afecta tanto a las funciones como a las variables, pero funciona de manera diferente dependiendo de c\u00f3mo se declaren las funciones. Es importante entender estos matices para evitar errores y aprovechar al m\u00e1ximo el comportamiento del lenguaje.</p>"},{"location":"javascript/hoisting/#declaraciones-de-funciones","title":"Declaraciones de funciones","text":"<p>Las declaraciones de funciones son completamente elevadas. Esto significa que el motor de JavaScript mueve tanto la declaraci\u00f3n como la definici\u00f3n de la funci\u00f3n al inicio de su \u00e1mbito. Por lo tanto, puedes llamar a una funci\u00f3n antes de declararla en el c\u00f3digo.</p> javascript<pre><code>console.log(sumar(5, 10));\n\nfunction sumar(a, b) {\n    return a + b;\n}\n</code></pre> <p>Durante la fase de creaci\u00f3n, el motor eleva tanto el nombre de la funci\u00f3n como su cuerpo completo al inicio del \u00e1mbito, esto permite que <code>sumar</code> sea accesible antes de que se declare en el c\u00f3digo.</p>"},{"location":"javascript/hoisting/#expresiones-de-funciones-y-funciones-flecha","title":"Expresiones de funciones y funciones flecha","text":"<p>Las expresiones de funciones y las funciones flecha (arrow functions) no son elevadas. Solo se eleva la declaraci\u00f3n de la variable que las contiene, pero no la asignaci\u00f3n de la funci\u00f3n. Por lo tanto, intentar invocar una expresi\u00f3n de funci\u00f3n o una funci\u00f3n flecha antes de su definici\u00f3n genera un error.</p> javascript<pre><code>console.log(multiplicar(5, 2)); // TypeError: multiplicar is not a function\n\nvar multiplicar = function(a, b) {\n    return a * b;\n};\n</code></pre> <p>Explicaci\u00f3n:</p> <ul> <li>Durante la fase de creaci\u00f3n, la variable <code>multiplicar</code> se eleva, pero se inicializa con <code>undefined</code>.</li> <li>Cuando intentas llamar a <code>multiplicar</code> antes de asignarle la funci\u00f3n, JavaScript arroja un error porque no es una funci\u00f3n en ese momento.</li> </ul>"},{"location":"javascript/hoisting/#ejemplo-con-funciones-flecha","title":"Ejemplo con funciones flecha:","text":"javascript<pre><code>console.log(dividir(10, 2)); // ReferenceError: Cannot access 'dividir' before initialization\n\nlet dividir = (a, b) =&gt; a / b;\n</code></pre> <p>Las variables declaradas con <code>let</code> o <code>const</code> no se inicializan durante la fase de creaci\u00f3n, aunque son elevadas. Esto provoca un error de referencia si intentas acceder a <code>dividir</code> antes de su declaraci\u00f3n.</p>"},{"location":"javascript/hoisting/#ejemplo-entendiendo-el-hoisting","title":"Ejemplo: Entendiendo el Hoisting","text":"<p>Para comprender c\u00f3mo funciona el hoisting en la pr\u00e1ctica, veamos un ejemplo que combina el comportamiento de variables y funciones. Este ejemplo ilustrar\u00e1 c\u00f3mo las declaraciones son elevadas al inicio del \u00e1mbito, c\u00f3mo afectan las variables declaradas con <code>var</code>, <code>let</code>, y <code>const</code>, y qu\u00e9 sucede con las diferentes formas de declarar funciones.</p> javascript<pre><code>console.log(x); // undefined\nvar x = 5;\n\nhoistedFunction(); // Funci\u00f3n ejecutada correctamente\n\nfunction hoistedFunction() {\n    console.log(\"Hoisting de funciones\");\n}\n\nnonHoistedFunction(); // Error: nonHoistedFunction is not a function\n\nvar nonHoistedFunction = function() {\n    console.log(\"Esto no es hoisted\");\n};\n</code></pre> <p>Explicaci\u00f3n del ejemplo:</p> <ol> <li><code>x</code> es elevado e inicializado como <code>undefined</code>.</li> <li>La funci\u00f3n <code>hoistedFunction</code> es elevada y completamente accesible.</li> <li>La variable <code>nonHoistedFunction</code> es elevada, pero su valor (la funci\u00f3n) no se asigna hasta la fase de ejecuci\u00f3n.</li> </ol>"},{"location":"javascript/hoisting/#buenas-practicas-para-evitar-problemas-con-el-hoisting","title":"Buenas pr\u00e1cticas para evitar problemas con el Hoisting","text":"<ol> <li>Usa <code>let</code> y <code>const</code> en lugar de <code>var</code>: Estas palabras clave hacen que el comportamiento sea m\u00e1s predecible y evitan inicializaciones accidentales.</li> <li>Declara funciones antes de usarlas: Aunque las declaraciones de funciones son elevadas, es mejor organizarlas en un orden l\u00f3gico.</li> <li>Entiende el \u00e1mbito de las variables: Aseg\u00farate de comprender el \u00e1mbito (global o de bloque) donde se declaran tus variables.</li> </ol>"},{"location":"javascript/hoisting/#conclusion","title":"Conclusi\u00f3n","text":"<p>El hoisting es una caracter\u00edstica poderosa de JavaScript que puede causar confusi\u00f3n si no se entiende completamente. Saber c\u00f3mo funciona con variables (<code>var</code>, <code>let</code>, <code>const</code>) y funciones (declaraciones y expresiones) es fundamental para escribir c\u00f3digo m\u00e1s claro y predecible. Siguiendo las buenas pr\u00e1cticas, puedes evitar errores comunes y aprovechar esta funcionalidad para estructurar mejor tu programa.</p> <p>En el pr\u00f3ximo art\u00edculo exploraremos c\u00f3mo el \u00e1mbito de las variables influye en el comportamiento del c\u00f3digo y su relaci\u00f3n con el hoisting.</p> <p></p>"},{"location":"javascript/importacion-modulos/","title":"Importaci\u00f3n","text":""},{"location":"javascript/importacion-modulos/#importacion","title":"Importaci\u00f3n","text":"<p>La importaci\u00f3n en JavaScript permite que un m\u00f3dulo use funciones, variables o clases de otro m\u00f3dulo, proporcionando una forma clara de reutilizar y organizar el c\u00f3digo. Al importar elementos de otros m\u00f3dulos, se mantiene una estructura modular donde cada archivo cumple una funci\u00f3n espec\u00edfica dentro del proyecto.</p> <p>Existen varios tipos de importaciones que permiten incorporar elementos de un m\u00f3dulo en otro de manera flexible y precisa. Dependiendo de las necesidades del proyecto, se puede optar por:</p> <ul> <li>Importaciones nombradas</li> <li>Importaciones por defecto</li> <li>Importaciones con alias</li> <li>Importar el m\u00f3dulo completo</li> </ul> <p>Cada tipo de importaci\u00f3n tiene ventajas y casos de uso espec\u00edficos que ayudan a mantener el c\u00f3digo modular y organizado. As\u00ed que veamos como funciona cada una.</p>"},{"location":"javascript/importacion-modulos/#importacion-nombrada","title":"Importaci\u00f3n nombrada","text":"<p>La importaci\u00f3n nombrada permite importar uno o varios elementos espec\u00edficos de un m\u00f3dulo. Es ideal para acceder a m\u00faltiples exportaciones de un archivo.</p> <p>Para facilitar la comprensi\u00f3n, imaginemos una estructura de proyecto que ilustre c\u00f3mo funcionan las importaciones:</p> estructura<pre><code>proyecto/\n\u251c\u2500\u2500 index.html\n\u2514\u2500\u2500 js/\n    \u251c\u2500\u2500 app.js         # Archivo principal donde se importan los m\u00f3dulos\n    \u251c\u2500\u2500 matematicas.js # M\u00f3dulo que exporta funciones matem\u00e1ticas\n    \u2514\u2500\u2500 saludo.js      # M\u00f3dulo que exporta una funci\u00f3n de saludo por defecto\n</code></pre> <p>Ejemplo de Importaci\u00f3n Nombrada</p> <p>Supongamos que tenemos un m\u00f3dulo <code>matematicas.js</code> que exporta dos funciones: <code>calcularArea</code> y <code>calcularCircunferencia</code>:</p> javascript<pre><code>export function calcularArea(radio) {\n    return Math.PI * radio * radio;\n}\n\nexport function calcularCircunferencia(radio) {\n    return 2 * Math.PI * radio;\n}\n</code></pre> <p>En el archivo <code>app.js</code>, se pueden importar ambas funciones usando la sintaxis de importaci\u00f3n nombrada:</p> javascript<pre><code>// app.js\nimport { calcularArea, calcularCircunferencia } from './matematicas.js';\n\nconst area = calcularArea(5); // 78.54\nconst circunferencia = calcularCircunferencia(5); // 31.42\n\ndocument.body.innerHTML = `\n    &lt;p&gt;\u00c1rea: ${area}&lt;/p&gt;\n    &lt;p&gt;Circunferencia: ${circunferencia}&lt;/p&gt;\n`;\n</code></pre> <p>Esta sintaxis importa <code>calcularArea</code> y <code>calcularCircunferencia</code> directamente en <code>app.js</code>, haci\u00e9ndolas disponibles para su uso en el c\u00f3digo.</p>"},{"location":"javascript/importacion-modulos/#importacion-por-defecto","title":"Importaci\u00f3n por Defecto","text":"<p>Se usa cuando un m\u00f3dulo tiene un elemento principal que encapsula su funcionalidad. Este tipo de importaci\u00f3n no requiere llaves {} y permite asignar cualquier nombre al importar.</p> <p>Ejemplo de Importaci\u00f3n por Defecto</p> <p>En el m\u00f3dulo <code>saludo.js</code>, exportamos una funci\u00f3n <code>saludar</code> como exportaci\u00f3n por defecto:</p> javascript<pre><code>// saludo.js\nexport default function saludar(nombre) {\n    return `Hola, ${nombre}!`;\n}\n</code></pre> <p>Para importar <code>saludar</code> en <code>app.js</code>, no necesitamos llaves <code>{ }</code>:</p> javascript<pre><code>// app.js\nimport saludar from './saludo.js';\n\nconst mensaje = saludar(\"Carlos\"); // Hola, Carlos!\ndocument.body.innerHTML = `&lt;p&gt;${mensaje}&lt;/p&gt;`;\n</code></pre> <p>Esta simplicidad en la importaci\u00f3n es una de las ventajas de las exportaciones por defecto.</p>"},{"location":"javascript/importacion-modulos/#importacion-con-alias","title":"Importaci\u00f3n con Alias","text":"<p>El alias es \u00fatil para evitar conflictos de nombres cuando se importan elementos de varios m\u00f3dulos con nombres similares.</p> <p>Ejemplo de Importaci\u00f3n con Alias</p> <p>En el siguiente ejemplo, renombramos <code>calcularArea</code> como <code>area</code> y <code>calcularCircunferencia</code> como <code>circunferencia</code> al importarlos en <code>app.js</code>:</p> javascript<pre><code>// app.js\nimport { calcularArea as area, calcularCircunferencia as circunferencia } from './matematicas.js';\n\nconst resultadoArea = area(5);\nconst resultadoCircunferencia = circunferencia(5);\n\ndocument.body.innerHTML = `\n    &lt;p&gt;\u00c1rea (Alias): ${resultadoArea}&lt;/p&gt;\n    &lt;p&gt;Circunferencia (Alias): ${resultadoCircunferencia}&lt;/p&gt;\n`;\n</code></pre> <p>El uso de alias es especialmente \u00fatil cuando se importa c\u00f3digo desde m\u00faltiples m\u00f3dulos que pueden tener nombres de funciones o variables similares.</p>"},{"location":"javascript/importacion-modulos/#importacion-agrupada","title":"Importaci\u00f3n Agrupada","text":"<p>La importaci\u00f3n agrupada permite combinar varias importaciones de un m\u00f3dulo en una sola declaraci\u00f3n, lo cual es \u00fatil para mejorar la organizaci\u00f3n del c\u00f3digo en archivos que dependen de m\u00faltiples exportaciones.</p> javascript<pre><code>// matematicas.js\n\nexport const PI = 3.14159;\n\nexport function calcularArea(radio) {\n    return PI * radio * radio;\n}\n\nexport function calcularCircunferencia(radio) {\n    return 2 * PI * radio;\n}\n</code></pre> <p>y en el archivo de importaciones lo hacemos de la siguiente forma:</p> javascript<pre><code>// app.js\nimport * as matematicas from './matematicas.js';\n\nconst area = matematicas.calcularArea(5);\nconst circunferencia = matematicas.calcularCircunferencia(5);\n\ndocument.body.innerHTML = `\n    &lt;p&gt;PI: ${matematicas.PI}&lt;/p&gt;\n    &lt;p&gt;\u00c1rea: ${area}&lt;/p&gt;\n    &lt;p&gt;Circunferencia: ${circunferencia}&lt;/p&gt;\n`;\n</code></pre> <p>Esta importaci\u00f3n agrupada facilita el manejo de m\u00f3dulos con muchas exportaciones.</p>"},{"location":"javascript/importacion-modulos/#importacion-de-todo-el-modulo","title":"Importaci\u00f3n de Todo el M\u00f3dulo","text":"<p>La importaci\u00f3n de todo el m\u00f3dulo con <code>* as</code> permite acceder a todas las exportaciones de un m\u00f3dulo como propiedades de un solo objeto. Esto es \u00fatil cuando se necesita importar m\u00faltiples funciones y constantes bajo un mismo nombre.</p> <p>Ejemplo de Importaci\u00f3n de Todo el M\u00f3dulo</p> javascript<pre><code>export const PI = 3.14159;\n\nexport function calcularArea(radio) {\n    return PI * radio * radio;\n}\n\nexport function calcularCircunferencia(radio) {\n    return 2 * PI * radio;\n}\n</code></pre> <p>Importacion:</p> javascript<pre><code>import * as matematicas from './matematicas.js';\n\nconsole.log(matematicas.PI);                // Output: 3.14159\nconsole.log(matematicas.calcularArea(5));    // Output: 78.53975\nconsole.log(matematicas.calcularCircunferencia(5)); // Output: 31.4159\n</code></pre> <p>En el anterior ejemplo todas las exportaciones de <code>matematicas.js</code> est\u00e1n accesibles como propiedades de <code>matematicas</code>, lo cual es conveniente para acceder a m\u00faltiples funciones o variables desde un solo m\u00f3dulo.</p>"},{"location":"javascript/importacion-modulos/#buenas-practicas-al-importar-en-javascript","title":"Buenas pr\u00e1cticas al importar en JavaScript","text":"<p>Es importante mantener ciertas buenas pr\u00e1cticas al importar en JavaScript</p> <ol> <li>Usa alias para evitar conflictos de nombres: Si importas funciones con nombres similares de diferentes m\u00f3dulos, utiliza alias para mantener la claridad.</li> <li>Evita importar todo el m\u00f3dulo innecesariamente: Importar el m\u00f3dulo completo (<code>import * as ...</code>) puede ser excesivo si solo necesitas unas pocas funciones. Esto mejora el rendimiento y la claridad.</li> <li>Agrupa las importaciones relacionadas: Mant\u00e9n juntas las importaciones de un mismo m\u00f3dulo para mejorar la organizaci\u00f3n.</li> <li>Evita dependencias circulares: Dise\u00f1a tus m\u00f3dulos para que no dependan unos de otros de manera recursiva, ya que esto puede causar errores dif\u00edciles de depurar.</li> </ol>"},{"location":"javascript/importacion-modulos/#conclusion","title":"Conclusi\u00f3n","text":"<p>La importaci\u00f3n en JavaScript es esencial para construir aplicaciones modulares y bien estructuradas. Al comprender las diferentes formas de importar y aplicar buenas pr\u00e1cticas, puedes mantener un c\u00f3digo m\u00e1s limpio, eficiente y escalable. En el pr\u00f3ximo art\u00edculo, profundizaremos en la Reexportaci\u00f3n de M\u00f3dulos, que simplifica la organizaci\u00f3n en proyectos complejos.</p> <p></p>"},{"location":"javascript/iteradores-asincronos/","title":"Iteradores As\u00edncronos","text":""},{"location":"javascript/iteradores-asincronos/#iteradores-asincronos","title":"Iteradores As\u00edncronos","text":"<p>Con el auge de aplicaciones que manejan datos en tiempo real y operaciones as\u00edncronas como la consulta a APIs o la lectura de streams, los iteradores as\u00edncronos se han vuelto una herramienta fundamental en JavaScript. Estos iteradores permiten manejar secuencias de datos que no est\u00e1n disponibles de inmediato, de una manera controlada y eficiente.</p> <p>En este art\u00edculo exploraremos qu\u00e9 son los iteradores as\u00edncronos, c\u00f3mo funcionan, sus casos de uso, adem\u00e1s de pr\u00e1cticas para utilizarlos en proyectos modernos.</p>"},{"location":"javascript/iteradores-asincronos/#que-es-un-iterador-asincrono","title":"\u00bfQu\u00e9 es un iterador as\u00edncrono?","text":"<p>Un iterador as\u00edncrono es un objeto que sigue el protocolo de iteraci\u00f3n as\u00edncrona, devolviendo una secuencia de promesas en lugar de valores inmediatos. Cada llamada al m\u00e9todo <code>next()</code> devuelve una promesa que se resuelve cuando el valor est\u00e1 disponible, lo que permite manejar datos que llegan de forma intermitente o tard\u00eda.</p> <p>Ejemplo b\u00e1sico:</p> <p>Para crear un iterador as\u00edncrono, debes implementar el m\u00e9todo <code>Symbol.asyncIterator</code>. Este m\u00e9todo devuelve un objeto que contiene un m\u00e9todo <code>next()</code> que devuelve una promesa.</p> javascript<pre><code>const objetoAsincrono = {\n    [Symbol.asyncIterator]() {\n        let i = 0;\n        return {\n            next() {\n                if (i &lt; 5) {\n                    return new Promise(resolve =&gt; {\n                        setTimeout(() =&gt; resolve({ value: i++, done: false }), 1000);\n                    });\n                } else {\n                    return Promise.resolve({ done: true });\n                }\n            }\n        };\n    }\n};\n</code></pre> <p>En este ejemplo: Una vez completados los valores, devuelve <code>{ done: true }</code>. El iterador simula una secuencia de datos donde cada valor se produce despu\u00e9s de un segundo.</p>"},{"location":"javascript/iteradores-asincronos/#iteracion-asincrona-con-for-awaitof","title":"Iteraci\u00f3n as\u00edncrona con for await\u2026of","text":"<p>JavaScript introdujo el bucle <code>for await...of</code> para iterar sobre objetos as\u00edncronos de forma secuencial. Este bucle espera a que cada promesa en la secuencia se resuelva antes de proceder al siguiente valor.</p> javascript<pre><code>async function procesarDatos() {\n    for await (const valor of objetoAsincrono) {\n        console.log(valor);\n    }\n}\n\nprocesarDatos();\n</code></pre> <p>En este ejemplo, <code>for await...of</code> espera que cada <code>next()</code> devuelva un valor antes de continuar, lo que permite manejar datos asincr\u00f3nicos de forma secuencial sin necesidad de m\u00faltiples promesas encadenadas.</p>"},{"location":"javascript/iteradores-asincronos/#casos-de-uso-de-iteradores-asincronos","title":"Casos de uso de iteradores as\u00edncronos","text":"<p>Los iteradores as\u00edncronos son ideales en situaciones donde los datos no est\u00e1n disponibles inmediatamente o se reciben de forma fragmentada:</p> <ol> <li>Lectura de streams de datos: Procesar archivos grandes o streams de red en fragmentos a medida que llegan.</li> <li>Consulta de APIs paginadas: Iterar sobre resultados de una API que devuelve datos en lotes.</li> <li>Monitoreo de eventos en tiempo real: Procesar entradas continuas, como datos de sensores o mensajes de chat.</li> </ol> <p>Ejemplo: Iteraci\u00f3n sobre una Fuente de Datos Remota</p> <p>Imaginemos que estamos solicitando datos a una API que devuelve resultados en lotes. Usar un iterador as\u00edncrono nos permite procesar cada lote tan pronto como est\u00e9 disponible.</p> javascript<pre><code>async function* obtenerDatosPorPagina() {\n    let pagina = 1;\n    while (true) {\n        const respuesta = await fetch(`https://api.example.com/data?page=${pagina}`);\n        const datos = await respuesta.json();\n        if (datos.length === 0) break;\n        yield datos;\n        pagina++;\n    }\n}\n\nasync function procesarDatos() {\n    for await (const datos of obtenerDatosPorPagina()) {\n        return datos;\n    }\n}\n\nprocesarDatos();\n</code></pre> <p>En el ejemplo anterior <code>obtenerDatosPorPagina</code> es un generador as\u00edncrono que obtiene y devuelve lotes de datos de la API. Con <code>for await...of</code>, podemos procesar cada lote sin esperar que se complete toda la descarga.</p>"},{"location":"javascript/iteradores-asincronos/#implementacion-de-iteradores-asincronos-personalizados","title":"Implementaci\u00f3n de iteradores as\u00edncronos personalizados","text":"<p>Podemos implementar iteradores as\u00edncronos personalizados en nuestros propios objetos, lo hacemos usando <code>Symbol.asyncIterator</code>. Esto permite crear estructuras de datos que solo proporcionan un valor cuando est\u00e1 disponible.</p> <p>Ejemplo de un Iterador As\u00edncrono Personalizado</p> javascript<pre><code>const generadorAsincrono = {\n    [Symbol.asyncIterator]() {\n        let contador = 1;\n        return {\n            async next() {\n                if (contador &lt;= 5) {\n                    await new Promise(resolve =&gt; setTimeout(resolve, 1000));\n                    return { value: contador++, done: false };\n                } else {\n                    return { done: true };\n                }\n            }\n        };\n    }\n};\n\nasync function ejecutarIterador() {\n    for await (const valor of generadorAsincrono) {\n        return valor;\n    }\n}\n\nejecutarIterador();\n</code></pre> <p>En este caso, <code>generadorAsincrono</code> es un iterador que produce valores cada segundo. El bucle <code>for await...of</code> permite iterar sobre esos valores en orden, esperando cada uno hasta que est\u00e9 disponible.</p>"},{"location":"javascript/iteradores-asincronos/#buenas-practicas-al-usar-iteradores-asincronos","title":"Buenas pr\u00e1cticas al usar iteradores as\u00edncronos","text":"<ol> <li>Controla el flujo con <code>for await...of</code>: Este bucle es la forma m\u00e1s limpia y legible de manejar iteradores as\u00edncronos.</li> <li>Evita iteradores infinitos sin control: Si tu iterador as\u00edncrono no tiene un l\u00edmite claro, implementa un mecanismo de cancelaci\u00f3n para evitar consumir recursos innecesarios.</li> <li>Usa <code>try...catch</code> para manejar errores: Los iteradores as\u00edncronos pueden fallar debido a problemas de red o datos, por lo que es importante manejar los errores adecuadamente.</li> </ol>"},{"location":"javascript/iteradores-asincronos/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los iteradores as\u00edncronos son una herramienta poderosa para manejar flujos de datos que no est\u00e1n disponibles de inmediato. Ya sea para procesar streams, consultar APIs paginadas o monitorear eventos en tiempo real, los iteradores as\u00edncronos ofrecen una soluci\u00f3n eficiente y estructurada para manejar datos as\u00edncronos en JavaScript.</p> <p>En el pr\u00f3ximo art\u00edculo, exploraremos los Generadores As\u00edncronos, una extensi\u00f3n que combina la flexibilidad de los generadores con el poder de la asincron\u00eda.</p> <p></p>"},{"location":"javascript/iteradores/","title":"Introducci\u00f3n a los Iteradores","text":""},{"location":"javascript/iteradores/#introduccion-a-los-iteradores","title":"Introducci\u00f3n a los Iteradores","text":"<p>Los iteradores en JavaScript proporcionan una manera eficiente y controlada de recorrer secuencias de datos. A trav\u00e9s del protocolo de iteraci\u00f3n, los iteradores permiten acceder secuencialmente a los elementos de una colecci\u00f3n sin la necesidad de usar bucles tradicionales como <code>for</code> o <code>while</code>.</p> <p>En este art\u00edculo exploraremos los conceptos b\u00e1sicos de los iteradores, c\u00f3mo se implementan y sus casos de uso m\u00e1s comunes.</p>"},{"location":"javascript/iteradores/#que-es-un-iterador","title":"\u00bfQu\u00e9 es un iterador?","text":"<p>Un iterador es un objeto que permite recorrer una secuencia de datos mediante el m\u00e9todo <code>next()</code>. Cada vez que se llama a este m\u00e9todo, se devuelve un objeto con dos propiedades:</p> <ul> <li><code>value</code>: el valor actual en la secuencia.</li> <li><code>done</code>: un booleano que indica si la secuencia ha terminado (<code>true</code> si ha terminado, <code>false</code> en caso contrario).</li> </ul> <p>Ejemplo b\u00e1sico de un iterador:</p> javascript<pre><code>function crearIterador(array) {\n    let indice = 0;\n    return {\n        next: function () {\n            if (indice &lt; array.length) {\n                return { value: array[indice++], done: false };\n            } else {\n                return { done: true };\n            }\n        }\n    };\n}\n\nconst iterador = crearIterador([1, 2, 3]);\n\nconsole.log(iterador.next());\nconsole.log(iterador.next());\nconsole.log(iterador.next());\nconsole.log(iterador.next());\n</code></pre> <p>En el ejemplo anterior <code>crearIterador</code> devuelve un objeto iterador para recorrer un array. Cada llamada a <code>next()</code> avanza al siguiente elemento en la secuencia.</p>"},{"location":"javascript/iteradores/#protocolos-de-iteracion-en-javascript","title":"Protocolos de iteraci\u00f3n en JavaScript","text":"<p>JavaScript define dos protocolos de iteraci\u00f3n esenciales que los objetos deben seguir para ser considerados iterables y usarse en bucles como <code>for...of</code>.</p>"},{"location":"javascript/iteradores/#1-protocolo-de-iterador","title":"1. Protocolo de Iterador","text":"<p>Un objeto es un iterador si implementa un m\u00e9todo <code>next()</code>, el cual devuelve un objeto con las propiedades <code>value</code> y <code>done</code>. Este protocolo define c\u00f3mo deben comportarse los iteradores.</p> javascript<pre><code>const iterador = {\n    current: 1,\n    last: 5,\n    next() {\n        if (this.current &lt;= this.last) {\n            return { value: this.current++, done: false };\n        } else {\n            return { done: true };\n        }\n    }\n};\n\nconsole.log(iterador.next());\nconsole.log(iterador.next());\n</code></pre> <p>El iterador devuelve n\u00fameros desde <code>current</code> hasta <code>last</code>. Cuando se alcanza el \u00faltimo n\u00famero, <code>done</code> pasa a ser <code>true</code>.</p>"},{"location":"javascript/iteradores/#2-protocolo-de-iterable","title":"2. Protocolo de Iterable","text":"<p>Un objeto es iterable si implementa el m\u00e9todo <code>Symbol.iterator</code>, que devuelve un iterador. Esto permite que el objeto sea recorrido mediante estructuras como <code>for...of</code> o el operador de propagaci\u00f3n.</p> javascript<pre><code>const objetoIterable = {\n    [Symbol.iterator]() {\n        let paso = 0;\n        return {\n            next() {\n                paso++;\n                return paso &lt;= 3 ? { value: paso, done: false } : { done: true };\n            }\n        };\n    }\n};\n\nfor (const valor of objetoIterable) {\n    console.log(valor); \n}\n</code></pre> <p>El m\u00e9todo <code>Symbol.iterator</code> define c\u00f3mo se generan los valores al recorrer el objeto. Se utiliza <code>for...of</code> para iterar de forma sencilla.</p>"},{"location":"javascript/iteradores/#por-que-usar-iteradores-en-javascript","title":"\u00bfPor qu\u00e9 usar iteradores en JavaScript?","text":"<p>Los iteradores ofrecen una serie de ventajas al permitir un control completo sobre el proceso de iteraci\u00f3n. Aqu\u00ed hay algunas razones para utilizarlos:</p> <ol> <li>Control secuencial: Permiten recorrer elementos en un orden espec\u00edfico, ideal para secuencias personalizadas.</li> <li>Iteraci\u00f3n personalizada: Los desarrolladores pueden definir exactamente c\u00f3mo y cu\u00e1ndo avanzar en una colecci\u00f3n.</li> <li>Legibilidad: Mejoran la claridad del c\u00f3digo, especialmente en estructuras complejas.</li> </ol>"},{"location":"javascript/iteradores/#creacion-de-iteradores-personalizados","title":"Creaci\u00f3n de Iteradores Personalizados","text":"<p>Podemos crear iteradores personalizados implementando el protocolo de iterador con el m\u00e9todo <code>next()</code>. Este enfoque es ideal para recorrer secuencias o estructuras de datos que no son inherentemente iterables, como objetos personalizados.</p> <p>Ejemplo de un Iterador Personalizado con un Rango de N\u00fameros</p> javascript<pre><code>const rango = {\n    inicio: 1,\n    fin: 5,\n    [Symbol.iterator]() {\n        let actual = this.inicio;\n        let fin = this.fin;\n        return {\n            next() {\n                return actual &lt;= fin\n                    ? { value: actual++, done: false }\n                    : { done: true };\n            }\n        };\n    }\n};\n\nfor (const numero of rango) {\n    console.log(numero);\n}\n</code></pre> <p>En este caso <code>rango</code> es un objeto que genera n\u00fameros entre <code>inicio</code> y <code>fin</code>. La implementaci\u00f3n de <code>Symbol.iterator</code> permite usar <code>for...of</code> para iterar f\u00e1cilmente sobre el rango.</p>"},{"location":"javascript/iteradores/#limpieza-de-recursos-con-el-metodo-return","title":"Limpieza de recursos con el m\u00e9todo return","text":"<p>El m\u00e9todo <code>return()</code> en el iterador permite liberar recursos o ejecutar l\u00f3gica cuando se detiene la iteraci\u00f3n antes de completar la secuencia. Este m\u00e9todo se invoca autom\u00e1ticamente si el bucle <code>for...of</code> finaliza prematuramente.</p> javascript<pre><code>const iterableConReturn = {\n    [Symbol.iterator]() {\n        let index = 0;\n        return {\n            next() {\n                if (index &lt; 3) {\n                    return { value: index++, done: false };\n                } else {\n                    return { done: true };\n                }\n            },\n            return() {\n                console.log(\"Iteraci\u00f3n detenida, liberando recursos.\");\n                return { done: true };\n            }\n        };\n    }\n};\n\nfor (const valor of iterableConReturn) {\n    if (valor &gt; 1) break;\n    console.log(valor);\n}\n</code></pre> <p>En el c\u00f3digo anterior el m\u00e9todo <code>return()</code> permite ejecutar una limpieza cuando se interrumpe la iteraci\u00f3n.</p>"},{"location":"javascript/iteradores/#buenas-practicas-con-iteradores","title":"Buenas Pr\u00e1cticas con Iteradores","text":"<ul> <li>Usa <code>Symbol.iterator</code> para definir secuencias personalizadas: Implementa este m\u00e9todo solo cuando necesitas un control avanzado sobre la iteraci\u00f3n.</li> <li>Evita iteradores complejos sin necesidad: Utiliza iteradores personalizados \u00fanicamente cuando no puedas resolver el problema con estructuras nativas como arrays o maps.</li> <li>Utiliza <code>return</code> para liberar recursos: Si la iteraci\u00f3n puede detenerse antes de completarse, implementa el m\u00e9todo <code>return()</code> para evitar problemas de memoria.</li> </ul>"},{"location":"javascript/iteradores/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los iteradores son una herramienta poderosa para manejar secuencias de datos en JavaScript. Al dominar los protocolos de iteraci\u00f3n y el uso de <code>Symbol.iterator</code>, puedes crear iteradores personalizados y optimizar la manera en que interact\u00faas con estructuras de datos complejas.</p> <p>En el pr\u00f3ximo art\u00edculo profundizaremos en el concepto de Iterables y el uso de for\u2026of para iterar eficientemente sobre diferentes tipos de datos en JavaScript.</p> <p></p>"},{"location":"javascript/manejo-de-errores-async-await/","title":"Manejo de Errores con Async/Await","text":""},{"location":"javascript/manejo-de-errores-async-await/#manejo-de-errores-con-asyncawait","title":"Manejo de Errores con Async/Await","text":"<p>El uso de async y await ha hecho que trabajar con c\u00f3digo as\u00edncrono sea m\u00e1s claro y legible. Sin embargo, para garantizar la robustez de tus aplicaciones, es fundamental implementar un manejo de errores adecuado. Esto incluye capturar excepciones, validar respuestas y liberar recursos correctamente, incluso cuando ocurren fallos.</p> <p>En este art\u00edculo exploraremos c\u00f3mo manejar errores con <code>try/catch</code>, c\u00f3mo utilizar <code>finally</code> para limpiar recursos y c\u00f3mo implementar buenas pr\u00e1cticas para mantener tu c\u00f3digo seguro y f\u00e1cil de depurar.</p>"},{"location":"javascript/manejo-de-errores-async-await/#captura-de-errores-con-trycatch","title":"Captura de errores con try/catch","text":"<p>Cuando trabajas con <code>async/await</code>, los errores en las operaciones as\u00edncronas pueden ser capturados directamente en un bloque <code>try/catch</code>. Esto simplifica el manejo de errores al centralizarlos en una sola secci\u00f3n, en lugar de depender de m\u00faltiples <code>.catch()</code>.</p> <p>Ejemplo b\u00e1sico:</p> javascript<pre><code>async function obtenerDatos() {\n    try {\n        const respuesta = await fetch('https://api.example.com/datos');\n        if (!respuesta.ok) throw new Error(\"Error en la solicitud\");\n\n        const datos = await respuesta.json();\n        return datos;\n    } catch (error) {\n        return { error: error.message };\n    }\n}\n</code></pre> <p>Si ocurre un error en la solicitud HTTP o al procesar los datos, el bloque <code>catch</code> lo captura. El error se devuelve como parte del flujo, en lugar de detener el programa.</p>"},{"location":"javascript/manejo-de-errores-async-await/#validacion-y-manejo-de-errores-condicionales","title":"Validaci\u00f3n y manejo de errores condicionales","text":"<p>Es com\u00fan agregar validaciones espec\u00edficas para asegurar que los datos obtenidos sean correctos antes de continuar. Esto permite manejar errores espec\u00edficos de manera m\u00e1s controlada.</p> <p>Ejemplo: Validaci\u00f3n de Respuesta</p> javascript<pre><code>async function obtenerUsuario(id) {\n    try {\n        const respuesta = await fetch(`https://api.example.com/usuario/${id}`);\n        if (!respuesta.ok) throw new Error(\"Usuario no encontrado\");\n\n        const usuario = await respuesta.json();\n        return usuario;\n    } catch (error) {\n        return { error: error.message };\n    }\n}\n</code></pre> <p>Aqu\u00ed se valida que la respuesta HTTP sea satisfactoria (<code>ok === true</code>). Si no lo es, se lanza un error personalizado para indicar que el usuario no fue encontrado.</p>"},{"location":"javascript/manejo-de-errores-async-await/#ejecucion-final-con-finally","title":"Ejecuci\u00f3n final con finally","text":"<p>El bloque <code>finally</code> se ejecuta despu\u00e9s de <code>try/catch</code>, independientemente de si hubo un error o no. Es \u00fatil para liberar recursos, cerrar conexiones o ejecutar acciones finales.</p> javascript<pre><code>async function procesarArchivo() {\n    try {\n        const archivo = await abrirArchivo('archivo.txt');\n        return archivo;\n    } catch (error) {\n        return { error: error.message };\n    } finally {\n        cerrarArchivo();\n    }\n}\n</code></pre> <p>En este caso, el bloque <code>finally</code> asegura que el archivo se cierre, independientemente de si la operaci\u00f3n fue exitosa o fallida.</p>"},{"location":"javascript/manejo-de-errores-async-await/#manejo-de-errores-en-operaciones-paralelas","title":"Manejo de errores en operaciones paralelas","text":"<p>Cuando trabajas con m\u00faltiples promesas en paralelo usando <code>Promise.all</code>, es importante manejar los errores para que una falla no interrumpa todo el flujo.</p> <p>Ejemplo de Manejo de Errores en Promesas Paralelas</p> javascript<pre><code>async function obtenerDatosParalelo() {\n    try {\n        const [usuario, pedidos] = await Promise.all([\n        fetch('https://api.example.com/usuario/1').then(res =&gt; res.json()),\n        fetch('https://api.example.com/pedidos/1').then(res =&gt; res.json())\n        ]);\n\n        return { usuario, pedidos };\n    } catch (error) {\n        return { error: error.message };\n    }\n}\n</code></pre> <p>En este ejemplo, si alguna de las promesas falla, el bloque <code>catch</code> captura el error y permite manejarlo sin interrumpir todo el programa.</p>"},{"location":"javascript/manejo-de-errores-async-await/#buenas-practicas-en-el-manejo-de-errores-con-asyncawait","title":"Buenas pr\u00e1cticas en el manejo de errores con async/await","text":"<p>Implementar buenas pr\u00e1cticas en el manejo de errores con <code>async/await</code> ayuda a mantener el c\u00f3digo m\u00e1s seguro y f\u00e1cil de depurar.</p> <ol> <li>Centraliza la captura de errores: Usa funciones auxiliares para encapsular bloques try/catch, evitando repetir l\u00f3gica de manejo de errores.</li> </ol> javascript<pre><code>async function manejarErrores(funcion) {\n    try {\n        return await funcion();\n    } catch (error) {\n        return { error: error.message };\n    }\n}\n</code></pre> <ol> <li> <p>Valida cada paso: Agrega verificaciones condicionales en puntos cr\u00edticos para capturar errores espec\u00edficos y mejorar la comprensi\u00f3n del flujo.</p> </li> <li> <p>Usa <code>finally</code> para liberar recursos: Aseg\u00farate de que recursos como archivos, conexiones de red o memoria sean liberados sin importar el resultado de la operaci\u00f3n.</p> </li> <li> <p>Maneja errores de operaciones paralelas: Asegura que los errores en operaciones concurrentes no afecten el flujo general.</p> </li> </ol>"},{"location":"javascript/manejo-de-errores-async-await/#conclusion","title":"Conclusi\u00f3n","text":"<p>El manejo adecuado de errores en funciones as\u00edncronas es esencial para escribir aplicaciones confiables y robustas. Al usar bloques <code>try/catch</code>, implementar validaciones condicionales y aprovechar <code>finally</code> para liberar recursos, puedes reducir la probabilidad de fallos inesperados y mejorar la legibilidad del c\u00f3digo. Con estas pr\u00e1cticas, estar\u00e1s mejor preparado para enfrentar los desaf\u00edos de la programaci\u00f3n as\u00edncrona en JavaScript.</p> <p></p>"},{"location":"javascript/manejo-errores-en-promesas/","title":"Manejo de Errores en Promesas","text":""},{"location":"javascript/manejo-errores-en-promesas/#manejo-de-errores-en-promesas","title":"Manejo de Errores en Promesas","text":"<p>Trabajar con promesas en JavaScript permite manejar operaciones as\u00edncronas de manera fluida, pero es fundamental capturar y gestionar adecuadamente los errores para evitar comportamientos inesperados y hacer el c\u00f3digo m\u00e1s seguro.</p> <p>En este art\u00edculo veremos c\u00f3mo manejar errores en promesas usando <code>catch</code>, <code>finally</code> y algunos patrones recomendados para lograr un flujo de trabajo confiable.</p>"},{"location":"javascript/manejo-errores-en-promesas/#captura-basica-de-errores-con-catch","title":"Captura B\u00e1sica de Errores con catch()","text":"<p>El m\u00e9todo <code>catch()</code> es el enfoque m\u00e1s directo para gestionar errores en promesas. Cuando una promesa falla (es rechazada) el flujo se redirige al bloque <code>catch()</code>, donde podemos capturar el error y tomar medidas adecuadas, como mostrar un mensaje de error o registrar el problema para futuras referencias.</p> <p>Ejemplo de Captura de Errores con catch()</p> javascript<pre><code>const promesaFallida = new Promise((resolve, reject) =&gt; {\n    const exito = false;\n\n    if (exito) {\n        resolve(\"Operaci\u00f3n exitosa\");\n    } else {\n        reject(\"Ocurri\u00f3 un error\");\n    }\n});\n\npromesaFallida\n    .then(resultado =&gt; console.log(\"Resultado:\", resultado))\n    .catch(error =&gt; console.log(\"Error capturado:\", error));\n</code></pre> <p>En este caso, como la promesa se rechaza, el flujo se redirige al bloque <code>catch()</code> capturando el error y evitando que el programa falle.</p>"},{"location":"javascript/manejo-errores-en-promesas/#uso-de-finally-para-ejecucion-final","title":"Uso de finally() para Ejecuci\u00f3n Final","text":"<p>El m\u00e9todo <code>finally()</code> se ejecuta independientemente de si la promesa fue resuelta o rechazada, permitiendo ejecutar tareas de limpieza o finalizar acciones sin importar el resultado de la operaci\u00f3n.</p> <p>Ejemplo de Uso de finally()</p> javascript<pre><code>const promesa = new Promise((resolve, reject) =&gt; {\n    const exito = false;\n\n    if (exito) {\n        resolve(\"Operaci\u00f3n exitosa\");\n    } else {\n        reject(\"Ocurri\u00f3 un error\");\n    }\n});\n\npromesa\n    .then(resultado =&gt; console.log(\"Resultado:\", resultado))\n    .catch(error =&gt; console.log(\"Error capturado:\", error))\n    .finally(() =&gt; console.log(\"Operaci\u00f3n finalizada\"));\n</code></pre> <p>En este ejemplo, el <code>finally()</code> asegura que el mensaje \u201cOperaci\u00f3n finalizada\u201d se imprima independientemente del \u00e9xito o fallo de la promesa.</p>"},{"location":"javascript/manejo-errores-en-promesas/#propagacion-de-errores-en-cadena-de-promesas","title":"Propagaci\u00f3n de Errores en Cadena de Promesas","text":"<p>Al encadenar m\u00faltiples promesas, si una falla, los errores se propagan por la cadena hasta el primer bloque <code>catch()</code> disponible. Esto simplifica el manejo de errores en operaciones secuenciales, ya que no es necesario capturar errores en cada paso de la cadena.</p> <p>Ejemplo de Propagaci\u00f3n de Errores</p> javascript<pre><code>const promesa = new Promise((resolve, reject) =&gt; {\n  resolve(5);\n});\n\npromesa\n    .then(resultado =&gt; {\n        console.log(\"Resultado inicial:\", resultado);\n        return resultado * 2;\n    })\n    .then(doble =&gt; {\n        console.log(\"Doble:\", doble);\n        throw new Error(\"Error en la operaci\u00f3n\");\n    })\n    .then(triple =&gt; {\n        console.log(\"Este c\u00f3digo no se ejecutar\u00e1\");\n    })\n    .catch(error =&gt; console.log(\"Error capturado:\", error.message));\n</code></pre> <p>En el c\u00f3digo anterior el error lanzado en el segundo then es capturado por el <code>catch()</code> al final de la cadena.</p>"},{"location":"javascript/manejo-errores-en-promesas/#manejo-de-errores-condicionales","title":"Manejo de Errores Condicionales","text":"<p>Es posible gestionar errores espec\u00edficos basados en el tipo de error o en su mensaje, permitiendo reacciones diferentes para cada tipo de fallo. Este enfoque es \u00fatil en situaciones en las que ciertos errores requieren una respuesta particular o reintentos.</p> <p>Ejemplo de Manejo Condicional de Errores</p> javascript<pre><code>const promesa = new Promise((_, reject) =&gt; {\n    reject(new Error(\"Error de red\"));\n});\n\npromesa\n    .catch(error =&gt; {\n        if (error.message.includes(\"red\")) {\n        console.log(\"Error de red capturado, reintentando...\");\n        // Aqu\u00ed se podr\u00eda iniciar un reintento\n        } else {\n        console.log(\"Otro tipo de error:\", error.message);\n        }\n    });\n</code></pre> <p>Este patr\u00f3n ayuda a capturar y tratar los errores de manera espec\u00edfica, asegurando que cada error sea gestionado correctamente.</p>"},{"location":"javascript/manejo-errores-en-promesas/#error-handling-pattern-encapsulacion-con-funciones-asincronas","title":"Error Handling Pattern: Encapsulaci\u00f3n con Funciones As\u00edncronas","text":"<p>Cuando manejamos muchas promesas en paralelo o en cadena, encapsular el manejo de errores en una funci\u00f3n espec\u00edfica ayuda a mantener el c\u00f3digo organizado y facilita la reutilizaci\u00f3n.</p> <p>Ejemplo de Encapsulaci\u00f3n con Funciones de Manejo de Errores</p> javascript<pre><code>function manejarErrores(p) {\n    return p.catch(error =&gt; {\n        console.error(\"Error capturado:\", error.message);\n        return null;  // Retorna un valor seguro en caso de error\n    });\n}\n\nconst promesa1 = manejarErrores(new Promise((_, reject) =&gt; reject(new Error(\"Fallo en promesa 1\"))));\nconst promesa2 = manejarErrores(Promise.resolve(\"Promesa 2 exitosa\"));\n\nPromise.all([promesa1, promesa2])\n    .then(resultados =&gt; {\n        console.log(\"Resultados:\", resultados);\n    });\n</code></pre> <p>En este ejemplo, cada promesa es manejada por <code>manejarErrores()</code>, que captura cualquier error y retorna un valor predeterminado para que el flujo contin\u00fae sin interrupciones.</p>"},{"location":"javascript/manejo-errores-en-promesas/#buenas-practicas-para-el-manejo-de-errores-en-promesas","title":"Buenas Pr\u00e1cticas para el Manejo de Errores en Promesas","text":"<p>Para un manejo de errores eficaz en promesas, considera las siguientes buenas pr\u00e1cticas:</p> <ol> <li>Utiliza <code>catch</code> para Capturar Errores de Toda la Cadena: Coloca <code>catch</code> al final de la cadena de promesas para capturar cualquier error propagado.</li> <li>Usa <code>finally</code> para Tareas de Limpieza: Aprovecha <code>finally</code> para liberar recursos o ejecutar acciones finales sin importar el \u00e9xito o fallo de la promesa.</li> <li>Encapsula Errores en Funciones: En proyectos complejos, encapsular el manejo de errores en funciones espec\u00edficas mejora la legibilidad y la organizaci\u00f3n del c\u00f3digo.</li> </ol>"},{"location":"javascript/manejo-errores-en-promesas/#conclusion","title":"Conclusi\u00f3n","text":"<p>Manejar errores en promesas es esencial para escribir c\u00f3digo robusto y confiable en JavaScript. Al combinar <code>catch</code>, <code>finally</code>, y patrones avanzados, puedes garantizar que el flujo de tu aplicaci\u00f3n siga funcionando correctamente incluso en presencia de fallos. Estos enfoques mejoran la legibilidad del c\u00f3digo y reducen la posibilidad de errores inesperados.</p> <p>En el siguiente art\u00edculo exploraremos async/await en JavaScript, que ofrece una forma a\u00fan m\u00e1s sencilla de manejar operaciones as\u00edncronas y mejorar la claridad del c\u00f3digo.</p> <p></p>"},{"location":"javascript/map/","title":"Map","text":""},{"location":"javascript/map/#map","title":"Map","text":"<p>El objeto <code>Map</code> en JavaScript, introducido en ES6, es una estructura de datos dise\u00f1ada para almacenar pares clave-valor con mayor flexibilidad y eficiencia que los objetos tradicionales. Su capacidad para aceptar cualquier tipo de clave y su rendimiento consistente lo convierten en una herramienta esencial para proyectos modernos.</p> <p>En este art\u00edculo, exploraremos c\u00f3mo crear y utilizar un <code>Map</code>, profundizando en sus m\u00e9todos principales y aplicaciones pr\u00e1cticas.</p>"},{"location":"javascript/map/#que-es-un-map-en-javascript","title":"\u00bfQu\u00e9 es un Map en JavaScript?","text":"<p>Un <code>Map</code> es una colecci\u00f3n que permite almacenar pares clave-valor, donde cada clave es \u00fanica. A diferencia de los objetos, que solo permiten claves de tipo cadena o s\u00edmbolo, un <code>Map</code> puede usar cualquier tipo de dato como clave, incluidos objetos y funciones.</p> <ol> <li>Permitir claves de cualquier tipo, no solo cadenas.</li> <li>Mantener el orden de inserci\u00f3n, lo cual es crucial en muchas aplicaciones.</li> <li>Proporcionar m\u00e9todos nativos espec\u00edficos para la gesti\u00f3n de claves y valores.</li> </ol>"},{"location":"javascript/map/#cuando-usar-map-en-lugar-de-object","title":"\u00bfCu\u00e1ndo usar Map en lugar de Object?","text":"<ul> <li>Si necesitas claves que no sean cadenas (por ejemplo, n\u00fameros u objetos), <code>Map</code> es ideal.</li> <li>Si planeas iterar frecuentemente sobre las claves o valores, <code>Map</code> es m\u00e1s eficiente y directo.</li> </ul>"},{"location":"javascript/map/#como-crear-un-map","title":"C\u00f3mo crear un Map","text":"javascript<pre><code>const mapa = new Map([\n    ['nombre', 'Carlos'],\n    ['edad', 30],\n]);\n\n// Acceder a los valores del Map\nconst nombre = mapa.get('nombre');\nconst edad = mapa.get('edad');\n\nconsole.log(nombre);\nconsole.log(edad);\n</code></pre> <p>En este ejemplo, el <code>Map</code> se inicializa con dos pares clave-valor. Puedes usar el m\u00e9todo <code>get</code> para recuperar los valores asociados a cada clave.</p>"},{"location":"javascript/map/#metodos-principales-de-map","title":"M\u00e9todos principales de Map","text":"<p>Los m\u00e9todos de Map est\u00e1n dise\u00f1ados para facilitar la manipulaci\u00f3n de datos de manera eficiente. Aqu\u00ed detallamos los m\u00e1s importantes:</p>"},{"location":"javascript/map/#1-metodo-setkey-value","title":"1. M\u00e9todo <code>set(key, value)</code>","text":"<p>Este m\u00e9todo agrega un nuevo par clave-valor al <code>Map</code> o actualiza el valor si la clave ya existe. Es especialmente \u00fatil cuando necesitas construir din\u00e1micamente una colecci\u00f3n de datos.</p> javascript<pre><code>const mapa = new Map();\nmapa.set('clave', 'valor inicial');\nmapa.set('clave', 'valor actualizado'); // Sobrescribe el valor anterior\n\nconsole.log(mapa.get('clave'));\n</code></pre> <p>Detalle adicional: <code>set</code> devuelve el propio <code>Map</code>, lo que permite el encadenamiento de m\u00e9todos:</p> javascript<pre><code>mapa.set('a', 1).set('b', 2).set('c', 3);\n</code></pre>"},{"location":"javascript/map/#2-metodo-getkey","title":"2. M\u00e9todo <code>get(key)</code>","text":"<p>Permite recuperar el valor asociado a una clave espec\u00edfica. Si la clave no existe en el <code>Map</code>, devuelve <code>undefined</code>.</p> javascript<pre><code>const profesion = mapa.get('profesi\u00f3n'); // \"Desarrollador\"\n</code></pre> <p>A diferencia de los objetos, no se requiere manipular estructuras complejas para buscar valores; <code>get</code> simplifica la consulta directa.</p>"},{"location":"javascript/map/#3-metodo-haskey","title":"3. M\u00e9todo <code>has(key)</code>","text":"<p>Este m\u00e9todo verifica si una clave espec\u00edfica existe en el <code>Map</code>. Es \u00fatil cuando necesitas validar la presencia de un dato antes de usarlo.</p> javascript<pre><code>const mapa = new Map();\nmapa.set('clave', 'valor inicial');\n\nconsole.log(mapa.has('clave'));\nconsole.log(mapa.has('otraClave'));\n</code></pre> <p>Con <code>has</code>, puedes evitar errores al intentar acceder a claves inexistentes.</p>"},{"location":"javascript/map/#4-metodo-deletekey","title":"4. M\u00e9todo <code>delete(key)</code>","text":"<p>El m\u00e9todo <code>delete</code> elimina un par clave-valor de la colecci\u00f3n. Devuelve <code>true</code> si la clave exist\u00eda y fue eliminada, o <code>false</code> si no se encontr\u00f3.</p> javascript<pre><code>const mapa = new Map();\nmapa.set('clave', 'valor inicial');\nmapa.delete('clave');\n\nconsole.log(mapa.has('clave'));\n</code></pre> <p>Ventaja sobre los objetos: En un objeto, eliminar propiedades implica usar la propiedad <code>delete</code>, lo que puede ser m\u00e1s propenso a errores en comparaci\u00f3n con la claridad de <code>delete()</code> en <code>Map</code>.</p>"},{"location":"javascript/map/#5-metodo-clear","title":"5. M\u00e9todo <code>clear()</code>","text":"<p>El m\u00e9todo <code>clear</code> elimina todos los pares clave-valor de un <code>Map</code>. Esto reinicia la colecci\u00f3n, dej\u00e1ndola vac\u00eda.</p> javascript<pre><code>const mapa = new Map();\nmapa.set('clave', 'valor inicial');\nmapa.clear();\n\nconsole.log(mapa.size);\n</code></pre> <p>\u00bfCu\u00e1ndo usarlo? Ideal para reiniciar datos temporales o limpiar cach\u00e9s en aplicaciones.</p>"},{"location":"javascript/map/#propiedades-de-map","title":"Propiedades de <code>Map</code>","text":"<p>La propiedad <code>size</code> devuelve el n\u00famero total de pares clave-valor en el <code>Map</code>. Esto resulta \u00fatil para verificar r\u00e1pidamente cu\u00e1ntos elementos contiene la colecci\u00f3n.</p> javascript<pre><code>const mapa = new Map([\n    ['clave1', 'valor1'],\n    ['clave2', 'valor2']\n]);\n\nconsole.log(mapa.size);\n</code></pre> <p>A diferencia de los objetos, no es necesario usar m\u00e9todos adicionales como <code>Object.keys()</code> para contar las propiedades. Con <code>Map</code>, la propiedad <code>size</code> est\u00e1 directamente disponible.</p>"},{"location":"javascript/map/#iteracion-sobre-map","title":"Iteraci\u00f3n sobre <code>Map</code>","text":"<p>Una de las grandes ventajas de <code>Map</code> es su compatibilidad nativa con m\u00e9todos de iteraci\u00f3n.</p> <p>- M\u00e9todo <code>keys()</code>: Devuelve un iterador con todas las claves del <code>Map</code>.</p> javascript<pre><code>const mapa = new Map([\n    ['clave1', 'valor1'],\n    ['clave2', 'valor2']\n]);\n\nfor (const clave of mapa.keys()) {\n    console.log(clave);\n}\n</code></pre> <p>- M\u00e9todo <code>values()</code>: Devuelve un iterador con todos los valores del <code>Map</code>.</p> javascript<pre><code>const mapa = new Map([\n    ['clave1', 'valor1'],\n    ['clave2', 'valor2']\n]);\n\nfor (const valor of mapa.values()) {\n    console.log(valor);\n}\n</code></pre> <p>- M\u00e9todo <code>entries()</code>: Devuelve un iterador con los pares clave-valor en forma de arrays.</p> javascript<pre><code>const mapa = new Map([\n    ['clave1', 'valor1'],\n    ['clave2', 'valor2']\n]);\n\nfor (const [clave, valor] of mapa.entries()) {\n    console.log(`${clave}: ${valor}`);\n}\n</code></pre> <p>- Uso con <code>forEach</code>: <code>Map</code> tambi\u00e9n soporta el m\u00e9todo <code>forEach</code> para iterar sobre los pares clave-valor.</p> javascript<pre><code>const mapa = new Map([\n    ['clave1', 'valor1'],\n    ['clave2', 'valor2']\n]);\n\nmapa.forEach((valor, clave) =&gt; {\n    console.log(`${clave}: ${valor}`);\n});\n</code></pre>"},{"location":"javascript/map/#ejemplo-basico-contador-de-palabras","title":"Ejemplo B\u00e1sico: Contador de Palabras","text":"<p>Un <code>Map</code> es ideal para contar la cantidad de veces que aparece un elemento en una colecci\u00f3n, como palabras en un texto.</p> javascript<pre><code>const frase = 'hola mundo hola javascript mundo javascript javascript';\nconst palabras = frase.split(' ');\n\nconst contador = new Map();\n\npalabras.forEach((palabra) =&gt; {\n    if (contador.has(palabra)) {\n        contador.set(palabra, contador.get(palabra) + 1);\n    } else {\n        contador.set(palabra, 1);\n    }\n});\n\nconsole.log(contador);\n</code></pre>"},{"location":"javascript/map/#casos-de-uso-de-map","title":"Casos de Uso de <code>Map</code>","text":"<ol> <li>Almacenar configuraciones: <code>Map</code> es ideal para guardar configuraciones con claves din\u00e1micas.</li> <li>Seguimiento de referencias a objetos: Dado que las claves pueden ser objetos, es \u00fatil para almacenar datos asociados a instancias espec\u00edficas.</li> <li>Reemplazo de Object cuando se necesita iterabilidad: <code>Map</code> facilita la iteraci\u00f3n directa sobre claves y valores sin m\u00e9todos adicionales.</li> </ol>"},{"location":"javascript/map/#conclusion","title":"Conclusi\u00f3n","text":"<p>El objeto <code>Map</code> es una herramienta esencial para gestionar colecciones clave-valor en JavaScript de manera eficiente y ordenada. Su flexibilidad para aceptar cualquier tipo de clave, junto con sus m\u00e9todos optimizados, lo convierte en una alternativa superior a los objetos tradicionales en muchos casos. Desde manejar datos din\u00e1micos hasta eliminar redundancias, <code>Map</code> es una soluci\u00f3n vers\u00e1til para desarrolladores modernos.</p> <p>En el pr\u00f3ximo art\u00edculo exploraremos Set en JavaScript, una colecci\u00f3n dise\u00f1ada para manejar valores \u00fanicos.</p> <p></p>"},{"location":"javascript/metodo-promise-all/","title":"Promise.all","text":""},{"location":"javascript/metodo-promise-all/#promiseall-promesas-en-paralelo","title":"Promise.all: Promesas en Paralelo","text":"<p>El m\u00e9todo <code>Promise.all</code> en JavaScript es una herramienta poderosa para manejar m\u00faltiples operaciones as\u00edncronas que se ejecutan en paralelo. Es \u00fatil cuando necesitas realizar tareas que pueden completarse de manera independiente, pero deseas esperar a que todas finalicen antes de continuar con el flujo del programa.</p> <p>Si todas las promesas se resuelven con \u00e9xito, <code>Promise.all</code> devuelve una nueva promesa que se resuelve con un array de resultados en el mismo orden en que las promesas fueron proporcionadas. Sin embargo, si alguna promesa falla, se rechazar\u00e1 con el motivo de error de la primera promesa que no se resolvi\u00f3.</p>"},{"location":"javascript/metodo-promise-all/#sintaxis-basica-de-promiseall","title":"Sintaxis b\u00e1sica de Promise.all","text":"<p>El m\u00e9todo toma un array de promesas como entrada y devuelve una nueva promesa que espera a que todas las promesas proporcionadas se completen.</p> javascript<pre><code>Promise.all([promesa1, promesa2, promesa3])\n    .then(resultados =&gt; {\n        // Manejar los resultados de todas las promesas\n    })\n    .catch(error =&gt; {\n        // Manejar el error si alguna promesa falla\n    });\n</code></pre> <p>El m\u00e9todo toma un array de promesas y devuelve una nueva promesa que se resuelve con un array de resultados cuando todas las promesas se han completado con \u00e9xito.</p>"},{"location":"javascript/metodo-promise-all/#casos-comunes-de-uso","title":"Casos comunes de uso","text":"<ol> <li>Solicitar datos de m\u00faltiples fuentes: Realizar m\u00faltiples solicitudes HTTP y procesar las respuestas una vez que todas est\u00e9n disponibles.</li> <li>Cargar recursos simult\u00e1neamente: Cargar im\u00e1genes, scripts o datos de manera concurrente para optimizar el rendimiento.</li> <li>Validaciones paralelas: Ejecutar varias validaciones o c\u00e1lculos en paralelo y procesar los resultados cuando todas las tareas finalicen.</li> </ol>"},{"location":"javascript/metodo-promise-all/#ejemplo-basico-ejecutar-promesas-en-paralelo","title":"Ejemplo b\u00e1sico: Ejecutar promesas en paralelo","text":"<p>Supongamos que tienes tres operaciones as\u00edncronas que tardan diferentes tiempos en completarse:</p> javascript<pre><code>const promesa1 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve('Resultado 1'), 1000));\nconst promesa2 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve('Resultado 2'), 2000));\nconst promesa3 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve('Resultado 3'), 1500));\n\nPromise.all([promesa1, promesa2, promesa3])\n    .then(resultados =&gt; {\n        console.log(resultados); // ['Resultado 1', 'Resultado 2', 'Resultado 3']\n    })\n    .catch(error =&gt; {\n        console.log(\"Error en alguna de las promesas:\", error);\n    });\n</code></pre> <p>En este ejemplo las tres promesas se ejecutan en paralelo y el c\u00f3digo en el bloque <code>then</code> se ejecuta una vez que todas han terminado. Si alguna promesa falla, el <code>catch</code> manejar\u00e1 el error.</p>"},{"location":"javascript/metodo-promise-all/#que-pasa-si-alguna-promesa-falla","title":"\u00bfQu\u00e9 pasa si alguna promesa falla?","text":"<p>Si una de las promesas en el array es rechazada, la operaci\u00f3n se rechazar\u00e1 con el motivo de esa promesa.</p> javascript<pre><code>const promesaExitosa = Promise.resolve(\"\u00c9xito\");\nconst promesaFallida = Promise.reject(\"Fallo\");\n\nPromise.all([promesaExitosa, promesaFallida])\n    .then(resultados =&gt; {\n        console.log(resultados); // No se ejecutar\u00e1\n    })\n    .catch(error =&gt; {\n        console.log(\"Error capturado:\", error); // Error capturado: Fallo\n    });\n</code></pre>"},{"location":"javascript/metodo-promise-all/#uso-de-promiseall-con-asyncawait","title":"Uso de Promise.all con async/await","text":"<p><code>Promise.all</code> tambi\u00e9n puede usarse en funciones as\u00edncronas con <code>async/await</code>, lo que hace que el c\u00f3digo sea m\u00e1s legible y f\u00e1cil de manejar.</p> javascript<pre><code>async function cargarDatos() {\n    try {\n        const [usuario, ordenes, productos] = await Promise.all([\n        obtenerDatosUsuario(),\n        obtenerDatosOrdenes(),\n        obtenerDatosProductos()\n        ]);\n\n        console.log(\"Datos del usuario:\", usuario);\n        console.log(\"Datos de las \u00f3rdenes:\", ordenes);\n        console.log(\"Datos de los productos:\", productos);\n    } catch (error) {\n        console.log(\"Error al cargar los datos:\", error);\n    }\n}\n</code></pre> <p>En este ejemplo:</p> <ul> <li>Las funciones <code>obtenerDatosUsuario</code>, <code>obtenerDatosOrdenes</code> y <code>obtenerDatosProductos</code> se ejecutan en paralelo.</li> <li>Los resultados se asignan a variables en el orden en que se definieron en el array.</li> </ul>"},{"location":"javascript/metodo-promise-all/#consideraciones-importantes-al-usar-promiseall","title":"Consideraciones importantes al usar Promise.all","text":"<p>Orden de los resultados: Aunque las promesas se ejecutan en paralelo, los resultados en el array est\u00e1n garantizados en el orden en que las promesas fueron pasadas a <code>Promise.all</code>.</p> <p>No es ideal para dependencias: Si necesitas que una tarea dependa de los resultados de otra, usa encadenamiento en lugar de <code>Promise.all</code>.</p> <p>Manejo de errores: Captura los errores correctamente con <code>.catch()</code> o <code>try/catch</code> para evitar que el programa falle inesperadamente.</p>"},{"location":"javascript/metodo-promise-all/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":"<ul> <li>Aseg\u00farate de que todas las promesas sean necesarias: Si algunas tareas no dependen entre s\u00ed, evita incluirlas en un <code>Promise.all</code> para simplificar la l\u00f3gica.</li> <li>Controla los errores de manera adecuada: Dise\u00f1a tu l\u00f3gica para manejar fallos parciales si es necesario.</li> <li>Usa <code>async/await</code> para mayor claridad: Combina <code>Promise.all</code> con <code>async/await</code> para un c\u00f3digo m\u00e1s legible.</li> </ul>"},{"location":"javascript/metodo-promise-all/#conclusion","title":"Conclusi\u00f3n","text":"<p>El m\u00e9todo <code>Promise.all</code> es una herramienta fundamental en JavaScript para manejar m\u00faltiples promesas en paralelo. Es ideal para optimizar operaciones as\u00edncronas que pueden ejecutarse de manera independiente, reduciendo el tiempo total de espera. Al comprender c\u00f3mo funciona y manejar adecuadamente los errores, puedes mejorar significativamente la eficiencia de tus aplicaciones.</p> <p>En el pr\u00f3ximo art\u00edculo, abordaremos Promise.race en JavaScript, que permite manejar la primera promesa que se resuelva o rechace, ofreciendo una forma diferente de manejar la asincron\u00eda.</p> <p></p>"},{"location":"javascript/metodo-promise-allsettled/","title":"Promise.allSettled","text":""},{"location":"javascript/metodo-promise-allsettled/#promiseallsettled-manejo-completo-de-promesas","title":"Promise.allSettled: Manejo Completo de Promesas","text":"<p>El m\u00e9todo <code>Promise.allSettled</code> en JavaScript es una herramienta dise\u00f1ada para manejar m\u00faltiples promesas simult\u00e1neamente, garantizando que todas finalicen, independientemente de si se resuelven o se rechazan. A diferencia de Promise.all, que se detiene al encontrar una promesa rechazada, <code>.allSettled</code> devuelve un informe detallado con el estado y el resultado (o motivo de error) de cada promesa.</p> <p>Esta capacidad es especialmente \u00fatil en situaciones donde necesitas procesar m\u00faltiples tareas en paralelo y manejar cada resultado de manera individual, incluso si algunas tareas fallan.</p>"},{"location":"javascript/metodo-promise-allsettled/#que-es-promiseallsettled-y-cuando-usarlo","title":"\u00bfQu\u00e9 es Promise.allSettled y cu\u00e1ndo usarlo?","text":"<p>El m\u00e9todo <code>Promise.allSettled</code> toma un array de promesas como entrada y devuelve una nueva promesa que se resuelve cuando todas las promesas originales han terminado. Esta promesa resultante contiene un array de objetos que describen el estado (<code>fulfilled</code> o <code>rejected</code>) y el resultado (<code>value</code> o <code>reason</code>) de cada promesa.</p> <p>sintaxis b\u00e1sica:</p> javascript<pre><code>Promise.allSettled([promesa1, promesa2, promesa3])\n    .then(resultados =&gt; {\n        // Procesar resultados aqu\u00ed\n    });\n</code></pre> <p>La sintaxis b\u00e1sica de <code>Promise.allSettled</code> es similar a la de otros m\u00e9todos de promesas. Toma un array de promesas y devuelve una nueva promesa que se resuelve con un array de objetos, cada uno con las propiedades <code>status</code> y <code>value</code> o <code>reason</code>.</p>"},{"location":"javascript/metodo-promise-allsettled/#cuando-usar-promiseallsettled","title":"Cu\u00e1ndo usar <code>Promise.allSettled</code>","text":"<p>Este m\u00e9todo es \u00fatil cuando necesitas:</p> <ul> <li>Obtener un resumen completo de los resultados de varias operaciones, incluso si algunas fallan.</li> <li>Ejecutar procesos en lote donde el \u00e9xito o el fallo de una tarea no detenga la ejecuci\u00f3n general.</li> <li>Gestionar errores de manera individual sin detener otras operaciones.</li> </ul>"},{"location":"javascript/metodo-promise-allsettled/#ejemplo-basico-de-uso","title":"Ejemplo b\u00e1sico de uso","text":"<p>Imagina que tienes tres promesas, dos de las cuales se resuelven y una falla. <code>Promise.allSettled</code> procesar\u00e1 todas las promesas y proporcionar\u00e1 un resumen de su estado.</p> javascript<pre><code>const promesa1 = Promise.resolve(\"Promesa 1 completada\");\nconst promesa2 = Promise.reject(\"Error en Promesa 2\");\nconst promesa3 = Promise.resolve(\"Promesa 3 completada\");\n\nPromise.allSettled([promesa1, promesa2, promesa3])\n    .then(resultados =&gt; {\n        resultados.forEach((resultado, indice) =&gt; {\n        if (resultado.status === \"fulfilled\") {\n            console.log(`Promesa ${indice + 1} result\u00f3 con \u00e9xito: ${resultado.value}`);\n        } else {\n            console.log(`Promesa ${indice + 1} fall\u00f3: ${resultado.reason}`);\n        }\n        });\n    });\n</code></pre> <p>Cada promesa en el array es procesada independientemente. La salida muestra un resumen de cada operaci\u00f3n, especificando si se complet\u00f3 con \u00e9xito (<code>fulfilled</code>) o fall\u00f3 (<code>rejected</code>).</p>"},{"location":"javascript/metodo-promise-allsettled/#procesamiento-avanzado-de-resultados","title":"Procesamiento avanzado de resultados","text":"<p>Puedes organizar los resultados de <code>Promise.allSettled</code> en categor\u00edas para manejarlos de manera m\u00e1s clara, separando las promesas exitosas de las fallidas.</p> javascript<pre><code>async function procesarResultados(promesas) {\n    const resultados = await Promise.allSettled(promesas);\n    const exitosas = resultados.filter(res =&gt; res.status === \"fulfilled\");\n    const fallidas = resultados.filter(res =&gt; res.status === \"rejected\");\n\n    console.log(\"Promesas exitosas:\", exitosas.map(res =&gt; res.value));\n    console.log(\"Promesas fallidas:\", fallidas.map(res =&gt; res.reason));\n}\n\nconst promesas = [\n    Promise.resolve(\"Datos del Usuario\"),\n    Promise.reject(\"Error en el servidor\"),\n    Promise.resolve(\"Datos de la Orden\")\n];\n\nprocesarResultados(promesas)\n</code></pre> <p>Se utilizan funciones de filtro para clasificar los resultados seg\u00fan su estado. Los resultados exitosos (<code>fulfilled</code>) y fallidos (<code>rejected</code>) se procesan por separado.</p>"},{"location":"javascript/metodo-promise-allsettled/#ventajas-y-consideraciones-al-usar-promiseallsettled","title":"Ventajas y consideraciones al usar Promise.allSettled","text":"<p>Procesamiento completo: Garantiza que todas las promesas sean procesadas, incluso si algunas fallan.</p> <p>Control detallado de errores: Permite manejar errores individualmente sin interrumpir otras operaciones.</p> <p>Ideal para lotes de tareas: \u00datil cuando necesitas conocer el estado de cada tarea en un conjunto de operaciones.</p>"},{"location":"javascript/metodo-promise-allsettled/#consideraciones","title":"Consideraciones","text":"<ul> <li>Manejo de Datos Complejo: Los resultados incluyen tanto valores como razones de error, lo que puede requerir m\u00e1s l\u00f3gica para el manejo de datos.</li> <li>Mayor Uso de Recursos: Si algunas promesas son innecesarias cuando otra falla, Promise.race puede ser m\u00e1s eficiente en esos casos.</li> </ul>"},{"location":"javascript/metodo-promise-allsettled/#conclusion","title":"Conclusi\u00f3n","text":"<p><code>Promise.allSettled</code> es una herramienta valiosa para manejar m\u00faltiples promesas en paralelo sin detener el flujo de ejecuci\u00f3n en caso de errores. Proporciona un informe completo del estado de cada promesa, lo que lo convierte en una opci\u00f3n ideal para tareas en lote o cuando necesitas manejar resultados y errores de manera individual.</p> <p>En el pr\u00f3ximo art\u00edculo abordaremos Promise.any en JavaScript, que devuelve la primera promesa que se resuelve con \u00e9xito, proporcionando un enfoque diferente para manejar resultados en paralelo.</p> <p></p>"},{"location":"javascript/metodo-promise-any/","title":"Promise.any","text":""},{"location":"javascript/metodo-promise-any/#promiseany-esperando-la-primera-promesa-resuelta-con-exito","title":"Promise.any: Esperando la Primera Promesa Resuelta con \u00c9xito","text":"<p><code>Promise.any</code> es un m\u00e9todo en JavaScript que devuelve la primera promesa que se resuelve con \u00e9xito entre varias promesas dadas. A diferencia del m\u00e9todo Promise.race que devuelve el primer resultado (ya sea \u00e9xito o error), este m\u00e9todo solo se resuelve si al menos una de las promesas se completa satisfactoriamente.</p> <p>Si todas las promesas fallan, el m\u00e9todo se rechaza con un <code>AggregateError</code>, que proporciona un detalle de todos los errores.</p>"},{"location":"javascript/metodo-promise-any/#que-es-promiseany-y-cuando-usarlo","title":"\u00bfQu\u00e9 es Promise.any y Cu\u00e1ndo Usarlo?","text":"<p>Este m\u00e9todo aplicado a promesas es \u00fatil en situaciones donde solo necesitas el primer resultado exitoso entre varias promesas y puedes ignorar cualquier fallo que ocurra. Por ejemplo, en aplicaciones web con m\u00faltiples servidores, <code>Promise.any</code> permite obtener el primer dato disponible sin importar si otros servidores fallan o responden lentamente.</p> <p>sintaxis b\u00e1sica:</p> javascript<pre><code>Promise.any([promesa1, promesa2, promesa3])\n    .then(resultado =&gt; {\n        // Maneja el primer resultado exitoso\n    })\n    .catch(error =&gt; {\n        // Maneja el error si todas las promesas fallan\n    });\n</code></pre> <p>La sintaxis b\u00e1sica de <code>Promise.any</code> es similar a otros m\u00e9todos de promesas. Toma un array de promesas y devuelve una nueva promesa que se resuelve con el primer resultado exitoso o se rechaza si todas fallan.</p> <p>Casos Comunes de Uso</p> <ul> <li>Obtener datos del servidor m\u00e1s r\u00e1pido en configuraciones con respaldo.</li> <li>Elegir la primera respuesta de varios puntos finales, sin importar si algunos fallan.</li> <li>Optimizaci\u00f3n de consultas cuando solo necesitas un resultado exitoso.</li> </ul>"},{"location":"javascript/metodo-promise-any/#ejemplo-basico-de-promiseany","title":"Ejemplo B\u00e1sico de Promise.any","text":"<p>Imagina que tienes tres promesas que representan tareas con diferentes tiempos de espera. <code>Promise.any</code> devuelve el resultado de la primera que se complete exitosamente.</p> javascript<pre><code>const promesa1 = new Promise((_, reject) =&gt; setTimeout(() =&gt; reject(\"Error en Promesa 1\"), 1000));\nconst promesa2 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(\"Promesa 2 completada\"), 2000));\nconst promesa3 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(\"Promesa 3 completada\"), 3000));\n\nPromise.any([promesa1, promesa2, promesa3])\n    .then(resultado =&gt; {\n        console.log(\"Resultado exitoso:\", resultado);\n    })\n    .catch(error =&gt; {\n        console.log(\"Error en todas las promesas:\", error);\n    });\n</code></pre> <p>En el ejemplo anterior Promise.any devuelve el resultado de <code>promesa2</code> porque es la primera promesa que se completa exitosamente, mientras que el <code>promesa1</code> falla y <code>promesa3</code> tarda m\u00e1s tiempo.</p>"},{"location":"javascript/metodo-promise-any/#usando-promiseany-en-casos-de-respaldo-para-servicios-web","title":"Usando Promise.any en Casos de Respaldo para Servicios Web","text":"<p>En aplicaciones que dependen de m\u00faltiples servidores o APIs, Promise.any es \u00fatil para realizar solicitudes simult\u00e1neas y aceptar el primer resultado exitoso. Esta t\u00e9cnica mejora el rendimiento y evita bloqueos si alg\u00fan servicio falla o responde lentamente.</p> <p>Ejemplo: Servicio de Respaldo con Promise.any</p> <p>Supongamos que tenemos tres servicios de respaldo que proporcionan informaci\u00f3n del clima. Al usar <code>Promise.any</code> obtenemos la respuesta m\u00e1s r\u00e1pida sin depender de un solo servidor.</p> javascript<pre><code>function obtenerClimaServidor1() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; resolve(\"Clima desde Servidor 1: Soleado\"), 2000);\n    });\n}\n\nfunction obtenerClimaServidor2() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; reject(\"Servidor 2: Error de conexi\u00f3n\"), 1500);\n    });\n}\n\nfunction obtenerClimaServidor3() {\n    return new Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; resolve(\"Clima desde Servidor 3: Nublado\"), 1000);\n    });\n}\n\n// Usamos Promise.any para obtener el primer resultado exitoso\nPromise.any([obtenerClimaServidor1(), obtenerClimaServidor2(), obtenerClimaServidor3()])\n    .then(resultado =&gt; console.log(\"Resultado exitoso:\", resultado))\n    .catch(error =&gt; console.log(\"Todas las promesas fallaron:\", error));\n</code></pre> <p>En el ejemplo anterior <code>Promise.any</code> devuelve el resultado de <code>obtenerClimaServidor3</code> porque es el primer servidor en responder exitosamente, mientras que el <code>Servidor 2</code> falla y el <code>Servidor 1</code> tarda m\u00e1s.</p>"},{"location":"javascript/metodo-promise-any/#manejando-el-aggregateerror-con-promiseany","title":"Manejando el <code>AggregateError</code> con <code>Promise.any</code>","text":"<p><code>Promise.any</code> se rechazar\u00e1 solo si todas las promesas fallan, devolviendo un <code>AggregateError</code>. Este error especial permite identificar las razones de los fallos y decidir qu\u00e9 hacer si no se obtiene ning\u00fan resultado.</p> <p>Ejemplo de M\u00faltiples Errores en Promise.any</p> javascript<pre><code>const promesaFallida1 = new Promise((_, reject) =&gt; setTimeout(() =&gt; reject(\"Error en Promesa 1\"), 1000));\nconst promesaFallida2 = new Promise((_, reject) =&gt; setTimeout(() =&gt; reject(\"Error en Promesa 2\"), 2000));\n\nPromise.any([promesaFallida1, promesaFallida2])\n    .then(resultado =&gt; console.log(\"Resultado exitoso:\", resultado))\n    .catch(error =&gt; {\n        console.log(\"Todas las promesas fallaron:\");\n        error.errors.forEach((err, indice) =&gt; console.log(`Error ${indice + 1}: ${err}`));\n    });\n</code></pre> <p>Este ejemplo muestra c\u00f3mo manejar un <code>AggregateError</code> cuando todas las promesas fallan. El error proporciona una lista completa de los motivos de fallo para cada promesa.</p>"},{"location":"javascript/metodo-promise-any/#comparacion-entre-promiseany-y-promiserace","title":"Comparaci\u00f3n entre <code>Promise.any</code> y <code>Promise.race</code>","text":"<ul> <li><code>Promise.any</code>: Devuelve la primera promesa que se resuelve con \u00e9xito. Se rechaza solo si todas las promesas fallan.</li> <li><code>Promise.race</code>: Devuelve el primer resultado, ya sea una resoluci\u00f3n o un rechazo. Es \u00fatil cuando necesitas el primer resultado sin importar su \u00e9xito o fracaso.</li> </ul>"},{"location":"javascript/metodo-promise-any/#consideraciones-al-usar-promiseany","title":"Consideraciones al Usar <code>Promise.any</code>","text":"<ol> <li>\u00datil en Situaciones de Respaldo: Ideal para obtener datos en configuraciones con redundancia, donde es probable que una fuente falle.</li> <li>Recibe un <code>AggregateError</code>: Cuando todas las promesas fallan, maneja <code>AggregateError</code> para obtener los detalles de cada error individual.</li> <li>Utilidad en Optimizaci\u00f3n de Tiempos: Ideal para obtener respuestas r\u00e1pidas sin esperar a cada promesa.</li> </ol>"},{"location":"javascript/metodo-promise-any/#conclusion","title":"Conclusi\u00f3n","text":"<p><code>Promise.any</code> es una herramienta poderosa en JavaScript para situaciones donde solo necesitas el primer resultado exitoso entre varias promesas, proporcionando una alternativa \u00fatil al m\u00e9todo <code>Promise.race</code> Adem\u00e1s que nos permite optimizar el rendimiento y manejar m\u00faltiples operaciones de respaldo sin detenerse en errores individuales.</p> <p>En el siguiente art\u00edculo abordaremos el Manejo de Errores en Promesas en JavaScript</p> <p></p>"},{"location":"javascript/metodo-promise-race/","title":"Promise.race","text":""},{"location":"javascript/metodo-promise-race/#promiserace-resolviendo-la-promesa-mas-rapida","title":"Promise.race: Resolviendo la Promesa M\u00e1s R\u00e1pida","text":"<p>El m\u00e9todo <code>Promise.race</code> en JavaScript permite manejar varias promesas ejecutadas en paralelo y obtener el resultado de la primera que se resuelva o rechace. A diferencia de Promise.all, que espera a que todas las promesas terminen, <code>.race</code> devuelve una nueva promesa que se completa tan pronto como una de las promesas originales haya finalizado.</p> <p>Este m\u00e9todo es ideal en situaciones donde la velocidad es esencial, como establecer l\u00edmites de tiempo para tareas o elegir la respuesta m\u00e1s r\u00e1pida entre varias fuentes.</p>"},{"location":"javascript/metodo-promise-race/#como-funciona-promiserace","title":"C\u00f3mo funciona Promise.race","text":"<p>Este m\u00e9todo toma un array de promesas como argumento y devuelve una promesa que se resuelve o rechaza dependiendo del estado de la primera promesa en completarse.</p> <p>sintaxis b\u00e1sica:</p> javascript<pre><code>Promise.race([promesa1, promesa2, promesa3])\n    .then(resultado =&gt; {\n        // Manejar el primer resultado exitoso\n    })\n    .catch(error =&gt; {\n        // Manejar el error de la primera promesa rechazada\n    });\n</code></pre> <p>La sintaxis b\u00e1sica es similar a la de otros m\u00e9todos de promesas. Toma un array de promesas y devuelve una promesa que se resuelve o rechaza tan pronto como cualquiera de las promesas en el array se complete.</p>"},{"location":"javascript/metodo-promise-race/#ejemplo-basico-obteniendo-el-primer-resultado","title":"Ejemplo B\u00e1sico: Obteniendo el Primer Resultado","text":"<p>Imaginemos tres promesas con diferentes tiempos de espera. <code>Promise.race</code> devolver\u00e1 el resultado de la promesa que termine primero.</p> javascript<pre><code>const promesa1 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(\"Promesa 1 completada\"), 3000));\nconst promesa2 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(\"Promesa 2 completada\"), 2000));\nconst promesa3 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(\"Promesa 3 completada\"), 1000));\n\nPromise.race([promesa1, promesa2, promesa3])\n    .then(resultado =&gt; console.log(\"Resultado:\", resultado)) // \"Promesa 3 completada\"\n    .catch(error =&gt; console.log(\"Error:\", error));\n</code></pre> <p>En este ejemplo, aunque las otras promesas a\u00fan est\u00e1n en ejecuci\u00f3n, as\u00ed que el m\u00e9todo devuelve el resultado de la tercera promesa porque es la m\u00e1s r\u00e1pida.</p>"},{"location":"javascript/metodo-promise-race/#usos-comunes-de-promiserace","title":"Usos comunes de Promise.race","text":"<ol> <li>Establecer un l\u00edmite de tiempo para operaciones as\u00edncronas: Puedes crear una promesa que se rechace despu\u00e9s de cierto tiempo, sirviendo como un l\u00edmite para otra operaci\u00f3n.</li> </ol> javascript<pre><code>function solicitudConLimiteDeTiempo(promesa, tiempoLimite) {\n    const limite = new Promise((_, reject) =&gt; \n        setTimeout(() =&gt; reject(\"Tiempo l\u00edmite alcanzado\"), tiempoLimite)\n    );\n    return Promise.race([promesa, limite]);\n}\n\nconst solicitud = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(\"Solicitud completada\"), 3000));\n\nsolicitudConLimiteDeTiempo(solicitud, 2000)\n    .then(resultado =&gt; console.log(\"Resultado:\", resultado))\n    .catch(error =&gt; console.log(\"Error:\", error)); // \"Error: Tiempo l\u00edmite alcanzado\"\n</code></pre> <ol> <li> <p>Obtener la respuesta m\u00e1s r\u00e1pida de m\u00faltiples solicitudes: Si haces solicitudes a varias fuentes y solo necesitas la primera respuesta, <code>race</code> es una excelente opci\u00f3n.</p> </li> <li> <p>Implementar tareas de respaldo: En caso de que una tarea primaria falle o tarde demasiado, puedes proporcionar una tarea de respaldo m\u00e1s r\u00e1pida.</p> </li> </ol>"},{"location":"javascript/metodo-promise-race/#manejo-de-errores-en-promiserace","title":"Manejo de errores en Promise.race","text":"<p>Cuando la primera promesa en completarse es rechazada, Promise.race devuelve el motivo del error. Las dem\u00e1s promesas no afectan el resultado.</p> javascript<pre><code>const promesaExitosa = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(\"\u00c9xito\"), 3000));\nconst promesaFallida = new Promise((_, reject) =&gt; setTimeout(() =&gt; reject(\"Error en promesa\"), 1000));\n\nPromise.race([promesaExitosa, promesaFallida])\n    .then(resultado =&gt; console.log(\"Resultado:\", resultado))\n    .catch(error =&gt; console.log(\"Error capturado:\", error)); // \"Error capturado: Error en promesa\"\n</code></pre> <p>En el c\u00f3digo anterior <code>Promise.race</code> captura el error de <code>promesaFallida</code> porque es la que termina primero.</p>"},{"location":"javascript/metodo-promise-race/#limitando-el-tiempo-de-ejecucion-de-una-promesa-con-promiserace","title":"Limitando el Tiempo de Ejecuci\u00f3n de una Promesa con <code>Promise.race</code>","text":"<p>Uno de los usos m\u00e1s comunes de <code>Promise.race</code> es establecer un tiempo l\u00edmite para una operaci\u00f3n as\u00edncrona. En este caso creamos una promesa que se rechaza despu\u00e9s de un tiempo espec\u00edfico para que este m\u00e9todo pueda usarla como l\u00edmite de tiempo.</p> <p>Ejemplo: L\u00edmite de Tiempo para una Solicitud</p> javascript<pre><code>function solicitudConLimiteDeTiempo(promesa, tiempoLimite) {\n    let limite = new Promise((_, reject) =&gt;\n        setTimeout(() =&gt; reject(\"Tiempo l\u00edmite alcanzado\"), tiempoLimite)\n    );\n\n    return Promise.race([promesa, limite]);\n}\n\nlet solicitud = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(\"Solicitud completada\"), 3000));\n\nsolicitudConLimiteDeTiempo(solicitud, 2000)\n    .then(resultado =&gt; console.log(resultado))\n    .catch(error =&gt; console.log(\"Error:\", error));\n</code></pre> <p>En el ejemplo anterior, si la promesa de <code>solicitud</code> tarda m\u00e1s de 2000 ms en completarse, el metodo devuelve el error \u201cTiempo l\u00edmite alcanzado\u201d.</p>"},{"location":"javascript/metodo-promise-race/#consideraciones-importantes-al-usar-promiserace","title":"Consideraciones importantes al usar Promise.race","text":"<ol> <li>Primer resultado o error: <code>Promise.race</code> no garantiza que todas las promesas se completen, solo devuelve el resultado de la primera que lo haga.</li> <li>Usar con l\u00edmites de tiempo: Es excelente para limitar la duraci\u00f3n de una tarea, rechazando las promesas que tarden demasiado.</li> <li>Ignorar las promesas restantes: Las promesas que terminan despu\u00e9s de la primera ya no afectan el resultado. Esto puede ser \u00fatil en algunos casos, pero tambi\u00e9n puede generar operaciones innecesarias en segundo plano.</li> </ol>"},{"location":"javascript/metodo-promise-race/#conclusion","title":"Conclusi\u00f3n","text":"<p>El m\u00e9todo <code>Promise.race</code> es una herramienta poderosa en JavaScript que permite optimizar el manejo de operaciones as\u00edncronas donde la velocidad es clave. Ya sea para limitar tiempos de espera, obtener la respuesta m\u00e1s r\u00e1pida o manejar tareas de respaldo, este m\u00e9todo simplifica y agiliza el flujo de trabajo en aplicaciones modernas.</p> <p>En el siguiente art\u00edculo, exploraremos Promise.allSettled, una alternativa que devuelve el estado de todas las promesas, sin importar si fueron resueltas o rechazadas.</p> <p></p>"},{"location":"javascript/metodos-de-acceso/","title":"M\u00e9todos de Acceso a Caracteres","text":""},{"location":"javascript/metodos-de-acceso/#metodos-de-acceso-a-caracteres","title":"M\u00e9todos de Acceso a Caracteres","text":"<p>Los m\u00e9todos de acceso a caracteres en JavaScript nos permiten trabajar con las posiciones espec\u00edficas de un string, ya sea para obtener el car\u00e1cter en una posici\u00f3n, su representaci\u00f3n en Unicode o incluso para trabajar con \u00edndices negativos. En este art\u00edculo, exploraremos en detalle los m\u00e9todos <code>charAt</code>, <code>charCodeAt</code>, <code>codePointAt</code> y <code>at</code>.</p>"},{"location":"javascript/metodos-de-acceso/#obten-el-caracter-en-una-posicion-charat","title":"Obt\u00e9n el Car\u00e1cter en una Posici\u00f3n: <code>charAt</code>","text":"<p>El m\u00e9todo <code>charAt</code> devuelve el car\u00e1cter ubicado en una posici\u00f3n espec\u00edfica de un string. Si el \u00edndice est\u00e1 fuera de rango, devuelve una cadena vac\u00eda (<code>\"\"</code>).</p> javascript<pre><code>str.charAt(index)\n</code></pre> <ul> <li><code>index</code>: Es un n\u00famero entero que indica la posici\u00f3n del car\u00e1cter que deseas obtener. El \u00edndice comienza desde <code>0</code> (el primer car\u00e1cter de la cadena).</li> </ul> <p>Si el \u00edndice est\u00e1 fuera de los l\u00edmites (menor que <code>0</code> o mayor o igual al tama\u00f1o de la cadena) devuelve una cadena vac\u00eda (<code>\"\"</code>). Este es uno de los m\u00e9todos de acceso que ofrece una alternativa a la notaci\u00f3n de corchetes (<code>str[index]</code>), que realiza una tarea similar pero con un comportamiento m\u00e1s predecible en navegadores m\u00e1s antiguos.</p>"},{"location":"javascript/metodos-de-acceso/#obtener-un-caracter-en-una-posicion-especifica","title":"Obtener un car\u00e1cter en una posici\u00f3n espec\u00edfica","text":"javascript<pre><code>const text = \"JavaScript\";\n\nconsole.log(text.charAt(0)); // \"J\" (primer car\u00e1cter)\nconsole.log(text.charAt(4)); // \"S\" (quinto car\u00e1cter)\nconsole.log(text.charAt(10)); // \"\" (\u00edndice fuera de rango)\n</code></pre> <p>En el anterior ejemplo el m\u00e9todo con el argumento <code>0</code> devuelve el primer car\u00e1cter, <code>\"J\"</code>. con el argumento <code>4</code> devuelve el car\u00e1cter <code>\"S\"</code>. Un \u00edndice fuera del rango devuelve una cadena vac\u00eda.</p> <p>Ejemplo 1: Convertir el primer car\u00e1cter a may\u00fascula: Puedes usar <code>charAt()</code> para manipular el primer car\u00e1cter de una cadena.</p> javascript<pre><code>const text = \"javascript\";\nconst capitalized = text.charAt(0).toUpperCase() + text.slice(1);\n\nconsole.log(capitalized); // \"Javascript\"\n</code></pre> <p>Ejemplo 2: Verificar si un car\u00e1cter es un n\u00famero: Puedes verificar si un car\u00e1cter en una posici\u00f3n espec\u00edfica es un n\u00famero.</p> javascript<pre><code>const code = \"A12345\";\nconst char = code.charAt(1);\nif (!isNaN(char)) {\n    console.log(`El car\u00e1cter '${char}' es un n\u00famero.`);\n} else {\n    console.log(`El car\u00e1cter '${char}' no es un n\u00famero.`);\n}\n</code></pre>"},{"location":"javascript/metodos-de-acceso/#ventajas-del-uso-de-charat","title":"Ventajas del uso de <code>charAt()</code>","text":"<ol> <li>Compatibilidad universal: Es compatible incluso con navegadores antiguos.</li> <li>Claridad y legibilidad: Es expl\u00edcito en su prop\u00f3sito de obtener un car\u00e1cter en una posici\u00f3n espec\u00edfica.</li> <li>Predecible: Retorna una cadena vac\u00eda (<code>\"\"</code>) si el \u00edndice est\u00e1 fuera de rango, lo que facilita el manejo de errores.</li> </ol>"},{"location":"javascript/metodos-de-acceso/#codigo-unicode-del-caracter-charcodeat","title":"C\u00f3digo Unicode del Car\u00e1cter: <code>charCodeAt</code>","text":"<p>El m\u00e9todo <code>charCodeAt</code> se utiliza para obtener el c\u00f3digo Unicode del car\u00e1cter en una posici\u00f3n espec\u00edfica dentro de un string. Este m\u00e9todo es esencial cuando necesitas trabajar con valores num\u00e9ricos que representan caracteres, como codificaciones o comparaciones.</p> javascript<pre><code>string.charCodeAt(index);\n</code></pre> <ul> <li>**'index<code>**: Es un n\u00famero entero que indica la posici\u00f3n del car\u00e1cter en la cadena. El \u00edndice comienza en</code>0`.</li> </ul> <p>El m\u00e9todo devuelve el c\u00f3digo Unicode (n\u00famero entre 0 y 65535) del car\u00e1cter en la posici\u00f3n especificada. Si el \u00edndice est\u00e1 fuera de los l\u00edmites de la cadena (menor que 0 o mayor o igual al tama\u00f1o de la cadena), devuelve <code>NaN</code>. El valor devuelto corresponde al punto de c\u00f3digo de Unicode del car\u00e1cter (UTF-16).</p>"},{"location":"javascript/metodos-de-acceso/#obtener-el-codigo-unicode-de-un-caracter","title":"Obtener el c\u00f3digo Unicode de un car\u00e1cter","text":"javascript<pre><code>const text = \"Hola\";\n\nconsole.log(text.charCodeAt(0)); // 72 (c\u00f3digo de 'H')\nconsole.log(text.charCodeAt(1)); // 111 (c\u00f3digo de 'o')\nconsole.log(text.charCodeAt(10)); // NaN (\u00edndice fuera de rango)\n</code></pre> <p>Puedes usar el m\u00e9todo complementario <code>String.fromCharCode()</code> para convertir un c\u00f3digo en un car\u00e1cter:</p> javascript<pre><code>const code = 72;\n\nconsole.log(String.fromCharCode(code)); // \"H\"\n</code></pre> <p>Ejemplo: Recorrer una cadena y obtener los c\u00f3digos Unicode: Puedes usar un bucle para iterar sobre cada car\u00e1cter de la cadena y obtener su c\u00f3digo Unicode:</p> javascript<pre><code>const text = \"ABC\";\n\nfor (let i = 0; i &lt; text.length; i++) {\n    console.log(`Car\u00e1cter: ${text.charAt(i)}, C\u00f3digo: ${text.charCodeAt(i)}`);\n}\n</code></pre> <p>Ejemplo: Recorrer una cadena y obtener los c\u00f3digos Unicode: Puedes usar un bucle para iterar sobre cada car\u00e1cter de la cadena y obtener su c\u00f3digo Unicode:</p> javascript<pre><code>const text = \"ABC\";\nfor (let i = 0; i &lt; text.length; i++) {\n    console.log(`Car\u00e1cter: ${text.charAt(i)}, C\u00f3digo: ${text.charCodeAt(i)}`);\n}\n// Resultado:\n// Car\u00e1cter: A, C\u00f3digo: 65\n// Car\u00e1cter: B, C\u00f3digo: 66\n// Car\u00e1cter: C, C\u00f3digo: 67\n</code></pre>"},{"location":"javascript/metodos-de-acceso/#ventajas-del-metodo-charcodeat","title":"Ventajas del m\u00e9todo <code>charCodeAt()</code>","text":"<p>Sencillo y eficiente: Es una forma directa de acceder al valor Unicode de un car\u00e1cter. Compatibilidad universal: Funciona con todos los navegadores modernos y antiguos. Ideal para validaciones y transformaciones: \u00datil en tareas como la validaci\u00f3n de entradas o encriptaci\u00f3n b\u00e1sica.</p>"},{"location":"javascript/metodos-de-acceso/#valor-unicode-avanzado-codepointat","title":"Valor Unicode Avanzado: <code>codePointAt</code>","text":"<p>El m\u00e9todo <code>codePointAt()</code> se utiliza para obtener el valor Unicode completo (punto de c\u00f3digo) de un car\u00e1cter en una posici\u00f3n espec\u00edfica de una cadena. Este m\u00e9todo es especialmente \u00fatil para trabajar con caracteres fuera del rango b\u00e1sico de Unicode (como emojis o s\u00edmbolos especiales), que no pueden representarse con un solo valor de 16 bits en UTF-16.</p> javascript<pre><code>string.codePointAt(index);\n</code></pre> <ul> <li><code>index</code>: Es un n\u00famero entero que indica la posici\u00f3n del car\u00e1cter en la cadena. El \u00edndice comienza desde <code>0</code>.</li> </ul> <p>El m\u00e9todo <code>codePointAt</code> devuelve el punto de c\u00f3digo Unicode completo de un car\u00e1cter, incluso si est\u00e1 representado como un par sustituto en UTF-16. Es \u00fatil para caracteres que tienen valores mayores a <code>U+FFFF</code>. Si el \u00edndice est\u00e1 fuera del rango de la cadena, devuelve <code>undefined</code>.</p>"},{"location":"javascript/metodos-de-acceso/#obtener-el-valor-unicode-de-un-caracter","title":"Obtener el valor Unicode de un car\u00e1cter","text":"javascript<pre><code>const text = \"Hola\";\n\nconsole.log(text.codePointAt(0)); // 72 (c\u00f3digo de 'H')\nconsole.log(text.codePointAt(1)); // 111 (c\u00f3digo de 'o')\nconsole.log(text.codePointAt(10)); // undefined (\u00edndice fuera de rango)\n</code></pre>"},{"location":"javascript/metodos-de-acceso/#diferencias-entre-charcodeat-y-codepointat","title":"Diferencias entre <code>charCodeAt()</code> y <code>codePointAt()</code>","text":"<p>El m\u00e9todo <code>charCodeAt()</code> solo devuelve la primera parte de un par sustituto, mientras que <code>codePointAt()</code> maneja correctamente los puntos de c\u00f3digo suplementarios.</p> javascript<pre><code>const emoji = \"\ud83d\ude04\";\n\nconsole.log(emoji.charCodeAt(0)); // 55357 (primera parte del par sustituto)\nconsole.log(emoji.charCodeAt(1)); // 56836 (segunda parte del par sustituto)\n\nconsole.log(emoji.codePointAt(0)); // 128516 (valor completo del emoji)\n</code></pre> <p>Ejemplo: Detectar caracteres fuera del rango b\u00e1sico</p> javascript<pre><code>const text = \"A\ud83d\ude04B\";\nfor (let i = 0; i &lt; text.length; i++) {\n    const code = text.codePointAt(i);\n    if (code &gt; 65535) {\n        console.log(`Car\u00e1cter avanzado detectado: ${text[i]}, C\u00f3digo: ${code}`);\n        i++; // Saltar la segunda parte del par sustituto\n    } else {\n        console.log(`Car\u00e1cter: ${text[i]}, C\u00f3digo: ${code}`);\n    }\n}\n</code></pre>"},{"location":"javascript/metodos-de-acceso/#ventajas-de-codepointat","title":"Ventajas de <code>codePointAt()</code>","text":"<ul> <li>Compatibilidad con caracteres avanzados: Funciona perfectamente con caracteres suplementarios (por encima de <code>U+FFFF</code>).</li> <li>Evita errores con pares sustitutos: A diferencia de <code>charCodeAt()</code>, no es necesario combinar manualmente las partes de un par sustituto.</li> <li>Integraci\u00f3n con <code>String.fromCodePoint()</code>: Permite una conversi\u00f3n bidireccional sencilla entre puntos de c\u00f3digo y caracteres.</li> </ul>"},{"location":"javascript/metodos-de-acceso/#acceso-simplificado-con-indices-negativos-at","title":"Acceso Simplificado (Con \u00cdndices Negativos): <code>at</code>","text":"<p>El m\u00e9todo <code>at</code> proporciona una forma simplificada y moderna de acceder a los elementos de un string y arreglos con soporte para \u00edndices negativos. Fue introducido en ECMAScript 2022 y ofrece una alternativa m\u00e1s clara y funcional a la notaci\u00f3n de corchetes (<code>[]</code>) o m\u00e9todos tradicionales como <code>charAt()</code>.</p> <p>javascript<pre><code>string.at(index);\n</code></pre>   - <code>index</code>: Es un n\u00famero entero que indica la posici\u00f3n del elemento que deseas obtener. Puede ser positivo (desde el inicio) o negativo (desde el final).</p> <p>Este m\u00e9todo permite acceder a los elementos desde el final de la cadena o arreglo, sin necesidad de calcular manualmente la longitud. Devuelve el car\u00e1cter o elemento en la posici\u00f3n especificada, funciona tanto en cadenas como en arreglos. Si el \u00edndice est\u00e1 fuera de rango, devuelve <code>undefined</code> (en lugar de una cadena vac\u00eda como <code>charAt()</code>).</p>"},{"location":"javascript/metodos-de-acceso/#acceder-a-caracteres-en-cadenas","title":"Acceder a caracteres en cadenas","text":"javascript<pre><code>const text = \"JavaScript\";\n\nconsole.log(text.at(0));  // \"J\" (primer car\u00e1cter)\nconsole.log(text.at(4));  // \"S\" (quinto car\u00e1cter)\nconsole.log(text.at(-1)); // \"t\" (\u00faltimo car\u00e1cter)\nconsole.log(text.at(-3)); // \"i\" (tercer car\u00e1cter desde el final)\nconsole.log(text.at(20)); // undefined (\u00edndice fuera de rango)\n</code></pre> <p>Acceder a elementos en arreglos:</p> javascript<pre><code>const array = [10, 20, 30, 40, 50];\n\nconsole.log(array.at(0));  // 10 (primer elemento)\nconsole.log(array.at(-1)); // 50 (\u00faltimo elemento)\nconsole.log(array.at(-2)); // 40 (pen\u00faltimo elemento)\nconsole.log(array.at(10)); // undefined (\u00edndice fuera de rango)\n</code></pre>"},{"location":"javascript/metodos-de-acceso/#ventajas-de-usar-at","title":"Ventajas de usar <code>at()</code>","text":"<ul> <li>1. Soporte para \u00edndices negativos: El m\u00e9todo <code>at()</code> simplifica el acceso a elementos desde el final de una cadena o arreglo. Con m\u00e9todos anteriores, esto requer\u00eda c\u00e1lculos manuales con la longitud.</li> <li>Comportamiento predecible: A diferencia de <code>charAt()</code>, que devuelve una cadena vac\u00eda si el \u00edndice est\u00e1 fuera de rango, <code>at()</code> devuelve <code>undefined</code>, lo que facilita la detecci\u00f3n de errores.</li> <li>Compatibilidad con arreglos: El soporte para cadenas y arreglos hace que sea una soluci\u00f3n unificada y m\u00e1s legible.</li> </ul>"},{"location":"javascript/metodos-de-acceso/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los m\u00e9todos de acceso a caracteres en JavaScript son herramientas fundamentales para trabajar con strings a nivel granular:</p> <ul> <li>Usa <code>charAt</code> o <code>at</code> para obtener caracteres individuales, con \u00edndices positivos o negativos.</li> <li>Prefiere <code>charCodeAt</code> y <code>codePointAt</code> cuando necesites informaci\u00f3n sobre valores Unicode.</li> <li>Adopta <code>normalize</code> para trabajar con texto multiling\u00fce o evitar inconsistencias en caracteres similares.</li> </ul> <p>Conocer estos m\u00e9todos te permitir\u00e1 manejar texto de manera m\u00e1s precisa y eficiente en tus proyectos.</p> <p></p>"},{"location":"javascript/metodos-de-busqueda-strings/","title":"M\u00e9todos de B\u00fasqueda en Strings","text":""},{"location":"javascript/metodos-de-busqueda-strings/#metodos-de-busqueda-en-strings","title":"M\u00e9todos de B\u00fasqueda en Strings","text":"<p>Los m\u00e9todos de b\u00fasqueda en JavaScript son importantes porque nos ayudan a localizar textos dentro de un string o cadena de caracteres, ya sea para verificar su existencia, encontrar su posici\u00f3n o buscar algun patr\u00f3n en espec\u00edfico. Comprender su funcionamiento es importante para escribir c\u00f3digo claro y eficiente.</p> <p>En este art\u00edculo exploraremos los m\u00e9todos de b\u00fasqueda del lenguaje. <code>indexOf</code>, <code>lastIndexOf</code>, <code>includes</code> y <code>search</code>, junto con sus casos de uso m\u00e1s comunes.</p>"},{"location":"javascript/metodos-de-busqueda-strings/#encuentra-la-primera-aparicion-indexof","title":"Encuentra la Primera Aparici\u00f3n: <code>indexOf()</code>","text":"<p>El m\u00e9todo <code>indexOf</code> nos permite buscar la posici\u00f3n de la primera aparici\u00f3n de un texto (subcadena) dentro de otra cadena. Este es un m\u00e9todo simple pero poderoso y se utiliza com\u00fanmente para realizar operaciones como b\u00fasqueda, validaci\u00f3n y manipulaci\u00f3n de texto.</p> javascript<pre><code>str.indexOf(searchValue, fromIndex)\n</code></pre> <ul> <li><code>searchValue</code>: La subcadena que deseas buscar dentro de la cadena principal.</li> <li><code>fromIndex</code> (opcional): El \u00edndice desde donde quieres que comience la b\u00fasqueda. Si no se especifica, comienza desde el inicio de la cadena (\u00edndice 0).</li> </ul> <p> El m\u00e9todo indexOf() devuelve el \u00edndice de la primera aparici\u00f3n de searchValue en la cadena. En caso de encontrar el valor buscado, devuelve -1. y un dato a tener en cuenta es que es sensible a may\u00fasculas y min\u00fasculas.</p> <p></p> <p>B\u00fasqueda b\u00e1sica con indexOf:</p> javascript<pre><code>const text = \"Hola mundo\";\n\nconsole.log(text.indexOf(\"mundo\")); // 5\nconsole.log(text.indexOf(\"Hola\"));  // 0\nconsole.log(text.indexOf(\"hola\"));  // -1 (sensible a may\u00fasculas)\n</code></pre>"},{"location":"javascript/metodos-de-busqueda-strings/#usando-el-segundo-parametro-fromindex","title":"Usando el segundo par\u00e1metro (fromIndex)","text":"<p>Podemos especificar desde donde queremos que el m\u00e9todo empiece la b\u00fasqueda, para esto utilizamos el par\u00e1metro num\u00e9rico que establece el \u00edndice espec\u00edfico.</p> javascript<pre><code>const text = \"Banana Banana\";\n\nconsole.log(text.indexOf(\"Banana\"));       // 0\nconsole.log(text.indexOf(\"Banana\", 1));   // 7 (salta la primera \"Banana\")\nconsole.log(text.indexOf(\"Banana\", 8));   // -1 (no hay m\u00e1s \"Banana\" despu\u00e9s del \u00edndice 8)\n</code></pre>"},{"location":"javascript/metodos-de-busqueda-strings/#validar-si-una-subcadena-existe","title":"Validar si una subcadena existe","text":"<p>Un uso recurrente para este metodo es la verificaci\u00f3n de un texto en un string, dado que <code>indexOf</code> devuelve <code>-1</code> si no encuentra la subcadena, puedes usarlo para verificar si un texto esta presente dentro de esta.</p> javascript<pre><code>const text = \"Frontend Developer\";\n\nif (text.indexOf(\"Developer\") !== -1) {\n    console.log(\"La palabra 'Developer' est\u00e1 presente.\");\n} else {\n    console.log(\"No se encontr\u00f3 'Developer'.\");\n}\n</code></pre>"},{"location":"javascript/metodos-de-busqueda-strings/#buenas-practicas-al-usar-indexof","title":"Buenas pr\u00e1cticas al usar indexOf","text":"<ol> <li>Comprobar con <code>-1</code>: Aseg\u00farate de manejar los casos donde no se encuentra la subcadena.</li> <li>Trabajar con cadenas normalizadas: Si est\u00e1s buscando cadenas que pueden diferir en may\u00fasculas/min\u00fasculas, normaliza antes de buscar.</li> <li>Usa <code>fromIndex</code> para optimizar b\u00fasquedas repetidas: Al buscar m\u00faltiples ocurrencias, establece un \u00edndice inicial para no buscar desde el principio cada vez.</li> </ol>"},{"location":"javascript/metodos-de-busqueda-strings/#encuentra-la-ultima-aparicion-lastindexof","title":"Encuentra la \u00daltima Aparici\u00f3n: <code>lastIndexOf()</code>","text":"<p>El m\u00e9todo <code>lastIndexOf</code> es similar a <code>indexOf</code>, pero en lugar de buscar la primera aparici\u00f3n de una subcadena, busca la \u00faltima aparici\u00f3n en una cadena. Este m\u00e9todo es \u00fatil cuando necesitas identificar la posici\u00f3n final de un texto o caracter dentro de un string, especialmente cuando este puede aparecer m\u00faltiples veces.</p> javascript<pre><code>str.lastIndexOf(searchValue, fromIndex)\n</code></pre> <ul> <li><code>searchValue</code>: La subcadena o car\u00e1cter que deseas buscar dentro de la cadena principal.</li> <li><code>fromIndex</code> (opcional): El \u00edndice desde el cual comenzar la b\u00fasqueda, pero en este caso se realiza hacia atr\u00e1s (de derecha a   izquierda). Por defecto, es la longitud de la cadena menos 1 (el final de la cadena).</li> </ul> <p> El m\u00e9todo lastIndexOf() devuelve el \u00edndice de la \u00faltima aparici\u00f3n de la subcadena especificada, si no encuentra la devuelve -1. Tambien es sensible a may\u00fasculas y min\u00fasculas y comienza la b\u00fasqueda desde el final de la cadena (o desde el \u00edndice fromIndex especificado).</p> <p></p> <p>B\u00fasqueda b\u00e1sica con lastIndexOf:</p> javascript<pre><code>const text = \"JavaScript es asombroso, y JavaScript es popular.\";\nconsole.log(text.lastIndexOf(\"JavaScript\")); // 27 (\u00faltima aparici\u00f3n)\nconsole.log(text.lastIndexOf(\"es\"));         // 38 (\u00faltima aparici\u00f3n)\nconsole.log(text.lastIndexOf(\"z\"));          // -1 (no encontrado)\n</code></pre>"},{"location":"javascript/metodos-de-busqueda-strings/#usar-el-segundo-parametro-fromindex","title":"Usar el segundo par\u00e1metro (fromIndex)","text":"<p>Puedes especificar desde qu\u00e9 \u00edndice iniciar la b\u00fasqueda (hacia atr\u00e1s):</p> javascript<pre><code>const text = \"JavaScript es genial. JavaScript es \u00fatil.\";\n\nconsole.log(text.lastIndexOf(\"JavaScript\", 20)); // 0 (busca hacia atr\u00e1s desde el \u00edndice 20)\nconsole.log(text.lastIndexOf(\"JavaScript\", 10)); // 0 (tambi\u00e9n encuentra la primera aparici\u00f3n)\n</code></pre>"},{"location":"javascript/metodos-de-busqueda-strings/#ejemplo-encontrar-la-ultima-palabra-o-caracter-en-una-cadena","title":"Ejemplo: Encontrar la \u00faltima palabra o caracter en una cadena","text":"<p>Si tienes una cadena de caracteres o string y quieres encontrar d\u00f3nde aparece por \u00faltima vez un caracter, <code>lastIndexOf</code> es una buena opci\u00f3n a utilizar:</p> javascript<pre><code>const url = \"https://www.ejemplo.com/archivo.html\";\nconst lastSlash = url.lastIndexOf(\"/\");\n\nconsole.log(lastSlash); // 23\nconsole.log(url.substring(lastSlash + 1)); // \"archivo.html\"\n</code></pre>"},{"location":"javascript/metodos-de-busqueda-strings/#consideraciones-al-usar-lastindexof","title":"Consideraciones al usar lastIndexOf","text":"<ol> <li>B\u00fasqueda ineficiente en cadenas grandes: Al realizar b\u00fasquedas en cadenas extensas, especialmente desde un \u00edndice cercano al inicio, puede ser m\u00e1s costoso que <code>indexOf</code>.</li> <li>No permite expresiones regulares: Si necesitas mayor flexibilidad para buscar patrones complejos, considera usar el m\u00e9todo <code>search</code> con expresiones regulares.</li> </ol>"},{"location":"javascript/metodos-de-busqueda-strings/#verifica-si-un-texto-esta-presente-includes","title":"Verifica si un Texto Est\u00e1 Presente: <code>includes()</code>","text":"<p>El m\u00e9todo <code>includes</code> en JavaScript nos permite verificar si un string contiene una subcadena espec\u00edfica. A diferencia de otros m\u00e9todos, <code>includes</code> no devuelve la posici\u00f3n de la coincidencia, sino un valor booleano (<code>true</code> o <code>false</code>). Este m\u00e9todo es ideal para comprobaciones r\u00e1pidas y limpias.</p> javascript<pre><code>str.includes(searchString, position)\n</code></pre> <ul> <li><code>searchString</code>: La subcadena que deseas buscar dentro de la cadena principal.</li> <li><code>position</code> (opcional): El \u00edndice desde el cual comenzar la b\u00fasqueda. Por defecto es 0 (inicio de la cadena).</li> </ul> <p> El metodo includes() devuelve un valor booleano: true: Si la subcadena existe dentro de la cadena principal. false: Si la subcadena no existe. Tambien es sensible a may\u00fasculas y min\u00fasculas y no devuelve la posici\u00f3n de la subcadena, solo indica si existe o no.</p> <p></p> <p>Ejemplo b\u00e1sico: Verificar la existencia de una subcadena:</p> javascript<pre><code>const text = \"JavaScript es incre\u00edble\";\n\nconsole.log(text.includes(\"JavaScript\")); // true\nconsole.log(text.includes(\"incre\u00edble\"));  // true\nconsole.log(text.includes(\"python\"));     // false\n</code></pre>"},{"location":"javascript/metodos-de-busqueda-strings/#usar-el-segundo-parametro-position","title":"Usar el segundo par\u00e1metro (position)","text":"<p>Puedes especificar un \u00edndice desde donde iniciar la b\u00fasqueda:</p> javascript<pre><code>const text = \"Hola mundo, bienvenido al mundo de JavaScript.\";\n\nconsole.log(text.includes(\"mundo\"));           // true\nconsole.log(text.includes(\"mundo\", 10));        // true (busca desde el \u00edndice 10)\nconsole.log(text.includes(\"bienvenido \", 25));  // false (despu\u00e9s del \u00edndice 25 no hay \"bienvenido\")\n</code></pre>"},{"location":"javascript/metodos-de-busqueda-strings/#ejemplo-validar-si-una-palabra-clave-esta-presente","title":"Ejemplo: Validar si una palabra clave est\u00e1 presente","text":"javascript<pre><code>const email = \"usuario@example.com\";\n\nif (email.includes(\"@\")) {\n    console.log(\"El correo electr\u00f3nico es v\u00e1lido.\");\n} else {\n    console.log(\"El correo electr\u00f3nico no es v\u00e1lido.\");\n}\n</code></pre>"},{"location":"javascript/metodos-de-busqueda-strings/#ventajas-del-metodo-includes","title":"Ventajas del m\u00e9todo includes()","text":"<ol> <li>Legible y directo: Es f\u00e1cil de entender, ya que indica claramente si un texto incluye una subcadena.</li> <li>M\u00e1s expresivo: Comparado con <code>indexOf</code>, no necesitas verificar si el resultado es diferente de <code>-1</code>.</li> <li>\u00datil para validaciones: Ideal para casos donde solo importa la presencia de una subcadena, no su posici\u00f3n.</li> </ol>"},{"location":"javascript/metodos-de-busqueda-strings/#buscar-con-expresiones-regulares-search","title":"Buscar con Expresiones Regulares: <code>search()</code>","text":"<p>El m\u00e9todo <code>search()</code> se utiliza para buscar un patr\u00f3n espec\u00edfico dentro de una cadena de texto. Este m\u00e9todo es poderoso porque permite el uso de expresiones regulares para definir patrones de b\u00fasqueda, lo que lo hace m\u00e1s flexible que m\u00e9todos como <code>indexOf</code> o <code>includes</code>.</p> javascript<pre><code>str.search(regexp)\n</code></pre> <ul> <li><code>regexp</code>: Una expresi\u00f3n regular (o un objeto <code>RegExp</code>) que define el patr\u00f3n que deseas buscar. Tambi\u00e9n puedes pasar una cadena literal, que internamente se convierte en una expresi\u00f3n regular.</li> </ul> <p> El m\u00e9todo search() devuelve la posici\u00f3n del primer \u00edndice donde se encuentra una coincidencia con el patr\u00f3n, si no encuentra ninguna coincidencia, devuelve -1. Funciona exclusivamente con patrones de b\u00fasqueda, lo que lo hace ideal para b\u00fasquedas avanzadas o casos donde indexOf no es suficiente.</p> <p></p>"},{"location":"javascript/metodos-de-busqueda-strings/#ejemplos-basicos","title":"Ejemplos b\u00e1sicos:","text":"<p>Buscar un texto literal con el m\u00e9todo search()</p> javascript<pre><code>const text = \"JavaScript es asombroso.\";\n\nconsole.log(text.search(\"JavaScript\")); // 0\nconsole.log(text.search(\"es\"));         // 11\nconsole.log(text.search(\"Python\"));     // -1 (no encontrado)\n</code></pre> <p>Usar expresiones regulares</p> javascript<pre><code>const text = \"JavaScript es divertido.\";\n\nconsole.log(text.search(/divertido/));  // 14 (coincide con \"divertido\")\nconsole.log(text.search(/javascript/i)); // 0 (coincide con \"JavaScript\", sin distinguir may\u00fasculas/min\u00fasculas)\n</code></pre>"},{"location":"javascript/metodos-de-busqueda-strings/#ejemplo-validar-un-formato-especifico","title":"Ejemplo: Validar un formato espec\u00edfico","text":"<p>Puedes usar <code>search()</code> para validar patrones como correos electr\u00f3nicos, n\u00fameros de tel\u00e9fono o URLs.</p> javascript<pre><code>const email = \"usuario@example.com\";\nconst emailPattern = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\nif (email.search(emailPattern) !== -1) {\n    console.log(\"El correo es v\u00e1lido.\");\n} else {\n    console.log(\"El correo no es v\u00e1lido.\");\n}\n</code></pre> javascript<pre><code>const phone = \"123-456-7890\";\nconst phonePattern = /^\\d{3}-\\d{3}-\\d{4}$/;\n\nif (phone.search(phonePattern) !== -1) {\n    console.log(\"El n\u00famero de tel\u00e9fono es v\u00e1lido.\");\n} else {\n    console.log(\"El n\u00famero de tel\u00e9fono no es v\u00e1lido.\");\n}\n</code></pre>"},{"location":"javascript/metodos-de-busqueda-strings/#ventajas-del-metodo-search","title":"Ventajas del m\u00e9todo search()","text":"<ol> <li>Soporte para expresiones regulares: Esto lo hace mucho m\u00e1s flexible y poderoso que m\u00e9todos como <code>indexOf</code>.</li> <li>Intuitivo: Aunque permite expresiones regulares complejas, su uso b\u00e1sico es f\u00e1cil de entender.</li> <li>B\u00fasquedas avanzadas: Puedes usar modificadores como <code>i</code> (ignorar may\u00fasculas), <code>g</code> (global) o patrones complejos.</li> </ol>"},{"location":"javascript/metodos-de-busqueda-strings/#algunas-limitaciones-al-utilizar-el-metodo-search","title":"Algunas limitaciones al utilizar el m\u00e9todo search()","text":"<ol> <li>Devuelve solo el \u00edndice de la primera coincidencia: Si necesitas encontrar todas las coincidencias, es mejor usar el m\u00e9todo <code>match</code> con una expresi\u00f3n regular global (<code>/patr\u00f3n/g</code>).</li> <li>No proporciona un booleano: Si solo necesitas verificar la presencia de un patr\u00f3n, <code>includes</code> es m\u00e1s apropiado.</li> <li>Requiere expresiones regulares para b\u00fasquedas avanzadas: Esto puede ser confuso para desarrolladores no familiarizados con las expresiones regulares.</li> </ol>"},{"location":"javascript/metodos-de-busqueda-strings/#conclusion","title":"Conclusi\u00f3n:","text":"<p>Los m\u00e9todos de b\u00fasqueda en JavaScript ofrecen soluciones vers\u00e1tiles para manipular texto:</p> <ul> <li>Usa <code>includes</code> para verificaciones r\u00e1pidas.</li> <li>Prefiere <code>indexOf</code> y <code>lastIndexOf</code> para localizar posiciones exactas.</li> <li>Utiliza <code>search</code> cuando necesites manejar patrones m\u00e1s complejos.</li> </ul> <p>Con estos m\u00e9todos disponibles podr\u00e1s resolver problemas relacionados con cadenas de texto de forma efectiva y profesional.</p> <p></p>"},{"location":"javascript/metodos-de-concatenacion-string/","title":"M\u00e9todos de Concatenaci\u00f3n y Relleno","text":""},{"location":"javascript/metodos-de-concatenacion-string/#metodos-de-concatenacion-y-relleno-en-strings","title":"M\u00e9todos de Concatenaci\u00f3n y Relleno en Strings","text":"<p>En JavaScript, los m\u00e9todos de concatenaci\u00f3n y relleno no solo son herramientas \u00fatiles, sino que tambi\u00e9n ofrecen una soluci\u00f3n directa para tareas como combinar strings o cadenas de caracteres din\u00e1micamente, crear formatos visuales consistentes y construir patrones de texto repetitivos. Comprender c\u00f3mo funcionan <code>concat</code>, <code>padStart</code>, <code>padEnd</code> y <code>repeat</code> te permitir\u00e1 resolver problemas espec\u00edficos de manipulaci\u00f3n de strings con precisi\u00f3n y eficiencia.</p>"},{"location":"javascript/metodos-de-concatenacion-string/#combina-strings-de-forma-explicita-concat","title":"Combina Strings de Forma Expl\u00edcita: <code>concat</code>","text":"<p>El m\u00e9todo <code>concat</code> es una forma directa de unir dos o m\u00e1s cadenas en una sola. Aunque el operador <code>+</code> o los template literals (<code>${}</code>) suelen ser m\u00e1s populares, <code>concat</code> puede resultar \u00fatil cuando necesitas una funci\u00f3n clara y expl\u00edcita para manejar la combinaci\u00f3n de strings.</p> javascript<pre><code>string1.concat(string2, string3, ..., stringN)\n</code></pre> <ul> <li><code>string1</code>: String / Cadena base.</li> <li><code>string2, ..., stringN</code>: Strings o cadenas adicionales que deseas concatenar.</li> </ul> javascript<pre><code>const saludo = \"Hola\";\nconst nombre = \"Mundo\";\nconst mensaje = saludo.concat(\", \", nombre, \"!\");\n\nconsole.log(mensaje); // \"Hola, Mundo!\"\n</code></pre> <p>El m\u00e9todo toma el string <code>\"Hola\"</code> y le a\u00f1ade <code>\", \"</code>, <code>\"Mundo\"</code>, y <code>\"!\"</code>, devolviendo una nueva cadena con todo concatenado.</p> <p>El m\u00e9todo <code>concat()</code> No modifica las cadenas originales, adem\u00e1s devuelve una nueva cadena con los valores concatenados. Es m\u00e1s expl\u00edcito que usar el operador <code>+</code>, aunque funcionalmente similar y permite concatenar m\u00faltiples cadenas en una sola llamada.</p>"},{"location":"javascript/metodos-de-concatenacion-string/#ejemplo-construir-una-url-con-concat","title":"Ejemplo: Construir una URL con Concat()","text":"javascript<pre><code>const baseUrl = \"https://www.ejemplo.com/\";\nconst ruta = \"articulo\";\nconst id = \"123\";\nconst url = baseUrl.concat(ruta, \"/\", id);\n\nconsole.log(url);\n</code></pre> <p>Normalmente se utiliza este m\u00e9todo cuando se manejan m\u00faltiples variables din\u00e1micas y quieres evitar el uso excesivo del operador <code>+</code></p> javascript<pre><code>function crearMensaje(saludo, nombre) {\n  return saludo.concat(\", \", nombre, \".\");\n}\n\nconsole.log(crearMensaje(\"Buenas tardes\", \"Mar\u00eda\"));\n</code></pre> <p>El m\u00e9todo <code>concat()</code> es una forma expl\u00edcita y legible de unir cadenas. Aunque no ofrece ventajas significativas sobre el operador <code>+</code>, es \u00fatil en casos donde la intenci\u00f3n de concatenar debe ser clara.</p>"},{"location":"javascript/metodos-de-concatenacion-string/#completar-rellenar-un-string-en-su-inicio-padstart","title":"Completar / Rellenar un String en su Inicio: <code>padStart</code>","text":"<p>El m\u00e9todo <code>padStart</code> es ideal para agregar caracteres al principio de un string, como ceros iniciales en n\u00fameros, espacios o cualquier otro s\u00edmbolo necesario para alcanzar una longitud espec\u00edfica. Este m\u00e9todo es com\u00fanmente utilizado en formateos.</p> javascript<pre><code>string.padStart(targetLength, padString)\n</code></pre> <ul> <li><code>targetLength</code>: La longitud deseada para la cadena resultante.</li> <li><code>padString</code> (opcional): La cadena con la que se rellenar\u00e1. Por defecto es un espacio (<code>\" \"</code>).</li> </ul> <p>Este m\u00e9todo completa al inicio, es decir, rellena con el valor especificado al principio de la cadena, sin modificar la cadena o string original. A dem\u00e1s, si la longitud de la cadena es igual o mayor al par\u00e1metro recibido como <code>targetLength</code>, devuelve el string original.</p> <p>Ejemplo B\u00e1sico:</p> javascript<pre><code>const numero = \"123\";\n\nconsole.log(numero.padStart(6, \"0\")); // \"000123\"\nconsole.log(numero.padStart(8, \"*\")); // \"*****123\"\n</code></pre> <p>En el ejemplo anterior en el primer ejemplo, el string <code>\"123\"</code> se rellena con ceros al principio hasta alcanzar una longitud total de 6 caracteres. En el segundo ejemplo, se rellenan con asteriscos hasta alcanzar 8 caracteres.</p> <p>El metodo <code>padStart</code> es ideal para formatear n\u00fameros o c\u00f3digos con una longitud fija, como en identificadores o n\u00fameros de tarjeta:</p> javascript<pre><code>function formatearCodigo(codigo) {\n  return codigo.toString().padStart(10, \"0\");\n}\n\nconsole.log(formatearCodigo(12345));\n</code></pre>"},{"location":"javascript/metodos-de-concatenacion-string/#completar-rellenar-un-string-en-su-final-padend","title":"Completar / Rellenar un String en su final: <code>padEnd</code>","text":"<p>Al contrario de <code>padStart</code>, <code>padEnd</code> agrega caracteres al final de una cadena de caracteres. Es especialmente \u00fatil para alinear texto o formatear columnas, como en tablas.</p> javascript<pre><code>string.padEnd(targetLength, padString)\n</code></pre> <ul> <li><code>targetLength</code>: La longitud deseada de la cadena resultante.</li> <li><code>padString</code> (opcional): La cadena usada para rellenar. Por defecto es un espacio (<code>\" \"</code>).</li> </ul> <p>El m\u00e9todo <code>padEnd()</code> Completa al final, es decir rellena con el valor especificado al final del string. Este m\u00e9todo No modifica la cadena original y si la longitud de la cadena es igual o mayor a <code>targetLength</code>, devuelve la cadena original.</p> javascript<pre><code>const texto = \"Hola\";\n\nconsole.log(texto.padEnd(10, \".\"));\nconsole.log(texto.padEnd(8, \"!\"));\n</code></pre> <p>En el c\u00f3digo anterior el string <code>\"Hola\"</code> se extiende a\u00f1adiendo puntos hasta que su longitud sea 10. En el segundo caso, se rellenan signos de exclamaci\u00f3n hasta alcanzar 8 caracteres.</p> <p>Este m\u00e9todo es usado para formatear listas de texto con alineaci\u00f3n visual, por ejemplo:</p> javascript<pre><code>function formatearColumna(titulo, dato) {\n  return titulo.padEnd(15, \" \") + dato;\n}\n\nconsole.log(formatearColumna(\"Nombre\", \"Juan\"));\nconsole.log(formatearColumna(\"Edad\", \"30\"));\n</code></pre>"},{"location":"javascript/metodos-de-concatenacion-string/#genera-patrones-repitiendo-un-string-repeat","title":"Genera Patrones Repitiendo un String: <code>repeat</code>","text":"<p>El m\u00e9todo <code>repeat</code> permite generar patrones de texto al repetir un string un n\u00famero espec\u00edfico de veces. Es \u00fatil en tareas como la creaci\u00f3n de separadores o cuando necesitas cadenas repetitivas.</p> javascript<pre><code>string.repeat(count)\n</code></pre> <ul> <li><code>count</code>: Un n\u00famero entero que indica cu\u00e1ntas veces se repetir\u00e1 la cadena. Debe ser un valor positivo o cero, si es un decimal, se redondea hacia abajo.</li> </ul> javascript<pre><code>const texto = \"\u00a1Hola! \";\n\nconsole.log(texto.repeat(3));\n</code></pre> <p>En el ejemplo anterior el string <code>\"\u00a1Hola! \"</code> se repite tres veces y se concatena en una nueva cadena.</p> <p>El m\u00e9todo Crea una nueva cadena, repite la cadena original sin modificarla y Devuelve una cadena vac\u00eda si <code>count</code> es 0. Tambi\u00e9n puede lanzar un error si <code>count</code> es negativo o infinito.</p> <p>Ejemplo: l\u00edneas decorativas Un uso pr\u00e1ctico es la creaci\u00f3n de separadores o encabezados decorativos.</p> javascript<pre><code>const decoracion = \"*\".repeat(10);\n\nconsole.log(decoracion); // \"**********\"\n</code></pre> <p>Crear patrones din\u00e1micos:</p> javascript<pre><code>const filas = 5;\nfor (let i = 1; i &lt;= filas; i++) {\n    console.log(\"#\".repeat(i));\n}\n</code></pre> <p>Otro caso com\u00fan es generar contenido estructurado, como cajas visuales:</p> javascript<pre><code>function crearCaja(texto, ancho) {\n  const borde = \"*\".repeat(ancho);\n  return `${borde}\\n${texto.padStart((ancho + texto.length) / 2).padEnd(ancho)}\\n${borde}`;\n}\n\nconsole.log(crearCaja(\"JavaScript\", 20));\n</code></pre> <p>El m\u00e9todo <code>repeat()</code> es perfecto para generar patrones repetitivos, l\u00edneas decorativas o replicar cadenas en bucles. Es una herramienta simple pero poderosa para tareas de dise\u00f1o y manipulaci\u00f3n de texto.</p>"},{"location":"javascript/metodos-de-concatenacion-string/#formas-de-utilizar-los-metodos-de-concatenacion-y-relleno","title":"Formas de Utilizar los M\u00e9todos de Concatenaci\u00f3n y Relleno","text":"<ol> <li>Usa <code>concat</code> para una Sem\u00e1ntica Clara: Aunque los operadores <code>+</code> y <code>${}</code> son m\u00e1s comunes, <code>concat</code> puede ser \u00fatil cuando necesitas enfatizar que est\u00e1s trabajando \u00fanicamente con strings.</li> <li><code>padStart</code> y <code>padEnd</code> en Formateo de Datos: Estos m\u00e9todos son perfectos para formatear contenido en interfaces de usuario, como reportes o sistemas de facturaci\u00f3n.</li> <li>Combina M\u00e9todos para Crear Estructuras Visuales: Combinar <code>repeat</code>, <code>padStart</code> y <code>padEnd</code> puede ayudarte a generar contenido visualmente atractivo. Por ejemplo, puedes crear cuadros, tablas o patrones decorativos para interfaces de terminal o logs.</li> <li>Optimiza el Uso de <code>repeat</code>: Para tareas repetitivas, como generar separadores o encabezados, <code>repeat</code> es m\u00e1s eficiente y legible que concatenar manualmente un string varias veces.</li> <li>Controla Longitudes Din\u00e1micas con <code>padStart</code> y <code>padEnd</code>: \u00dasalos para trabajar con cadenas de longitudes variables y asegurarte de que el resultado sea uniforme.</li> <li>Ten en Cuenta el Rendimiento: Aunque estos m\u00e9todos son eficientes para tareas espec\u00edficas, evita su uso excesivo en operaciones que procesen grandes cantidades de datos en ciclos.</li> </ol>"},{"location":"javascript/metodos-de-concatenacion-string/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los m\u00e9todos de concatenaci\u00f3n y relleno de JavaScript son herramientas extremadamente vers\u00e1tiles, ideales para combinar, extender o manipular strings en una amplia variedad de contextos. Su utilidad se extiende desde tareas simples, como agregar ceros iniciales en un n\u00famero, hasta casos m\u00e1s avanzados, como crear estructuras visuales din\u00e1micas.</p> <p></p>"},{"location":"javascript/metodos-de-division-y-union-en-strings/","title":"M\u00e9todos de Divisi\u00f3n y Uni\u00f3n en Strings","text":""},{"location":"javascript/metodos-de-division-y-union-en-strings/#metodos-de-division-y-union-en-strings","title":"M\u00e9todos de Divisi\u00f3n y Uni\u00f3n en Strings","text":"<p>En la manipulaci\u00f3n de datos en JavaScript, los m\u00e9todos de divisi\u00f3n y uni\u00f3n <code>split</code> y <code>join</code> juegan un papel importante. <code>split()</code> permite dividir un string en partes m\u00e1s manejables y convertirlo en un array, mientras que <code>join()</code> hace el proceso inverso, uniendo los elementos de un array en una \u00fanica cadena de texto. Comprender estos m\u00e9todos es esencial para el procesamiento de datos, formateo de strings y conversi\u00f3n eficiente entre tipos de datos.</p>"},{"location":"javascript/metodos-de-division-y-union-en-strings/#convertir-un-string-en-un-array-split","title":"Convertir un String en un Array: <code>split</code>","text":"<p>El m\u00e9todo <code>split()</code> divide string o una cadena de texto en m\u00faltiples fragmentos y devuelve un array con los elementos resultantes. Se basa en un separador que define el punto de divisi\u00f3n.</p> javascript<pre><code>string.split(separator, limit);\n</code></pre> <ul> <li><code>separator</code> (opcional): Define el car\u00e1cter o expresi\u00f3n regular que indica d\u00f3nde dividir el string.</li> <li><code>limit</code> (opcional): Especifica la cantidad m\u00e1xima de elementos en el array resultante.</li> </ul> javascript<pre><code>const texto = \"manzana,pera,uva,mango\";\n\nconsole.log(texto.split(\",\"));  // [\"manzana\", \"pera\", \"uva\", \"mango\"]\n</code></pre> <p>El separador <code>\",\"</code> indica que cada vez que se encuentra una coma en el string, se crea un nuevo elemento en el array.</p>"},{"location":"javascript/metodos-de-division-y-union-en-strings/#division-con-un-limite","title":"Divisi\u00f3n con un L\u00edmite","text":"javascript<pre><code>const lista = \"manzana,pera,uva,mango\";\n\nconsole.log(lista.split(\",\", 2));  // [\"manzana\", \"pera\"]\n</code></pre> <p>En el codigo anterior el l\u00edmite <code>2</code> indica que solo se deben extraer los dos primeros elementos, ignorando el resto del string.</p> <p>Caso de Uso: Convertir una Oraci\u00f3n en Palabras: Uno de los usos m\u00e1s comunes de <code>split()</code> es descomponer una oraci\u00f3n en palabras individuales.</p> javascript<pre><code>function obtenerPalabras(texto) {\n  return texto.split(\" \");\n}\n\nconsole.log(obtenerPalabras(\"JavaScript es un lenguaje poderoso\"));\n</code></pre> <p>Este enfoque es \u00fatil en motores de b\u00fasqueda, an\u00e1lisis de texto y procesamiento de datos.</p>"},{"location":"javascript/metodos-de-division-y-union-en-strings/#unir-elementos-de-un-array-en-un-string-join","title":"Unir Elementos de un Array en un String: <code>join</code>","text":"<p>El m\u00e9todo <code>join()</code> hace lo contrario a <code>split()</code>, une los elementos de un array en un solo string, separ\u00e1ndolos mediante un separador definido.</p> javascript<pre><code>array.join(separator);\n</code></pre> <ul> <li><code>separator</code> (opcional): Define el car\u00e1cter que separar\u00e1 cada elemento en el string resultante. Si se omite, se usa una coma <code>\",\"</code> por defecto.</li> </ul> javascript<pre><code>const frutas = [\"manzana\", \"pera\", \"uva\", \"mango\"];\n\nconsole.log(frutas.join(\", \"));  // \"manzana, pera, uva, mango\"\n</code></pre> <p>En el c\u00f3digo anterior cada elemento del array se une en un solo string, separado por <code>\", \"</code>.</p>"},{"location":"javascript/metodos-de-division-y-union-en-strings/#uso-sin-separador","title":"Uso sin Separador","text":"<p>Si no se proporciona un separador, <code>join()</code> usa la coma <code>\",\"</code> por defecto.</p> javascript<pre><code>const frutas = [\"manzana\", \"pera\", \"uva\", \"mango\"];\n\nconsole.log(frutas.join());  // \"manzana,pera,uva,mango\"\n</code></pre> <p>Caso de Uso: Formatear Listas para Interfaces de Usuario.</p> javascript<pre><code>const nombres = [\"Carlos\", \"Ana\", \"Luis\"];\n\nconsole.log(\"Participantes: \" + nombres.join(\" - \")); // \"Participantes: Carlos - Ana - Luis\"\n</code></pre> <p>Este uso es ideal para mostrar datos en listas de forma legible.</p>"},{"location":"javascript/metodos-de-division-y-union-en-strings/#diferencias-entre-split-y-join","title":"Diferencias entre split() y join()","text":"<p>Aunque <code>split()</code> y <code>join()</code> parecen opuestos, cada uno tiene una funci\u00f3n espec\u00edfica en la manipulaci\u00f3n de strings y arrays. A continuaci\u00f3n, te explico sus diferencias clave:</p> <ol> <li>Tipo de Entrada y Salida<ul> <li><code>split()</code> recibe un string y lo divide en un array basado en un separador.</li> <li><code>join()</code> recibe un array y lo convierte en un string, uniendo los elementos con un separador.</li> </ul> </li> <li>Prop\u00f3sito Principal<ul> <li><code>split()</code> se usa para fragmentar cadenas de texto, permitiendo separar palabras, caracteres o estructuras definidas.</li> <li><code>join()</code> se usa para construir cadenas a partir de un array, facilitando la creaci\u00f3n de listas o formatos legibles.</li> </ul> </li> <li>Uso del Separador<ul> <li>En <code>split()</code>, el separador define d\u00f3nde se corta la cadena y desaparece en la salida.</li> <li>En <code>join()</code>, el separador se inserta entre cada elemento del array en la salida.</li> </ul> </li> <li>Efecto en los Datos<ul> <li><code>split()</code> puede devolver un array con uno o m\u00e1s elementos dependiendo del separador y del contenido del string original.</li> <li><code>join()</code> siempre devuelve un solo string, sin importar cu\u00e1ntos elementos haya en el array.</li> </ul> </li> <li>Casos de Uso<ul> <li><code>split()</code>: Ideal para analizar texto, dividir palabras, extraer datos estructurados.</li> <li><code>join()</code>: Perfecto para formatear datos, crear cadenas legibles, generar reportes o estructuras din\u00e1micas.</li> </ul> </li> </ol>"},{"location":"javascript/metodos-de-division-y-union-en-strings/#practicas-para-usar-split-y-join","title":"Pr\u00e1cticas para Usar <code>split()</code> y <code>join()</code>","text":"<ul> <li>Usa <code>split(\" \")</code> para dividir oraciones en palabras.</li> <li>Utiliza <code>join()</code> para construir cadenas de texto de manera eficiente sin concatenaciones manuales.</li> <li>Combina <code>split()</code> y <code>join()</code> para eliminar espacios innecesarios en strings:</li> </ul> javascript<pre><code>function limpiarTexto(texto) {\n  return texto.split(\" \").join(\" \");\n}\n</code></pre>"},{"location":"javascript/metodos-de-division-y-union-en-strings/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los m\u00e9todos split() y join() son herramientas clave en la manipulaci\u00f3n de strings y arrays en JavaScript:</p> <ul> <li>Usa <code>split()</code> cuando necesites fragmentar un string en partes manejables.</li> <li>Prefiere <code>join()</code> cuando quieras unir elementos de un array en una cadena formateada.</li> </ul> <p>Estos m\u00e9todos permiten transformar datos con facilidad, haci\u00e9ndolos fundamentales para el procesamiento de texto en cualquier aplicaci\u00f3n web.</p> <p></p>"},{"location":"javascript/metodos-de-extraccion/","title":"M\u00e9todos de Extracci\u00f3n y Corte","text":""},{"location":"javascript/metodos-de-extraccion/#metodos-de-extraccion-y-corte","title":"M\u00e9todos de Extracci\u00f3n y Corte","text":"<p>La manipulaci\u00f3n de cadenas de texto o strings es una tarea muy recurrida en JavaScript, y los m\u00e9todos <code>slice</code>, <code>substring</code> y <code>split</code> son herramientas clave para realizar estas operaciones. Estos m\u00e9todos te permiten extraer secciones de un string o dividirlo en partes m\u00e1s manejables. En este art\u00edculo, exploraremos c\u00f3mo funcionan, c\u00f3mo se diferencian y c\u00f3mo puedes utilizarlos de manera efectiva en tus proyectos.</p>"},{"location":"javascript/metodos-de-extraccion/#extrae-una-porcion-de-la-cadena-slice","title":"Extrae una Porci\u00f3n de la Cadena: <code>slice</code>","text":"<p>El m\u00e9todo <code>slice</code> se utiliza para extraer una parte de un string. Recibe dos argumentos: el \u00edndice de inicio y el \u00edndice de fin (opcional). Devuelve una nueva cadena que contiene los caracteres desde el \u00edndice de inicio hasta el \u00edndice anterior al \u00edndice de fin. Si no se especifica el \u00edndice de fin, <code>slice</code> extrae desde el \u00edndice de inicio hasta el final del string.</p> javascript<pre><code>string.slice(start, end);\n</code></pre> <ul> <li><code>start</code>: Especifica el \u00edndice desde donde comienza la extracci\u00f3n. Si es negativo, cuenta desde el final de la cadena, si no se especifica, comienza desde el \u00edndice <code>0</code>.</li> <li><code>end</code> (opcional): Especifica el \u00edndice donde termina la extracci\u00f3n (no incluye este \u00edndice). Si es negativo, cuenta desde el final, si no se especifica extrae hasta el final de la cadena.</li> </ul>"},{"location":"javascript/metodos-de-extraccion/#extraer-una-subcadena-especifica","title":"Extraer una subcadena espec\u00edfica","text":"javascript<pre><code>const texto = \"JavaScript es asombroso\";\n\nconst subcadena = texto.slice(0, 10); // Desde el \u00edndice 0 hasta el 9\nconsole.log(subcadena); // \"JavaScript\"\n</code></pre> <p>Omitir el par\u00e1metro <code>end</code>: Si no se especifica el segundo argumento, extrae desde <code>start</code> hasta el final de la cadena:</p> javascript<pre><code>const texto = \"Frontend Developer\";\n\nconst subcadena = texto.slice(9);\nconsole.log(subcadena); // \"Developer\"\n</code></pre> <p>Usar \u00edndices negativos: Los \u00edndices negativos cuentan desde el final de la cadena:</p> javascript<pre><code>const texto = \"JavaScript\";\n\nconst subcadena = texto.slice(-10, -6); // Desde -10 (inicio) hasta -6 (no incluido)\nconsole.log(subcadena); // \"Java\"\n</code></pre> <p>El m\u00e9todo <code>slice</code> es especialmente \u00fatil cuando necesitas extraer partes espec\u00edficas de una cadena, como la extensi\u00f3n de un archivo:</p> javascript<pre><code>function obtenerExtension(archivo) {\n  return archivo.slice(archivo.lastIndexOf(\".\") + 1);\n}\n\nconsole.log(obtenerExtension(\"documento.txt\")); // \"txt\"\nconsole.log(obtenerExtension(\"imagen.png\")); // \"png\"\n</code></pre> <p>En este ejemplo, el m\u00e9todo <code>lastIndexOf</code> encuentra la posici\u00f3n del \u00faltimo punto en el nombre del archivo, y <code>slice</code> extrae todo lo que viene despu\u00e9s, devolviendo la extensi\u00f3n del archivo.</p>"},{"location":"javascript/metodos-de-extraccion/#ventajas-de-slice","title":"Ventajas de <code>slice()</code>","text":"<ol> <li>Seguro y no destructivo: No altera la cadena o arreglo original.</li> <li>Versatilidad: Funciona con cadenas y arreglos, lo que lo hace adecuado para m\u00faltiples casos.</li> <li>Soporte para \u00edndices negativos: Simplifica la extracci\u00f3n desde el final.</li> </ol>"},{"location":"javascript/metodos-de-extraccion/#extrae-subcadenas-de-forma-segura-substring","title":"Extrae Subcadenas de Forma Segura: substring","text":"<p>El m\u00e9todo <code>substring()</code> se utiliza para extraer una porci\u00f3n de una cadena entre dos \u00edndices, devolviendo una nueva cadena sin modificar la original. Es una alternativa al m\u00e9todo <code>slice()</code> pero con algunas diferencias importantes, como el manejo de \u00edndices negativos.</p> javascript<pre><code>string.substring(start, end)\n</code></pre> <ul> <li><code>start</code>: \u00cdndice donde comienza la extracci\u00f3n. Es obligatorio.</li> <li><code>end</code> (opcional): \u00cdndice donde finaliza la extracci\u00f3n (no incluido). Si no se especifica, extrae hasta el final de la cadena.</li> </ul> <p>El m\u00e9todo substring No modifica la cadena original, devuelve una nueva cadena con la porci\u00f3n extra\u00edda. \u00cdndices negativos no v\u00e1lidos: Si se pasa un \u00edndice negativo, se considera como <code>0</code>. Si <code>start</code> es mayor que <code>end</code> los valores se invierten autom\u00e1ticamente.</p> <p>No permite contar desde el final: A diferencia de <code>slice()</code>, no acepta \u00edndices negativos.</p>"},{"location":"javascript/metodos-de-extraccion/#extraer-una-subcadena-especifica_1","title":"Extraer una subcadena espec\u00edfica","text":"javascript<pre><code>const texto = \"JavaScript es incre\u00edble\";\n\nconst subcadena = texto.substring(0, 10); // Desde el \u00edndice 0 hasta el 9\nconsole.log(subcadena); // \"JavaScript\"\n</code></pre>"},{"location":"javascript/metodos-de-extraccion/#omitir-el-segundo-argumento","title":"Omitir el segundo argumento","text":"<p>Si no se especifica el par\u00e1metro <code>end</code>, extrae desde el \u00edndice inicial hasta el final de la cadena:</p> javascript<pre><code>const texto = \"Frontend Developer\";\n\nconst subcadena = texto.substring(9);\nconsole.log(subcadena); // \"Developer\"\n</code></pre>"},{"location":"javascript/metodos-de-extraccion/#intercambio-de-indices","title":"Intercambio de \u00edndices","text":"<p>Si <code>start</code> es mayor que <code>end</code>, <code>substring()</code> invierte los valores autom\u00e1ticamente:</p> javascript<pre><code>const texto = \"JavaScript\";\n\nconst subcadena = texto.substring(10, 4); // Se invierte a substring(4, 10)\nconsole.log(subcadena); // \"Script\"\n</code></pre>"},{"location":"javascript/metodos-de-extraccion/#ventajas-de-substring","title":"Ventajas de substring()","text":"<ol> <li>Robustez: Los \u00edndices negativos y valores fuera de rango no generan errores.</li> <li>Intercambio de \u00edndices autom\u00e1tico: Asegura que siempre funcione, sin importar el orden de los argumentos.</li> <li>Legibilidad: Es claro y f\u00e1cil de entender para tareas de extracci\u00f3n de texto.</li> </ol>"},{"location":"javascript/metodos-de-extraccion/#divide-un-string-en-partes-split","title":"Divide un String en Partes: <code>split</code>","text":"<p>El m\u00e9todo <code>split()</code> en JavaScript se utiliza para dividir una cadena en un arreglo de subcadenas, usando un separador especificado. Es una herramienta esencial para trabajar con datos basados en texto, como transformar una l\u00ednea de texto en elementos individuales o procesar datos estructurados.</p> javascript<pre><code>string.split(separator, limit)\n</code></pre> <ul> <li><code>separator</code>: Define c\u00f3mo dividir la cadena. Puede ser: Una subcadena espec\u00edfica (como <code>\",\"</code> o <code>\" \"</code>), una expresi\u00f3n regular para patrones m\u00e1s complejos. Si no se especifica o es <code>undefined</code>, el resultado ser\u00e1 un arreglo con la cadena completa como \u00fanico elemento.</li> <li><code>limit</code> (opcional): Un n\u00famero que indica cu\u00e1ntas divisiones realizar. Si se especifica, el arreglo resultante tendr\u00e1 un m\u00e1ximo de <code>limit</code> elementos.</li> </ul> <p>El m\u00e9todo split devuelve un arreglo: Cada elemento es una parte de la cadena original, no modifica la cadena original, adem\u00e1s de retornar un nuevo arreglo.</p>"},{"location":"javascript/metodos-de-extraccion/#dividir-una-cadena-con-un-separador-simple","title":"Dividir una cadena con un separador simple","text":"javascript<pre><code>const texto = \"manzana, pera, uva, mango\";\n\nconsole.log(texto.split(\", \")); // [\"manzana\", \"pera\", \"uva\", \"mango\"]\nconsole.log(texto.split(\", \", 2)); // [\"manzana\", \"pera\"]\n</code></pre> <p>Explicaci\u00f3n:</p> <ol> <li>En <code>texto.split(\", \")</code>, el separador <code>\", \"</code> indica que el texto debe dividirse donde aparecen comas seguidas de un espacio. Esto crea un array con cada fruta como un elemento separado.</li> <li>Con <code>texto.split(\", \", 2)</code>, se especifica un l\u00edmite de 2 elementos en el array resultante. El m\u00e9todo detiene la divisi\u00f3n despu\u00e9s de encontrar las dos primeras coincidencias del separador.</li> </ol>"},{"location":"javascript/metodos-de-extraccion/#dividir-sin-un-separador","title":"Dividir sin un separador","text":"<p>Si no se especifica un separador, el resultado ser\u00e1 un arreglo con la cadena completa como \u00fanico elemento:</p> javascript<pre><code>const texto = \"JavaScript es genial\";\nconst resultado = texto.split();\n\nconsole.log(resultado);\n</code></pre>"},{"location":"javascript/metodos-de-extraccion/#uso-con-expresiones-regulares","title":"Uso con Expresiones Regulares","text":"<p><code>split</code> tambi\u00e9n puede usar expresiones regulares como separadores, lo que lo hace muy flexible:</p> javascript<pre><code>const texto = \"JavaScript123Python456Ruby\";\n\nconsole.log(texto.split(/\\d+/)); // [\"JavaScript\", \"Python\", \"Ruby\"]\n</code></pre> <p>En este ejemplo, la expresi\u00f3n regular <code>/\\d+/</code> divide el string en cada secuencia de uno o m\u00e1s d\u00edgitos (<code>123</code>, <code>456</code>), elimin\u00e1ndolos del resultado.</p>"},{"location":"javascript/metodos-de-extraccion/#ventajas-de-split","title":"Ventajas de split()","text":"<ol> <li>Versatilidad: Compatible con separadores simples y patrones complejos.</li> <li>Facilidad de uso: Ideal para tareas como convertir texto en arreglos.</li> <li>Compatibilidad universal: Funciona en todos los navegadores y versiones modernas de JavaScript.</li> </ol>"},{"location":"javascript/metodos-de-extraccion/#diferencias-clave-entre-slice-substring-y-split","title":"Diferencias Clave Entre slice, substring y split","text":"<ol> <li>Prop\u00f3sito:<ul> <li><code>slice</code> y <code>substring</code> se usan para extraer una secci\u00f3n de un string.</li> <li><code>split</code> divide un string en partes y devuelve un array.</li> </ul> </li> <li>\u00cdndices Negativos:<ul> <li><code>slice</code> admite \u00edndices negativos, comenzando desde el final del string.</li> <li><code>substring</code> trata los \u00edndices negativos como <code>0</code>.</li> </ul> </li> <li>Orden de \u00cdndices:<ul> <li><code>substring</code> invierte los \u00edndices fuera de orden autom\u00e1ticamente.</li> <li><code>slice</code> no invierte \u00edndices; espera que est\u00e9n en el orden correcto.</li> </ul> </li> </ol>"},{"location":"javascript/metodos-de-extraccion/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los m\u00e9todos <code>slice</code>, <code>substring</code> y <code>split</code> son herramientas fundamentales para manipular strings en JavaScript. Cada uno tiene su prop\u00f3sito \u00fanico:</p> <ul> <li>Usa <code>slice</code> para trabajar con \u00edndices negativos o extraer partes espec\u00edficas.</li> <li>Prefiere <code>substring</code> cuando los \u00edndices pueden estar desordenados.</li> <li>Adopta <code>split</code> para convertir cadenas en arrays basados en separadores.</li> </ul> <p></p>"},{"location":"javascript/metodos-de-limpieza-string/","title":"M\u00e9todos de Limpieza en Strings","text":""},{"location":"javascript/metodos-de-limpieza-string/#metodos-de-limpieza-en-strings","title":"M\u00e9todos de Limpieza en Strings","text":"<p>Al trabajar con strings en JavaScript, es com\u00fan encontrarse con espacios en blanco al inicio o al final que pueden afectar validaciones, comparaciones y almacenamiento de datos. Para solucionar esto, JavaScript proporciona los m\u00e9todos de limpieza <code>trim()</code>, <code>trimStart()</code> y <code>trimEnd()</code> (tambi\u00e9n conocidos como <code>trimLeft()</code> y <code>trimRight()</code>). Estos m\u00e9todos ayudan a limpiar strings y mejorar la manipulaci\u00f3n de datos.</p> <p>En este art\u00edculo exploraremos estos m\u00e9todos, explicando sus diferencias, casos de uso y consideraciones importantes.</p>"},{"location":"javascript/metodos-de-limpieza-string/#elimina-espacios-al-inicio-y-al-final-de-un-string-trim","title":"Elimina Espacios al Inicio y al Final de un String: <code>trim</code>","text":"<p>El m\u00e9todo <code>trim()</code> se encarga de eliminar los espacios en blanco al principio y al final de un string o cadena de caracteres, sin modificar su contenido interno. Es \u00fatil en situaciones donde los usuarios ingresan datos con espacios adicionales, lo que puede generar problemas en validaciones y comparaciones.</p> javascript<pre><code>string.trim();\n</code></pre> <ul> <li>Retorna: Un nuevo string sin espacios en los extremos.</li> <li>No modifica el string original.</li> </ul> javascript<pre><code>const texto = \"   Hola, mundo!   \";\n\nconsole.log(texto.trim());\n</code></pre> <p>En el c\u00f3digo anterior vemos que los espacios antes y despu\u00e9s de <code>\"Hola, mundo!\"</code> son eliminados, dejando el contenido limpio.</p> <p>Caso de Uso: Un uso pr\u00e1ctico de <code>trim()</code> es en la validaci\u00f3n de formularios donde los usuarios pueden ingresar espacios innecesarios al principio o al final.</p> javascript<pre><code>function validarEntrada(entrada) {\n  return entrada.trim().length &gt; 0 ? \"Entrada v\u00e1lida\" : \"Campo vac\u00edo\";\n}\n\nconsole.log(validarEntrada(\"   Hola  \")); // \"Entrada v\u00e1lida\"\nconsole.log(validarEntrada(\"      \"));   // \"Campo vac\u00edo\"\n</code></pre> <p>En este caso, <code>trim()</code> evita que un string compuesto solo por espacios en blanco sea considerado v\u00e1lido.</p>"},{"location":"javascript/metodos-de-limpieza-string/#limpiar-strings-antes-de-almacenarlas","title":"Limpiar strings antes de almacenarlas","text":"<p>Tambi\u00e9n el m\u00e9todo <code>trim()</code> es utilizado para limpiar strings antes de almacenar el dato entrante en una base de datos. </p> javascript<pre><code>const datos = \"   Informaci\u00f3n importante   \";\nconst limpio = datos.trim();\n\nconsole.log(limpio); // \"Informaci\u00f3n importante\"\n</code></pre>"},{"location":"javascript/metodos-de-limpieza-string/#elimina-espacios-al-inicio-de-un-string-trimstart","title":"Elimina Espacios al Inicio de un String: <code>trimStart()</code>","text":"<p>El m\u00e9todo <code>trimStart()</code> elimina \u00fanicamente los espacios en blanco al inicio de un string, dejando intacto el resto del contenido. En versiones anteriores de JavaScript, este m\u00e9todo era conocido como <code>trimLeft()</code>, pero <code>trimStart()</code> es la forma recomendada en la actualidad.</p> javascript<pre><code>string.trimStart();\n</code></pre> <ul> <li>Retorna: Un nuevo string sin espacios al inicio.</li> <li>Alias funcional: <code>trimLeft()</code> realiza la misma operaci\u00f3n que <code>trimStart()</code>.</li> <li>No afecta los espacios al final del string.</li> </ul> javascript<pre><code>const texto = \"   Hola, mundo!   \";\n\nconsole.log(texto.trimStart());  // \"Hola, mundo!   \"\n</code></pre> <p>En el c\u00f3digo anterior vemos que solo los espacios al inicio han sido eliminados, pero los espacios al final permanecen.</p> <p>Caso de Uso: Supongamos que tenemos un sistema que almacena nombres de usuarios, y queremos evitar que los espacios al inicio afecten la organizaci\u00f3n de la base de datos.</p> javascript<pre><code>function limpiarNombre(nombre) {\n  return nombre.trimStart();\n}\n\nconsole.log(limpiarNombre(\"   Juan P\u00e9rez\")); function limpiarNombre(nombre) {\n  return nombre.trimStart();\n}\n\nconsole.log(limpiarNombre(\"            Juan P\u00e9rez\"));  // \"Juan P\u00e9rez\"\n</code></pre> <p>Esto es \u00fatil en escenarios donde los espacios iniciales pueden causar errores en b\u00fasquedas y ordenamientos.</p>"},{"location":"javascript/metodos-de-limpieza-string/#comparacion-con-trim","title":"Comparaci\u00f3n con trim()","text":"javascript<pre><code>const texto = \"   Hola Mundo   \";\n\nconsole.log(texto.trimStart()); // \"Hola Mundo   \"\nconsole.log(texto.trim());      // \"Hola Mundo\"\n</code></pre>"},{"location":"javascript/metodos-de-limpieza-string/#elimina-espacios-al-final-de-un-string-trimend","title":"Elimina Espacios al Final de un String: <code>trimEnd()</code>","text":"<p>El m\u00e9todo <code>trimEnd()</code> funciona de manera similar a <code>trimStart()</code>, pero en lugar de eliminar los espacios iniciales, elimina los espacios en blanco al final de un string. Anteriormente, se conoc\u00eda como <code>trimRight()</code>.</p> javascript<pre><code>string.trimEnd();\n</code></pre> <ul> <li>Elimina espacios al final: Los espacios al inicio permanecen intactos.</li> <li>Alias funcional: <code>trimRight()</code> realiza la misma operaci\u00f3n que <code>trimEnd()</code>.</li> <li>No modifica la cadena original: Devuelve una nueva cadena.</li> </ul> javascript<pre><code>const texto = \"   Hola, mundo!   \";\n\nconsole.log(texto.trimEnd());  // \"   Hola, mundo!\"\n</code></pre> <p>En el c\u00f3digo anterior vemos que los espacios al final son eliminados, pero los espacios al inicio permanecen.</p> <p>Caso de Uso: Imagina que trabajas con datos provenientes de una API y necesitas asegurar que los nombres de usuario no tengan espacios innecesarios al final.</p> javascript<pre><code>function limpiarTextoFinal(texto) {\n  return texto.trimEnd();\n}\n\nconsole.log(limpiarTextoFinal(\"Usuario123    \")); // \"Usuario123\"\n</code></pre> <p>Esto evita que los espacios adicionales al final interfieran con comparaciones o b\u00fasquedas en bases de datos.</p>"},{"location":"javascript/metodos-de-limpieza-string/#buenas-practicas-al-usar-metodos-de-limpieza-en-strings","title":"Buenas Pr\u00e1cticas al Usar M\u00e9todos de Limpieza en Strings","text":"<ul> <li>Usa <code>trim()</code> para limpiar entradas de usuario antes de almacenarlas en una base de datos.</li> <li>Emplea <code>trimStart()</code> cuando necesites eliminar solo los espacios iniciales, como en listas ordenadas.</li> <li>Prefiere <code>trimEnd()</code> para limpiar datos antes de comparaciones o validaciones.</li> <li>Recuerda que estos m\u00e9todos no afectan el string original, sino que devuelven una nueva versi\u00f3n modificada.</li> <li>En sistemas donde la normalizaci\u00f3n del texto es clave, combina estos m\u00e9todos con los metodos de M\u00e9todos de Transformaci\u00f3n de Caso para asegurar coherencia.</li> </ul>"},{"location":"javascript/metodos-de-limpieza-string/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los m\u00e9todos <code>trim()</code>, <code>trimStart()</code> y <code>trimEnd()</code> son importantes en la manipulaci\u00f3n de strings en JavaScript. No solo permiten limpiar espacios innecesarios, sino que tambi\u00e9n mejoran la precisi\u00f3n en validaciones, comparaciones y almacenamiento de datos.</p> <p>Estos m\u00e9todos son \u00fatiles en formularios, bases de datos y sistemas de procesamiento de texto, ayudando a evitar errores comunes causados por espacios en blanco invisibles.</p> <p></p>"},{"location":"javascript/metodos-de-reemplazo-string/","title":"M\u00e9todos de Reemplazo en Strings","text":""},{"location":"javascript/metodos-de-reemplazo-string/#metodos-de-reemplazo-en-strings","title":"M\u00e9todos de Reemplazo en Strings","text":"<p>Reemplazar texto en JavaScript es una operaci\u00f3n com\u00fan y poderosa que permite modificar strings para adaptarlas a diferentes necesidades. Los m\u00e9todos de reemplazo: <code>replace</code> y <code>replaceAll</code> son herramientas que nos son \u00fatiles para estas tareas, nos ofrecen flexibilidad y eficiencia en la manipulaci\u00f3n de cadenas de caracteres. A continuaci\u00f3n exploraremos c\u00f3mo funcionan, sus diferencias y casos de uso pr\u00e1cticos.</p>"},{"location":"javascript/metodos-de-reemplazo-string/#reemplaza-la-primera-ocurrencia-de-un-texto-replace","title":"Reemplaza la Primera Ocurrencia de un Texto: <code>replace()</code>","text":"<p>El m\u00e9todo <code>replace</code> sustituye la primera coincidencia de una subcadena o un patr\u00f3n en el string por otro texto especificado como par\u00e1metro en el m\u00e9todo. Es una soluci\u00f3n sencilla para modificaciones espec\u00edficas.</p> javascript<pre><code>string.replace(pattern, replacement);\n</code></pre> <ul> <li><code>pattern</code>: Puede ser un string o una expresi\u00f3n regular.</li> <li><code>replacement</code>: El texto que sustituir\u00e1 la coincidencia.</li> </ul> <p>El m\u00e9todo No modifica la cadena original y este retorna una nueva cadena con los reemplazos aplicados. Solo reemplaza la primera coincidencia si el <code>pattern</code> es una cadena o una expresi\u00f3n regular sin el modificador global (<code>g</code>). Puede reemplazar usando un texto est\u00e1tico o el resultado de una funci\u00f3n.</p>"},{"location":"javascript/metodos-de-reemplazo-string/#reemplazo-simple-con-cadenas","title":"Reemplazo simple con cadenas","text":"javascript<pre><code>const texto = \"JavaScript es divertido. Aprender JavaScript es \u00fatil.\";\nconst resultado = texto.replace(\"JavaScript\", \"Python\");\n\nconsole.log(resultado); // \"Python es divertido. Aprender JavaScript es \u00fatil.\"\n</code></pre> <p>Solo la primera aparici\u00f3n de <code>\"JavaScript\"</code> es reemplazada por <code>\"Python\"</code>. Las coincidencias posteriores no se ven afectadas.</p>"},{"location":"javascript/metodos-de-reemplazo-string/#uso-con-expresiones-regulares","title":"Uso con Expresiones Regulares","text":"<p>Cuando se utiliza una expresi\u00f3n regular como patr\u00f3n, puedes realizar reemplazos m\u00e1s flexibles:</p> javascript<pre><code>const texto = \"Aprender es divertido. Aprender JavaScript es \u00fatil.\";\nconst resultado = texto.replace(/aprender/i, \"Estudiar\");\n\nconsole.log(resultado); // \"Estudiar es divertido. Aprender JavaScript es \u00fatil.\"\n</code></pre> <p>La bandera <code>i</code> permite que el patr\u00f3n ignore may\u00fasculas y min\u00fasculas, reemplazando <code>\"Aprender\"</code> por <code>\"Estudiar\"</code>.</p>"},{"location":"javascript/metodos-de-reemplazo-string/#ejemplo-reemplazar-palabras-clave-en-una-descripcion-o-comentario","title":"Ejemplo: Reemplazar palabras clave en una descripci\u00f3n o comentario:","text":"javascript<pre><code>const comentario = \"El producto es caro y el env\u00edo es caro.\";\nconst actualizado = comentario.replace(\"caro\", \"costoso\");\n\nconsole.log(actualizado); // \"El producto es costoso y el env\u00edo es caro.\"\n</code></pre>"},{"location":"javascript/metodos-de-reemplazo-string/#ventajas-del-metodo-replace","title":"Ventajas del m\u00e9todo replace()","text":"<ol> <li>Flexibilidad: Soporta reemplazos est\u00e1ticos y din\u00e1micos.</li> <li>Compatibilidad con expresiones regulares: Lo hace poderoso para b\u00fasquedas y modificaciones avanzadas.</li> <li>Manejo din\u00e1mico: Usar funciones como reemplazo permite una l\u00f3gica compleja.</li> </ol>"},{"location":"javascript/metodos-de-reemplazo-string/#reemplaza-todas-las-ocurrencias-de-un-texto-replaceall","title":"Reemplaza Todas las Ocurrencias de un Texto: <code>replaceAll()</code>","text":"<p>El m\u00e9todo <code>replaceAll</code> es una versi\u00f3n extendida de <code>replace</code>, este fue dise\u00f1ado espec\u00edficamente para reemplazar todas las apariciones de un patr\u00f3n o subcadena en un string.</p> javascript<pre><code>string.replaceAll(pattern, replacement);\n</code></pre> <ul> <li><code>pattern</code>: Puede ser un string o una expresi\u00f3n regular con la bandera global (g).</li> <li><code>replacement</code>: El texto que sustituir\u00e1 todas las coincidencias.</li> </ul> <p>Este m\u00e9todo reemplaza todas las coincidencias de forma directa (no solo la primera como <code>replace()</code>). Permite el uso de cadenas o expresiones regulares globales como patr\u00f3n y No modifica la cadena original, sino que devuelve una nueva con los reemplazos aplicados.</p> <p>Es m\u00e1s legible y directo para reemplazos m\u00faltiples que <code>replace()</code> combinado con expresiones regulares globales.</p>"},{"location":"javascript/metodos-de-reemplazo-string/#reemplazo-simple-con-cadenas_1","title":"Reemplazo simple con cadenas","text":"javascript<pre><code>const text = \"Hola mundo, mundo hermoso\";\nconst newText = text.replaceAll(\"mundo\", \"JavaScript\");\n\nconsole.log(newText); // \"Hola JavaScript, JavaScript hermoso\"\n</code></pre>"},{"location":"javascript/metodos-de-reemplazo-string/#reemplazo-con-expresiones-regulares-globales","title":"Reemplazo con expresiones regulares globales","text":"<p>Aunque <code>replaceAll</code> no requiere el modificador <code>g</code>, puedes usarlo con expresiones regulares.</p> javascript<pre><code>const text = \"123-456-789\";\nconst newText = text.replaceAll(/\\d/g, \"*\");\n\nconsole.log(newText); // \"***-***-***\"\n</code></pre>"},{"location":"javascript/metodos-de-reemplazo-string/#caso-de-uso-limpiar-texto-de-caracteres-no-deseados","title":"Caso de Uso: Limpiar texto de caracteres no deseados:","text":"javascript<pre><code>const texto = \"123-456-7890\";\nconst limpio = texto.replaceAll(\"-\", \"\");\n\nconsole.log(limpio); // \"1234567890\"\n</code></pre> <p>Esto es \u00fatil en escenarios donde necesitas estandarizar n\u00fameros o datos formateados.</p>"},{"location":"javascript/metodos-de-reemplazo-string/#diferencias-clave-entre-replace-y-replaceall","title":"Diferencias Clave entre replace y replaceAll","text":"<ol> <li>Cantidad de Reemplazos:<ul> <li><code>replace</code> solo reemplaza la primera coincidencia.</li> <li><code>replaceAll</code> reemplaza todas las coincidencias.</li> </ul> </li> <li>Compatibilidad:<ul> <li><code>replace</code> es ampliamente compatible con todas las versiones modernas de JavaScript.</li> <li><code>replaceAll</code> fue introducido en ES2021, por lo que podr\u00eda no estar disponible en entornos m\u00e1s antiguos.</li> </ul> </li> <li>Uso con Expresiones Regulares:<ul> <li>Ambos m\u00e9todos funcionan con expresiones regulares, pero <code>replace</code> requiere expl\u00edcitamente la bandera global (<code>g</code>) para realizar m\u00faltiples reemplazos.</li> </ul> </li> </ol>"},{"location":"javascript/metodos-de-reemplazo-string/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los m\u00e9todos de reemplazo <code>replace</code> y <code>replaceAll</code> son herramientas imprescindibles para la manipulaci\u00f3n de strings en JavaScript. Mientras que <code>replace</code> es ideal para modificaciones puntuales, <code>replaceAll</code> simplifica el trabajo con m\u00faltiples coincidencias. Entender las diferencias entre ambos y c\u00f3mo aplicarlos correctamente te permitir\u00e1 escribir c\u00f3digo m\u00e1s eficiente y adaptable a diversas necesidades.</p> <p></p>"},{"location":"javascript/metodos-de-transformacion-caso-string/","title":"M\u00e9todos de Transformaci\u00f3n de Caso","text":""},{"location":"javascript/metodos-de-transformacion-caso-string/#metodos-de-transformacion-de-caso","title":"M\u00e9todos de Transformaci\u00f3n de Caso","text":"<p>Trabajar con cadenas de texto en JavaScript a menudo implica ajustar el formato de may\u00fasculas y min\u00fasculas para normalizar datos, validar entradas o mejorar la presentaci\u00f3n. Los m\u00e9todos de transformaci\u00f3n de caso: <code>toLowerCase</code>, <code>toUpperCase</code>, <code>toLocaleLowerCase</code> y <code>toLocaleUpperCase</code> proporcionan formas flexibles y eficaces de cambiar el caso de un string, tanto a nivel general como respetando configuraciones locales (locale).</p>"},{"location":"javascript/metodos-de-transformacion-caso-string/#conversion-a-minusculas-tolowercase","title":"Conversi\u00f3n a Min\u00fasculas: <code>toLowerCase</code>","text":"<p>El m\u00e9todo <code>toLowerCase()</code> convierte todos los caracteres de una cadena a min\u00fasculas. Es una herramienta est\u00e1ndar para normalizar texto antes de realizar comparaciones, b\u00fasquedas o formateos consistentes.</p> javascript<pre><code>string.toLowerCase();\n</code></pre> <ul> <li>Retorna: Un nuevo string con todos los caracteres en min\u00fasculas.</li> </ul> javascript<pre><code>const texto = \"JavaScript ES Incre\u00edble\";\n\nconsole.log(texto.toLowerCase());\n</code></pre> <p>El m\u00e9todo convierte cada car\u00e1cter de <code>\"JavaScript ES Incre\u00edble\"</code> a su equivalente en min\u00fasculas.</p>"},{"location":"javascript/metodos-de-transformacion-caso-string/#caracteristicas","title":"Caracter\u00edsticas","text":"<ol> <li>No modifica la cadena original: Devuelve una nueva cadena con los caracteres en min\u00fasculas.</li> <li>Case-insensitive: Facilita comparaciones ignorando diferencias entre may\u00fasculas y min\u00fasculas.</li> <li>Independiente del idioma: Sigue un comportamiento general para todas las configuraciones locales.</li> </ol> <p>Caso de Uso: Normalizar datos antes de compararlos.</p> javascript<pre><code>function compararCadenas(cadena1, cadena2) {\n  return cadena1.toLowerCase() === cadena2.toLowerCase();\n}\n\nconsole.log(compararCadenas(\"Hola\", \"hola\"));\n</code></pre>"},{"location":"javascript/metodos-de-transformacion-caso-string/#conversion-a-mayusculas-touppercase","title":"Conversi\u00f3n a May\u00fasculas: <code>toUpperCase</code>","text":"<p><code>toUpperCase</code> es el opuesto de <code>toLowerCase</code> transformando todos los caracteres de un string a may\u00fasculas. Es \u00fatil para formatear t\u00edtulos o validar texto sin importar el caso.</p> javascript<pre><code>string.toUpperCase();\n</code></pre> <ul> <li>Retorna: Un nuevo string con todos los caracteres en may\u00fasculas.</li> </ul> javascript<pre><code>const texto = \"JavaScript es incre\u00edble\";\n\nconsole.log(texto.toUpperCase());\n</code></pre> <p>El m\u00e9todo convierte cada car\u00e1cter de la cadena original a su equivalente en may\u00fasculas.</p>"},{"location":"javascript/metodos-de-transformacion-caso-string/#caracteristicas_1","title":"Caracter\u00edsticas","text":"<ol> <li>Devuelve una nueva cadena: No altera el valor original.</li> <li>Universal: Funciona para todas las configuraciones locales.</li> <li>\u00datil para normalizaci\u00f3n: Facilita comparaciones y formateos uniformes.</li> </ol> <p>Caso de Uso: Generar identificadores \u00fanicos o c\u00f3digos en formato est\u00e1ndar.</p> javascript<pre><code>function generarCodigo(nombre) {\n  return nombre.toUpperCase().slice(0, 5);\n}\n\nconsole.log(generarCodigo(\"javascript\")); \n</code></pre>"},{"location":"javascript/metodos-de-transformacion-caso-string/#minusculas-con-soporte-regional-tolocalelowercase","title":"Min\u00fasculas con Soporte Regional: <code>toLocaleLowerCase</code>","text":"<p>El m\u00e9todo <code>toLocaleLowerCase</code> es similar a <code>toLowerCase</code>, pero respeta configuraciones de idioma (locale) que pueden afectar c\u00f3mo se manejan ciertos caracteres. Esto es particularmente importante en idiomas como el turco, donde las reglas para convertir <code>\"I\"</code> a min\u00fasculas difieren del ingl\u00e9s.</p> javascript<pre><code>string.toLocaleLowerCase(locale);\n</code></pre> <ul> <li><code>locale</code> (opcional): Un string que representa el idioma o configuraci\u00f3n regional, como <code>\"en-US\"</code> o <code>\"tr-TR\"</code>.</li> <li>Retorna: Un nuevo string en min\u00fasculas ajustado seg\u00fan el locale.</li> </ul> <p>Ejemplo B\u00e1sico</p> javascript<pre><code>const texto = \"I\";\n\nconsole.log(texto.toLocaleLowerCase(\"en-US\")); // \"i\"\nconsole.log(texto.toLocaleLowerCase(\"tr-TR\")); // \"\u0131\"\n</code></pre> <p>En ingl\u00e9s, <code>\"I\"</code> se convierte a <code>\"i\"</code>. Sin embargo, en turco, <code>\"I\"</code> se convierte a <code>\"\u0131\"</code>, un car\u00e1cter distinto.</p>"},{"location":"javascript/metodos-de-transformacion-caso-string/#caracteristicas_2","title":"Caracter\u00edsticas","text":"<ol> <li>Respeto al idioma: Ideal para lenguajes con reglas particulares (por ejemplo, el turco).</li> <li>Devuelve una nueva cadena: No modifica la cadena original.</li> <li>Compatible con configuraciones regionales din\u00e1micas.</li> </ol> <p>Caso de Uso: Manejo de idiomas espec\u00edficos</p> javascript<pre><code>const texto = \"Istanbul\";\nconsole.log(texto.toLocaleLowerCase(\"tr-TR\")); // \"\u0131stanbul\"\n</code></pre> <p>En turco, la <code>I</code> may\u00fascula se convierte en <code>\u0131</code> (sin punto), lo cual no ocurre con <code>toLowerCase()</code></p> <p>El m\u00e9todo <code>toLocaleLowerCase()</code> es una versi\u00f3n mejorada de <code>toLowerCase()</code> para aplicaciones internacionales donde las reglas ling\u00fc\u00edsticas importan.</p>"},{"location":"javascript/metodos-de-transformacion-caso-string/#mayusculas-con-soporte-regional-tolocaleuppercase","title":"May\u00fasculas con Soporte Regional: <code>toLocaleUpperCase</code>","text":"<p><code>toLocaleUpperCase</code> funciona como <code>toUpperCase</code>, pero tambi\u00e9n respeta configuraciones locales para manejar caracteres especiales.</p> javascript<pre><code>string.toLocaleUpperCase(locale);\n</code></pre> <ul> <li><code>locale</code> (opcional): Un string que representa el idioma o configuraci\u00f3n regional.</li> <li>Retorna: Un nuevo string en may\u00fasculas ajustado seg\u00fan el locale.</li> </ul> <p>Ejemplo B\u00e1sico: Manejo de idiomas espec\u00edficos</p> javascript<pre><code>const texto = \"istanbul\";\nconsole.log(texto.toLocaleUpperCase(\"tr-TR\")); // \"\u0130STANBUL\"\n</code></pre> <p>En ingl\u00e9s, <code>\"i\"</code> se convierte a <code>\"I\"</code>, pero en turco, <code>\"i\"</code> se convierte a <code>\"\u0130\"</code>, un car\u00e1cter espec\u00edfico del idioma.</p> <p>El m\u00e9todo <code>toLocaleUpperCase()</code> garantiza que la conversi\u00f3n a may\u00fasculas sea precisa seg\u00fan las reglas del idioma, haci\u00e9ndolo esencial para aplicaciones multiling\u00fces.</p>"},{"location":"javascript/metodos-de-transformacion-caso-string/#caracteristicas_3","title":"Caracter\u00edsticas","text":"<ol> <li>Conversi\u00f3n espec\u00edfica del idioma: Respeta reglas regionales \u00fanicas (como en el turco).</li> <li>Devuelve una nueva cadena: No modifica la cadena original.</li> <li>Soporte para internacionalizaci\u00f3n.</li> </ol> <p>Caso de Uso: Formatear t\u00edtulos o encabezados seg\u00fan la regi\u00f3n del usuario.</p> javascript<pre><code>function formatearTitulo(titulo, locale) {\n  return titulo.toLocaleUpperCase(locale);\n}\n\nconsole.log(formatearTitulo(\"istanbul\", \"tr-TR\")); // \"\u0130STANBUL\"\n</code></pre>"},{"location":"javascript/metodos-de-transformacion-caso-string/#errores-comunes-y-como-evitarlos","title":"Errores Comunes y C\u00f3mo Evitarlos","text":"<ol> <li>Olvidar el Efecto de los Locales en <code>toLocaleLowerCase</code> y <code>toLocaleUpperCase</code>: Si no especificas un locale, se usar\u00e1 el predeterminado del entorno, lo que puede dar resultados inesperados en ciertos idiomas como el turco.</li> <li>No Diferenciar entre <code>toLowerCase</code> y <code>toLocaleLowerCase</code>: Si no trabajas con locales espec\u00edficos, <code>toLowerCase</code> es suficiente y m\u00e1s eficiente.</li> <li>Comparar Cadenas sin Normalizar el Caso: Siempre convierte las cadenas a un caso com\u00fan antes de compararlas para evitar errores por may\u00fasculas y min\u00fasculas.</li> </ol>"},{"location":"javascript/metodos-de-transformacion-caso-string/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los m\u00e9todos para cambiar el caso de strings en JavaScript son esenciales para manipular y normalizar texto:</p> <ul> <li>Usa <code>toLowerCase</code> y <code>toUpperCase</code> para operaciones generales de cambio de caso.</li> <li>Prefiere <code>toLocaleLowerCase</code> y <code>toLocaleUpperCase</code> cuando trabajes con configuraciones regionales que afecten caracteres espec\u00edficos.</li> </ul> <p>Con estos m\u00e9todos, puedes garantizar que tus cadenas sean consistentes y adecuadas para diferentes contextos y audiencias.</p> <p></p>"},{"location":"javascript/modulos-dinamicos/","title":"M\u00f3dulos Din\u00e1micos","text":""},{"location":"javascript/modulos-dinamicos/#modulos-dinamicos","title":"M\u00f3dulos Din\u00e1micos","text":"<p>Los m\u00f3dulos din\u00e1micos en JavaScript permiten cargar c\u00f3digo de manera as\u00edncrona durante la ejecuci\u00f3n, optimizando el rendimiento de las aplicaciones al reducir la carga inicial. Introducidos en ES2020, los m\u00f3dulos din\u00e1micos usan la funci\u00f3n <code>import()</code> para cargar m\u00f3dulos bajo demanda, haciendo que las aplicaciones sean m\u00e1s flexibles y eficientes.</p> <p>En este art\u00edculo exploraremos c\u00f3mo funcionan los m\u00f3dulos din\u00e1micos, sus casos de uso y las mejores pr\u00e1cticas para integrarlos en tus proyectos.</p>"},{"location":"javascript/modulos-dinamicos/#que-son-los-modulos-dinamicos","title":"\u00bfQu\u00e9 son los m\u00f3dulos din\u00e1micos?","text":"<p>Un m\u00f3dulo din\u00e1mico es un m\u00f3dulo que se carga en tiempo de ejecuci\u00f3n, en lugar de estar disponible desde el inicio de la aplicaci\u00f3n. Esto se logra usando la funci\u00f3n <code>import()</code>, que devuelve una promesa que se resuelve con el m\u00f3dulo cargado.</p>"},{"location":"javascript/modulos-dinamicos/#caracteristicas-clave","title":"Caracter\u00edsticas clave:","text":"<ol> <li>Carga as\u00edncrona: <code>import()</code> permite cargar m\u00f3dulos sin bloquear la ejecuci\u00f3n del programa.</li> <li>Flexibilidad: Puedes cargar m\u00f3dulos bajo ciertas condiciones o en respuesta a eventos.</li> <li>Optimizaci\u00f3n: Ayudan a reducir el tama\u00f1o inicial del bundle y a mejorar el tiempo de carga.</li> </ol>"},{"location":"javascript/modulos-dinamicos/#carga-dinamica-en-respuesta-a-un-evento","title":"Carga din\u00e1mica en respuesta a un evento","text":"<p>Supongamos que tenemos un m\u00f3dulo llamado <code>utilidades.js</code> que exporta una funci\u00f3n saludar. Este m\u00f3dulo solo se carga cuando el usuario hace clic en un bot\u00f3n.</p> <p>C\u00f3digo del m\u00f3dulo: Supongamos que tenemos un m\u00f3dulo <code>utilidades.js</code> que exporta una funci\u00f3n <code>saludar</code>:</p> javascript<pre><code>// utilidades.js\nexport default function saludar(nombre) {\n    return `Hola, ${nombre}!`;\n}\n</code></pre> <p>Integraci\u00f3n din\u00e1mica: La funci\u00f3n <code>import()</code> tiene una sintaxis similar a la palabra clave <code>import</code>, pero en lugar de ejecutarse de forma est\u00e1tica, se utiliza de manera din\u00e1mica en tiempo de ejecuci\u00f3n.</p> javascript<pre><code>// app.js\ndocument.querySelector('#botonCargar').addEventListener('click', async () =&gt; {\n    try {\n        const modulo = await import('./utilidades.js');\n        const mensaje = modulo.default('Carlos');\n        document.body.innerHTML = `&lt;p&gt;${mensaje}&lt;/p&gt;`;\n    } catch (error) {\n        document.body.innerHTML = `&lt;p&gt;Error al cargar el m\u00f3dulo: ${error.message}&lt;/p&gt;`;\n    }\n});\n</code></pre>"},{"location":"javascript/modulos-dinamicos/#casos-de-uso-de-los-modulos-dinamicos","title":"Casos de uso de los m\u00f3dulos din\u00e1micos","text":"<ol> <li>Carga Condicional: Cargar m\u00f3dulos solo si se cumplen ciertas condiciones es una pr\u00e1ctica com\u00fan en aplicaciones donde no todos los m\u00f3dulos son necesarios en todos los contextos.</li> </ol> javascript<pre><code>if (usuarioAutenticado) {\n    import('./moduloPrivado.js').then(modulo =&gt; {\n        modulo.mostrarPanelPrivado();\n    });\n}\n</code></pre> <ol> <li>Mejorar el Rendimiento (Lazy Loading): En aplicaciones grandes se pueden cargar m\u00f3dulos din\u00e1micamente para evitar que todo el c\u00f3digo se cargue en el inicio, lo que mejora el tiempo de carga inicial.</li> </ol> javascript<pre><code>document.querySelector('#botonGraficos').addEventListener('click', async () =&gt; {\n    const moduloGraficos = await import('./graficos.js');\n    moduloGraficos.renderizar();\n});\n</code></pre> <ol> <li>Localizaci\u00f3n y Soporte de Idiomas: Para aplicaciones multiling\u00fces, los m\u00f3dulos din\u00e1micos permiten cargar traducciones espec\u00edficas seg\u00fan el idioma seleccionado:</li> </ol> javascript<pre><code>async function cargarTraducciones(idioma) {\n    try {\n        const traducciones = await import(`./locales/${idioma}.js`);\n        document.body.innerHTML = `&lt;p&gt;${traducciones.default.mensajeBienvenida}&lt;/p&gt;`;\n    } catch (error) {\n        document.body.innerHTML = `&lt;p&gt;Error al cargar traducciones: ${error.message}&lt;/p&gt;`;\n    }\n}\ncargarTraducciones('es');\n</code></pre>"},{"location":"javascript/modulos-dinamicos/#ventajas-de-los-modulos-dinamicos","title":"Ventajas de los m\u00f3dulos din\u00e1micos","text":"<ol> <li>Rendimiento mejorado: Reduce el tiempo de carga inicial al dividir el c\u00f3digo en fragmentos.</li> <li>Flexibilidad: Carga m\u00f3dulos espec\u00edficos en funci\u00f3n de eventos o condiciones.</li> <li>Integraci\u00f3n con promesas: <code>import()</code> devuelve una promesa, lo que facilita su integraci\u00f3n con otras operaciones as\u00edncronas.</li> </ol>"},{"location":"javascript/modulos-dinamicos/#limitaciones-de-los-modulos-dinamicos","title":"Limitaciones de los m\u00f3dulos din\u00e1micos","text":"<ol> <li>Compatibilidad de navegadores: Los m\u00f3dulos din\u00e1micos son compatibles con navegadores modernos, pero pueden requerir polyfills para navegadores antiguos.</li> <li>No est\u00e1ticos: Al no estar presentes en tiempo de compilaci\u00f3n, algunas herramientas de an\u00e1lisis de c\u00f3digo pueden no detectarlos.</li> <li>Errores en la carga: Es fundamental manejar errores correctamente, ya que problemas de red o rutas incorrectas pueden interrumpir la carga del m\u00f3dulo.</li> </ol>"},{"location":"javascript/modulos-dinamicos/#buenas-practicas-al-usar-modulos-dinamicos","title":"Buenas pr\u00e1cticas al usar m\u00f3dulos din\u00e1micos","text":"<ul> <li>Organizaci\u00f3n clara: Mant\u00e9n los m\u00f3dulos organizados en carpetas espec\u00edficas para facilitar su localizaci\u00f3n.</li> <li>Manejo de errores: Siempre utiliza bloques <code>.catch()</code> o <code>try/catch</code> para manejar errores al cargar m\u00f3dulos.</li> <li>Uso estrat\u00e9gico: Utiliza m\u00f3dulos din\u00e1micos para funcionalidades no cr\u00edticas que puedan cargarse de manera diferida.</li> <li>Evita abusar de <code>import()</code>: Aunque \u00fatil, no todo debe cargarse din\u00e1micamente. Equilibra entre m\u00f3dulos est\u00e1ticos y din\u00e1micos seg\u00fan las necesidades.</li> </ul>"},{"location":"javascript/modulos-dinamicos/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los m\u00f3dulos din\u00e1micos en JavaScript ofrecen una forma poderosa de optimizar el rendimiento de aplicaciones modernas al cargar c\u00f3digo de manera as\u00edncrona y bajo demanda. Al usarlos de forma estrat\u00e9gica, puedes mejorar la eficiencia y flexibilidad de tus proyectos.</p> <p>En el siguiente art\u00edculo exploraremos Top-level Await en JavaScript, una funcionalidad que permite usar <code>await</code> directamente en el nivel superior de los m\u00f3dulos.</p> <p></p>"},{"location":"javascript/modulos/","title":"Introducci\u00f3n a los M\u00f3dulos","text":""},{"location":"javascript/modulos/#introduccion-a-los-modulos","title":"Introducci\u00f3n a los M\u00f3dulos","text":"<p>Los m\u00f3dulos en JavaScript son fundamentales para organizar y estructurar c\u00f3digo de manera eficiente en aplicaciones modernas. Dividir el c\u00f3digo en m\u00f3dulos permite gestionar funcionalidades espec\u00edficas de forma independiente, facilitando el mantenimiento, la escalabilidad y la colaboraci\u00f3n en equipos de desarrollo.</p>"},{"location":"javascript/modulos/#que-son-los-modulos-en-javascript","title":"\u00bfQu\u00e9 son los m\u00f3dulos en JavaScript?","text":"<p>Un m\u00f3dulo en JavaScript es un archivo que contiene c\u00f3digo reutilizable como variables, funciones o clases. Al usar m\u00f3dulos, puedes separar la l\u00f3gica en fragmentos manejables que pueden importarse y exportarse entre archivos. Esto mejora la organizaci\u00f3n del c\u00f3digo y evita conflictos al proporcionar un \u00e1mbito privado para cada m\u00f3dulo.</p> <p>Antes de la introducci\u00f3n de los m\u00f3dulos ES6, se usaban sistemas como CommonJS (Node.js) y AMD (navegadores) para manejar la modularidad. Los m\u00f3dulos ES6 estandarizan esta funcionalidad y son compatibles con navegadores modernos.</p> <p>Los m\u00f3dulos permiten:</p> <ul> <li>Reutilizaci\u00f3n: Puedes compartir y reutilizar funcionalidades en diferentes partes de tu aplicaci\u00f3n.</li> <li>Encapsulaci\u00f3n: Las variables y funciones de un m\u00f3dulo est\u00e1n protegidas en su propio \u00e1mbito.</li> <li>Carga optimizada: Los m\u00f3dulos se cargan de forma as\u00edncrona, mejorando el rendimiento de la aplicaci\u00f3n.</li> </ul>"},{"location":"javascript/modulos/#exportar-codigo","title":"Exportar c\u00f3digo","text":"<p>Para que un m\u00f3dulo comparta funcionalidades, debes usar la palabra clave <code>export</code>. Hay dos tipos principales de exportaciones:</p> <ol> <li>Exportaci\u00f3n nombrada: Permite exportar m\u00faltiples elementos desde un m\u00f3dulo, y cada elemento debe ser importado usando su nombre exacto.</li> </ol> javascript<pre><code>// archivo.js\nexport const PI = 3.1416;\n\nexport function calcularArea(radio) {\n    return PI * radio * radio;\n}\n</code></pre> <ol> <li>Exportaci\u00f3n por defecto: Permite exportar un solo elemento como predeterminado, lo que simplifica su importaci\u00f3n.</li> </ol> javascript<pre><code>// archivo.js\nexport default function saludo() {\n    return \"Hola, M\u00f3dulos!\";\n}\n</code></pre>"},{"location":"javascript/modulos/#importar-codigo","title":"Importar c\u00f3digo","text":"<p>La palabra clave <code>import</code> se utiliza para traer funcionalidades de otros m\u00f3dulos. Puedes importar elementos espec\u00edficos (exportaci\u00f3n nombrada) o el elemento principal (exportaci\u00f3n por defecto).</p> javascript<pre><code>// importar.js\nimport saludo from './archivo.js'; // Exportaci\u00f3n por defecto\nimport { PI, calcularArea } from './archivo.js'; // Exportaci\u00f3n nombrada\n\nsaludo(); // \"Hola, M\u00f3dulos!\"\ncalcularArea(5); // 78.54\n</code></pre>"},{"location":"javascript/modulos/#configuracion-basica-en-html","title":"Configuraci\u00f3n b\u00e1sica en HTML","text":"<p>Para usar m\u00f3dulos en un entorno web es necesario configurar correctamente los archivos HTML para que el navegador pueda interpretar las importaciones y exportaciones. Esto se logra utilizando el atributo <code>type=\"module\"</code> en la etiqueta <code>&lt;script&gt;</code>.</p> html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;title&gt;M\u00f3dulos en JavaScript&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;!--contenido --&gt;\n  &lt;!--contenido --&gt;\n  &lt;script type=\"module\" src=\"app.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Notas Importantes:</p> <ul> <li>Origen seguro: Los m\u00f3dulos deben servirse desde un servidor HTTP o HTTPS. Si intentas cargarlos localmente (con <code>file://</code>), navegadores como Chrome bloquear\u00e1n las importaciones.</li> <li>Compatibilidad: Los m\u00f3dulos ES6 son compatibles con la mayor\u00eda de los navegadores modernos, pero es recomendable verificar el soporte en los navegadores objetivo.</li> </ul>"},{"location":"javascript/modulos/#caracteristicas-clave-de-los-modulos-en-javascript","title":"Caracter\u00edsticas clave de los m\u00f3dulos en JavaScript","text":"<ol> <li>Modo estricto por defecto: Los m\u00f3dulos se ejecutan autom\u00e1ticamente en strict mode, ayudando a evitar errores comunes.</li> <li>\u00c1mbito privado: Las variables y funciones declaradas en un m\u00f3dulo no son accesibles fuera de \u00e9l, a menos que se exporten expl\u00edcitamente.</li> <li>Carga diferida: Los m\u00f3dulos se cargan de manera as\u00edncrona y solo cuando son necesarios, mejorando el rendimiento.</li> </ol> <p>Como mencionamos anteriormente, cada m\u00f3dulo en JavaScript tiene su propio \u00e1mbito, lo que significa que las variables, funciones y clases definidas en un m\u00f3dulo no son visibles fuera de \u00e9l a menos que se exporten. Esto ayuda a mantener un c\u00f3digo m\u00e1s seguro y a evitar conflictos de nombres.</p> javascript<pre><code>// archivo.js\nconst secreto = \"Esto es privado\";\nexport const publico = \"Esto es p\u00fablico\";\n</code></pre> <p>En este caso, la variable <code>secreto</code> no es accesible desde otros archivos, ya que no se exporta.</p>"},{"location":"javascript/modulos/#beneficios-de-usar-modulos","title":"Beneficios de usar m\u00f3dulos","text":"<p>Los m\u00f3dulos aportan varias ventajas significativas al desarrollo de aplicaciones en JavaScript:</p> <ol> <li>Estructura clara y organizada: Al dividir tu aplicaci\u00f3n en m\u00f3dulos, cada archivo puede enfocarse en una funcionalidad espec\u00edfica, como manejar usuarios o interactuar con una API.</li> <li>Prevenci\u00f3n de conflictos de nombres: Las variables y funciones en un m\u00f3dulo no interfieren con las de otros archivos.</li> <li>Reutilizaci\u00f3n de c\u00f3digo: Puedes importar funciones, objetos o clases en cualquier parte de tu aplicaci\u00f3n o incluso entre proyectos.</li> <li>Escalabilidad: Los m\u00f3dulos facilitan el trabajo en equipo al permitir que varios desarrolladores trabajen en diferentes partes de la aplicaci\u00f3n sin interferencias.</li> </ol>"},{"location":"javascript/modulos/#restricciones-de-los-modulos-en-javascript","title":"Restricciones de los m\u00f3dulos en JavaScript","text":"<p>Aunque los m\u00f3dulos son muy \u00fatiles, tienen algunas limitaciones:</p> <ul> <li>Origen seguro: Deben cargarse desde un servidor.</li> <li>Extensi\u00f3n <code>.mjs</code> en Node.js: Aunque los m\u00f3dulos ES6 funcionan en Node.js, es com\u00fan usar la extensi\u00f3n <code>.mjs</code> para diferenciarlos de los m\u00f3dulos CommonJS.</li> <li>Una sola exportaci\u00f3n por defecto: Un m\u00f3dulo puede tener solo una exportaci\u00f3n por defecto, aunque puede incluir m\u00faltiples exportaciones nombradas.</li> </ul>"},{"location":"javascript/modulos/#buenas-practicas-al-trabajar-con-modulos","title":"Buenas pr\u00e1cticas al trabajar con m\u00f3dulos","text":"<ul> <li>Nombra tus m\u00f3dulos descriptivamente: Usa nombres que reflejen claramente el prop\u00f3sito del m\u00f3dulo.</li> <li>Organiza por funcionalidades: Divide tu c\u00f3digo en m\u00f3dulos basados en \u00e1reas espec\u00edficas, como <code>usuarios.js</code> o <code>productos.js</code>.</li> <li>Usa exportaciones por defecto para componentes principales: Exporta como predeterminada la funcionalidad m\u00e1s importante del m\u00f3dulo y usa exportaciones nombradas para elementos secundarios.</li> <li>Evita dependencias circulares: Dise\u00f1a tus m\u00f3dulos para que no se necesiten entre s\u00ed de manera circular, ya que esto puede causar errores.</li> </ul>"},{"location":"javascript/modulos/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los m\u00f3dulos en JavaScript son esenciales para estructurar y organizar c\u00f3digo en aplicaciones modernas. Gracias a las exportaciones e importaciones, puedes crear proyectos modulares y escalables con facilidad. Su capacidad de encapsulaci\u00f3n y su compatibilidad con navegadores modernos los convierten en una herramienta indispensable para cualquier desarrollador.</p> <p>En el siguiente art\u00edculo profundizaremos en Exportaci\u00f3n en JavaScript, donde exploraremos c\u00f3mo exportar variables, funciones y clases de un m\u00f3dulo para que sean accesibles en otros archivos.</p> <p></p>"},{"location":"javascript/numeros/","title":"Los N\u00fameros","text":""},{"location":"javascript/numeros/#los-numeros","title":"Los N\u00fameros","text":"<p>En JavaScript el tipo de dato <code>number</code> se utiliza para representar tanto n\u00fameros enteros como decimales. Este tipo de dato es fundamental en la programaci\u00f3n, ya que permite realizar operaciones matem\u00e1ticas, trabajar con c\u00e1lculos precisos y manejar valores especiales como <code>NaN</code>, <code>Infinity</code> y <code>-Infinity</code>.</p>"},{"location":"javascript/numeros/#que-son-los-numeros-en-javascript","title":"\u00bfQu\u00e9 son los n\u00fameros en JavaScript?","text":"<p>JavaScript utiliza un solo tipo de dato num\u00e9rico (<code>number</code>) para representar todos los n\u00fameros, ya sean enteros o de punto flotante. A diferencia de otros lenguajes que tienen tipos distintos para enteros y decimales, JavaScript trata todos los n\u00fameros de la misma manera.</p> <p>T\u00e9cnicamente utiliza el formato IEEE-754 para el tipo de dato <code>number</code>, que cubre tanto enteros como valores de punto flotante. Sin embargo, con la especificaci\u00f3n ES2020, se introdujo el tipo \u201cbigint\u201d para manejar enteros grandes, lo que proporciona una mayor flexibilidad en el manejo de valores num\u00e9ricos en JavaScript.</p>"},{"location":"javascript/numeros/#numeros-enteros","title":"N\u00fameros Enteros","text":"<p>A continuaci\u00f3n se muestra c\u00f3mo declarar una variable que contiene un n\u00famero entero decimal:</p> javascript<pre><code>const counter = 100;\n</code></pre> <p>Los n\u00fameros enteros se pueden representar en los siguientes formatos:</p> <ul> <li>Octal (base 8)</li> <li>Hexadecimal (basado en 16)</li> </ul> <p>Cuando utiliza n\u00fameros octales y hexadecimales en operaciones aritm\u00e9ticas, JavaScript los trata como n\u00fameros decimales.</p>"},{"location":"javascript/numeros/#numeros-octales","title":"N\u00fameros Octales","text":"<p>Un n\u00famero literal octal comienza con el d\u00edgito cero (0) seguido de una secuencia de d\u00edgitos octales (n\u00fameros del 0 al 7). Por ejemplo:</p> javascript<pre><code>const num = 071;\nconsole.log(num);\n</code></pre> <p>Si un n\u00famero octal contiene un n\u00famero que no est\u00e1 en el rango de 0 a 7, el motor de JavaScript ignora el 0 y trata el n\u00famero como un decimal. Por ejemplo:</p> javascript<pre><code>const num = 080;\nconsole.log(num);\n</code></pre> <p>Este comportamiento impl\u00edcito podr\u00eda causar problemas. Por tal raz\u00f3n ES6 introdujo un nuevo literal octal que comienza con <code>0o</code> seguido de una secuencia de d\u00edgitos octales (de 0 a 7). Por ejemplo:</p> javascript<pre><code>const num = 0o71;\nconsole.log(num);\n</code></pre>"},{"location":"javascript/numeros/#numeros-hexadecimales","title":"N\u00fameros Hexadecimales","text":"<p>Los n\u00fameros hexadecimales comienzan con 0x o 0X seguidos de cualquier n\u00famero de d\u00edgitos hexadecimales (del 0 al 9 y de la a a la f). Por ejemplo:</p> javascript<pre><code>const num = 0x1a;\nconsole.log(num);\n</code></pre>"},{"location":"javascript/numeros/#numeros-de-punto-flotante","title":"N\u00fameros de Punto Flotante","text":"<p>Para definir un n\u00famero literal de punto flotante, se agrega un punto decimal seguido de al menos un n\u00famero. Por ejemplo:</p> javascript<pre><code>const price = 9.99;\nconst tax = 0.08;\nconst discount = .05; // valido pero no recomendable\n</code></pre> <p>Cuando trabajas con n\u00fameros muy grandes puedes usar la notaci\u00f3n cient\u00edfica. La notaci\u00f3n E indica que un n\u00famero se multiplica por 10 elevado a una potencia espec\u00edfica.</p> javascript<pre><code>const amount = 3.14e7;\nconsole.log(amount);\n</code></pre> <p>La notaci\u00f3n <code>3.14e7</code> significa que se toma <code>3.14</code> y se multiplica por .<code>10</code><sup><code>7</code></sup></p> <p>Asimismo puedes utilizar la notaci\u00f3n E para representar un n\u00famero muy peque\u00f1o.</p> javascript<pre><code>const amount = 5e-7; \nconsole.log(amount); // 0.0000005\n</code></pre> <p>La notaci\u00f3n <code>5e-7</code> significa que se toma <code>5</code> y se divide entre <code>10.000.000</code>.</p> <p>Adem\u00e1s, JavaScript convierte autom\u00e1ticamente cualquier n\u00famero de punto flotante con al menos seis ceros despu\u00e9s del punto decimal en notaci\u00f3n electr\u00f3nica. Por ejemplo:</p> javascript<pre><code>const amount = 0.0000005;\nconsole.log(amount);\n</code></pre> <p>Los n\u00fameros de punto flotante tienen una precisi\u00f3n de hasta 17 decimales. Cuando realiza operaciones aritm\u00e9ticas con n\u00fameros de punto flotante a menudo obtiene el resultado aproximado.</p>"},{"location":"javascript/numeros/#trabajar-con-el-constructor-number","title":"Trabajar con el Constructor <code>Number()</code>","text":"<p>Los valores num\u00e9ricos en JavaScript se pueden crear usando su forma literal o con el constructor incorporado <code>Number()</code>. Puedes crear un objeto <code>Number</code> usando la palabra clave <code>new</code>, por ejemplo: <code>new Number(123)</code>. Sin embargo esto no es com\u00fan, ya que los objetos <code>Number</code> no son primitivos y pueden causar confusi\u00f3n.</p> <p>Una vez creado un valor num\u00e9rico, podemos realizar operaciones aritm\u00e9ticas como sumas (<code>+</code>), restas (<code>-</code>), multiplicaciones (<code>*</code>) y divisiones (<code>/</code>). Adem\u00e1s de la aritm\u00e9tica b\u00e1sica, JavaScript admite una gran variedad de funciones matem\u00e1ticas, <code>como Math.abs()</code>, <code>Math.pow()</code> y <code>Math.round()</code>, que se pueden utilizar para realizar operaciones m\u00e1s complejas.</p>"},{"location":"javascript/numeros/#conversion-a-primitivos-numericos","title":"Conversi\u00f3n a Primitivos Num\u00e9ricos:","text":"<p>M\u00e1s com\u00fanmente, <code>Number()</code> se utiliza como una funci\u00f3n para convertir valores a primitivos num\u00e9ricos. Por ejemplo, <code>Number(\"123\")</code> convierte el string <code>\"123\"</code> en el n\u00famero primitivo <code>123</code>.</p> javascript<pre><code>const stringToNumber = Number(\"123\")\nconsole.log(stringToNumber)\n</code></pre>"},{"location":"javascript/numeros/#diferencias-entre-objeto-y-primitivo","title":"Diferencias Entre Objeto y Primitivo:","text":"<p>Un objeto <code>Number</code> (<code>new Number(123)</code>) y un primitivo num\u00e9rico (<code>Number(\"123\")</code>) son diferentes, el primero es un objeto y el segundo es un primitivo. Esto se puede verificar usando <code>typeof</code></p> javascript<pre><code>const number1 = new Number(123);\nconst number2 = Number(\"123\");\n\nconsole.log(typeof number1);\nconsole.log(typeof number2);\n</code></pre>"},{"location":"javascript/numeros/#number-y-bigint","title":"<code>Number()</code> y <code>BigInt</code>","text":"<p>Cuando utilizas la funci\u00f3n <code>Number()</code> para convertir un <code>BigInt</code> a un n\u00famero, no se produce un error. Sin embargo, es importante tener en cuenta que puede haber p\u00e9rdida de precisi\u00f3n si el <code>BigInt</code> es demasiado grande.</p>"},{"location":"javascript/numeros/#comparacion-de-valores-numericos","title":"Comparaci\u00f3n de valores num\u00e9ricos","text":"<p>En JavaScript, los valores num\u00e9ricos tambi\u00e9n se pueden comparar utilizando operadores de comparaci\u00f3n como <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> y <code>&gt;=</code>. Por ejemplo, el siguiente c\u00f3digo comprueba si la variable <code>num</code> es menor que 50:</p> javascript<pre><code>const num = 40;\n\nif (num &lt; 50) {\n console.log(\"El n\u00famero es menor que 50\");\n}\n</code></pre> <p>M\u00e9todos y Propiedades \u00datiles:</p> <ul> <li><code>Number.isNaN()</code>: Determina si el valor es NaN (Not a Number) o No se un numero.</li> <li><code>Number.isFinite()</code>: Determina si el valor es finito.</li> <li><code>Number.isInteger()</code>: Determina si un valor es un entero.</li> <li><code>Number.MAX_SAFE_INTEGER</code>: El m\u00e1ximo entero seguro en JavaScript.</li> <li><code>Number.MIN_SAFE_INTEGER</code>: El m\u00ednimo entero seguro en JavaScript.</li> </ul>"},{"location":"javascript/numeros/#infinity","title":"Infinity","text":"<p>En JavaScript, <code>Infinity</code> es un valor especial que representa n\u00fameros que son demasiado grandes para ser manejados por el lenguaje. El n\u00famero m\u00e1s grande que JavaScript puede manejar es <code>1.7976931348623157e+308</code>.</p> javascript<pre><code>const hugeNumber = 2e308;\nconsole.log(hugeNumber);\n</code></pre> <p>Tambi\u00e9n hay un valor <code>-Infinity</code>, que se usa para n\u00fameros negativos que van por debajo de <code>-1.7976931348623157e+308</code></p> javascript<pre><code>const hugeNumber = -2e308;\nconsole.log(hugeNumber);\n</code></pre> <p>El valor de infinito tambi\u00e9n se puede obtener al dividir entre cero.</p> javascript<pre><code>let result = 10 / 0;\nconsole.log(result);\n</code></pre>"},{"location":"javascript/numeros/#nan","title":"NaN","text":"<p><code>NaN</code> es un valor de error que significa \u201cNot a Number\u201c. Se utiliza cuando se intenta realizar una operaci\u00f3n y el resultado no es un valor num\u00e9rico. Por ejemplo: Como cuando intentas multiplicar un string por un n\u00famero, por ejemplo.</p> javascript<pre><code>const result = \"Hola\" * 5;\nconsole.log(result);\n</code></pre> <p>Pero\u2026 el resultado devuelto por el operador <code>typeof</code> para <code>NaN</code>. Algo curioso que debemos tener en cuenta.</p> javascript<pre><code>console.log(typeof NaN);\n</code></pre>"},{"location":"javascript/numeros/#redondear-y-dar-formato-a-los-numeros","title":"Redondear y dar formato a los n\u00fameros","text":"<p>JavaScript proporciona varias funciones para redondear y dar formato a los valores num\u00e9ricos. La funci\u00f3n <code>toFixed()</code> puede utilizarse para redondear un n\u00famero a un n\u00famero especificado de decimales. Por ejemplo, el siguiente c\u00f3digo redondea la variable n\u00famero a dos decimales:</p> javascript<pre><code>const number = 1.23456;\nconst roundedNumber = number.toFixed(2);\n\nconsole.log(roundedNumber); \n</code></pre> <p>En temas m\u00e1s avanzados, exploraremos en detalle las diversas propiedades disponibles para el tipo <code>number</code> en JavaScript.</p>"},{"location":"javascript/numeros/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los n\u00fameros en JavaScript ofrecen una amplia gama de funcionalidades para realizar operaciones matem\u00e1ticas, trabajar con valores especiales y manejar grandes cantidades con precisi\u00f3n. Comprender sus particularidades y las herramientas disponibles es esencial para el desarrollo de aplicaciones robustas.</p> <p>En el siguiente art\u00edculo exploraremos los valores booleanos en JavaScript, abordando su importancia en las condiciones y la l\u00f3gica de programaci\u00f3n.</p> <p></p>"},{"location":"javascript/objetos/","title":"Introducci\u00f3n a los Objetos","text":""},{"location":"javascript/objetos/#introduccion-a-los-objetos","title":"Introducci\u00f3n a los Objetos","text":"<p>En JavaScript, los objetos son una de las estructuras de datos m\u00e1s importantes y vers\u00e1tiles. Permiten almacenar m\u00faltiples valores bajo una misma entidad, lo que facilita la organizaci\u00f3n y manipulaci\u00f3n de datos complejos. Los objetos se utilizan para representar entidades del mundo real y sus caracter\u00edsticas como propiedades y comportamientos.</p> <p>En este art\u00edculo exploraremos los conceptos fundamentales de los objetos en JavaScript, incluyendo c\u00f3mo crear, acceder y modificar sus propiedades.</p>"},{"location":"javascript/objetos/#que-es-un-objeto-en-javascript","title":"\u00bfQu\u00e9 es un Objeto en JavaScript?","text":"<p>Un objeto en JavaScript es una colecci\u00f3n de pares clave-valor, donde cada clave (tambi\u00e9n llamada propiedad) es un identificador \u00fanico asociado a un valor. Los valores pueden ser de cualquier tipo v\u00e1lido en JavaScript, incluyendo n\u00fameros, cadenas de texto, booleanos, funciones e incluso otros objetos.</p> <p>Los objetos permiten agrupar informaci\u00f3n relacionada en una sola estructura, lo que resulta \u00fatil para representar entidades complejas del mundo real. Por ejemplo, puedes usar un objeto para modelar las caracter\u00edsticas de una persona, como su nombre, edad y g\u00e9nero o las propiedades de un auto, como su marca, modelo y a\u00f1o.</p> <p>Ejemplo de un Objeto B\u00e1sico:</p> javascript<pre><code>const persona = {\n  nombre: \"Juan\",\n  edad: 30,\n  esEstudiante: true\n};\n</code></pre> <p>En este ejemplo <code>persona</code> es un objeto con tres propiedades: <code>nombre</code>, <code>edad</code> y <code>esEstudiante</code>. Cada propiedad tiene un nombre \u00fanico y un valor asociado.</p>"},{"location":"javascript/objetos/#creacion-de-objetos-en-javascript","title":"Creaci\u00f3n de Objetos en JavaScript","text":"<p>Hay varias formas de crear objetos en JavaScript, siendo las m\u00e1s comunes la notaci\u00f3n literal y el uso del constructor <code>Object()</code>. Elegir un m\u00e9todo u otro depende del caso de uso y de las preferencias del desarrollador.</p>"},{"location":"javascript/objetos/#1-notacion-literal","title":"1. Notaci\u00f3n Literal","text":"<p>La forma m\u00e1s com\u00fan y sencilla de crear un objeto es utilizando la notaci\u00f3n literal, que consiste en definir el objeto directamente entre llaves <code>{}</code> con sus pares clave-valor. Este m\u00e9todo es ideal cuando se conoce de antemano la estructura del objeto.</p> javascript<pre><code>const auto = {\n  marca: \"Toyota\",\n  modelo: \"Corolla\",\n  anio: 2022\n};\n</code></pre> <p>En el snippet anterior se crea el objeto <code>auto</code> con tres propiedades: <code>marca</code>, <code>modelo</code> y <code>anio</code>. La notaci\u00f3n literal es concisa y f\u00e1cil de leer, por lo que es la opci\u00f3n preferida en la mayor\u00eda de los casos.</p>"},{"location":"javascript/objetos/#2-uso-del-constructor-object","title":"2. Uso del Constructor <code>Object()</code>","text":"<p>El constructor <code>Object()</code> es otra forma de crear objetos, aunque no es tan utilizada como la notaci\u00f3n literal. Es \u00fatil cuando se necesita crear un objeto vac\u00edo y agregar propiedades de forma din\u00e1mica o cuando se trabaja con programaci\u00f3n m\u00e1s orientada a objetos.</p> javascript<pre><code>const libro = new Object();\nlibro.titulo = \"El principito\";\nlibro.autor = \"Antoine de Saint-Exup\u00e9ry\";\nlibro.publicacion = 1943;\n\nconsole.log(libro);\n</code></pre> <p>Ambos m\u00e9todos permiten crear objetos, pero la notaci\u00f3n literal es generalmente m\u00e1s pr\u00e1ctica y legible.</p>"},{"location":"javascript/objetos/#acceso-a-las-propiedades-de-un-objeto","title":"Acceso a las Propiedades de un Objeto","text":"<p>Para trabajar con los datos almacenados en un objeto es necesario saber c\u00f3mo acceder a sus propiedades. En JavaScript se puede hacer esto usando la notaci\u00f3n de punto (<code>objeto.propiedad</code>) o la notaci\u00f3n de corchetes (<code>objeto[\"propiedad\"]</code>). Ambos m\u00e9todos son equivalentes en funcionalidad, pero se usan en diferentes contextos.</p> <p>Ejemplos de Acceso a Propiedades:</p> javascript<pre><code>const persona = {\n  nombre: \"Mar\u00eda\",\n  edad: 25\n};\n\n// Usando notaci\u00f3n de punto\nconsole.log(persona.nombre);\n\n// Usando notaci\u00f3n de corchetes\nconsole.log(persona[\"edad\"]);\n</code></pre> <p>La notaci\u00f3n de punto es m\u00e1s concisa y se utiliza con mayor frecuencia, mientras que la notaci\u00f3n de corchetes es \u00fatil cuando el nombre de la propiedad es din\u00e1mico o contiene caracteres especiales.</p>"},{"location":"javascript/objetos/#modificacion-de-las-propiedades-de-un-objeto","title":"Modificaci\u00f3n de las Propiedades de un Objeto","text":"<p>Una de las ventajas de los objetos en JavaScript es que sus propiedades se pueden modificar en tiempo de ejecuci\u00f3n. Esto significa que puedes actualizar el valor de una propiedad existente, a\u00f1adir nuevas propiedades o incluso eliminar propiedades que ya no son necesarias. Esta flexibilidad permite trabajar con datos din\u00e1micos, adaptando la estructura del objeto seg\u00fan las necesidades del programa.</p> <p>Ejemplo de Modificaci\u00f3n de Propiedades:</p> javascript<pre><code>const mascota = {\n  nombre: \"Firulais\",\n  tipo: \"Perro\"\n};\n\n// Modificando una propiedad existente\nmascota.nombre = \"Max\";\n\n// A\u00f1adiendo una nueva propiedad\nmascota.edad = 4;\n\nconsole.log(mascota);\n</code></pre> <p>En este ejemplo, se cambia el nombre de la mascota y se a\u00f1ade una nueva propiedad <code>edad</code>. Este tipo de operaciones son comunes en aplicaciones donde los datos pueden cambiar con el tiempo.</p>"},{"location":"javascript/objetos/#eliminacion-de-propiedades-en-un-objeto","title":"Eliminaci\u00f3n de Propiedades en un Objeto","text":"<p>A veces es necesario eliminar propiedades de un objeto para reducir su tama\u00f1o o limpiar datos que ya no son relevantes. En JavaScript, se utiliza la palabra clave <code>delete</code> para eliminar propiedades de un objeto. Esta operaci\u00f3n es permanente y elimina la propiedad completamente, junto con su valor asociado.</p> <p>Ejemplo de Eliminaci\u00f3n de Propiedades:</p> javascript<pre><code>const usuario = {\n  nombre: \"Carlos\",\n  correo: \"carlos@example.com\"\n};\n\n// Eliminando la propiedad correo\ndelete usuario.correo;\n\nconsole.log(usuario); \n</code></pre> <p>El uso del operador <code>delete</code> permite gestionar mejor la memoria y mantener los objetos limpios y organizados.</p> <p>Aunque <code>delete</code> elimina la propiedad del objeto, si se accede a ella posteriormente, se obtendr\u00e1 <code>undefined</code>.</p>"},{"location":"javascript/objetos/#comprobacion-de-propiedades-en-un-objeto","title":"Comprobaci\u00f3n de Propiedades en un Objeto","text":"<p>En ocasiones es \u00fatil verificar si un objeto tiene una propiedad espec\u00edfica antes de manipularla. Para esto JavaScript ofrece dos formas principales: el operador <code>in</code> y el m\u00e9todo <code>hasOwnProperty()</code>. Estos m\u00e9todos ayudan a evitar errores al acceder a propiedades inexistentes y permiten verificar la estructura del objeto antes de realizar operaciones.</p> <p>Ejemplos de Comprobaci\u00f3n:</p> javascript<pre><code>const producto = {\n  nombre: \"Laptop\",\n  precio: 1200\n};\n\n// Usando el operador 'in'\nconsole.log(\"nombre\" in producto);\n\n// Usando el m\u00e9todo hasOwnProperty()\nconsole.log(producto.hasOwnProperty(\"precio\"));\n</code></pre> <p>Estos m\u00e9todos son esenciales para trabajar con objetos en aplicaciones m\u00e1s complejas, donde la estructura de los datos puede ser variable.</p>"},{"location":"javascript/objetos/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los objetos en JavaScript son una parte fundamental del lenguaje, permitiendo modelar y gestionar datos de manera eficiente. Comprender c\u00f3mo crear, modificar y eliminar propiedades es esencial para trabajar con aplicaciones que manejan datos complejos. Esta introducci\u00f3n proporciona las bases para trabajar con objetos, mientras que los temas avanzados se abordan en una secci\u00f3n espec\u00edfica.</p> <p></p>"},{"location":"javascript/operador-exponenciacion/","title":"Operador de Exponenciaci\u00f3n","text":""},{"location":"javascript/operador-exponenciacion/#operador-de-exponenciacion","title":"Operador de Exponenciaci\u00f3n","text":"<p>Introducido en ES6, el operador de exponenciaci\u00f3n (<code>**</code>) en JavaScript permite elevar un n\u00famero a la potencia de otro, simplificando c\u00e1lculos de potencias que antes se realizaban con <code>Math.pow</code>. Este operador es intuitivo y esencial para realizar operaciones matem\u00e1ticas avanzadas. En este art\u00edculo exploraremos c\u00f3mo funciona, sus aplicaciones y algunos detalles importantes para dominarlo.</p>"},{"location":"javascript/operador-exponenciacion/#que-es-el-operador-de-exponenciacion","title":"\u00bfQu\u00e9 es el Operador de Exponenciaci\u00f3n?","text":"<p>El operador de exponenciaci\u00f3n (<code>**</code>) en JavaScript eleva un n\u00famero base a una potencia espec\u00edfica. Este operador es ampliamente utilizado en aplicaciones matem\u00e1ticas y cient\u00edficas. La sintaxis es:</p> javascript<pre><code>resultado = base ** exponente;\n</code></pre> <ul> <li><code>base</code>: El n\u00famero que deseas elevar.</li> <li><code>exponente</code>: La potencia a la que se eleva la base.</li> </ul> <p>Ejemplo B\u00e1sico de Exponenciaci\u00f3n:</p> javascript<pre><code>const base = 2;\nconst exponente = 3;\nconst resultado = base ** exponente;\n\nconsole.log(resultado);\n</code></pre> <p>En el anterior c\u00f3digo vemos como <code>2 ** 3</code> representa <code>2</code><sup><code>3</code></sup>, que equivale a <code>8</code>.</p>"},{"location":"javascript/operador-exponenciacion/#comparacion-con-mathpow","title":"Comparaci\u00f3n con <code>Math.pow()</code>","text":"<p>Antes de ES6 la forma de calcular una potencia era usando <code>Math.pow</code>. Aunque la funci\u00f3n a\u00fan sigue siendo v\u00e1lida, el operador <code>**</code> ofrece una sintaxis m\u00e1s breve y clara.</p> javascript<pre><code>const base = 4;\nconst exponente = 2;\n\nconsole.log(Math.pow(base, exponente));\nconsole.log(base ** exponente);\n</code></pre> <p>Ambas formas generan el mismo resultado, pero <code>**</code> suele preferirse por su simplicidad y legibilidad.</p> <p> Tenga en cuenta que algunos lenguajes utilizan el s\u00edmbolo de intercalaci\u00f3n ^ para la exponenciaci\u00f3n. Sin embargo, JavaScript ya usa ese s\u00edmbolo para el operador XOR l\u00f3gico bit a bit.</p> <p></p> <p>Este operador eleva el n\u00famero de la base al exponente especificado. Adem\u00e1s, el operador de exponenciaci\u00f3n acepta tanto valores <code>number</code> como <code>bigint</code>.</p>"},{"location":"javascript/operador-exponenciacion/#exponenciacion-con-numeros-negativos","title":"Exponenciaci\u00f3n con N\u00fameros Negativos","text":"<p>El operador de exponenciaci\u00f3n en JavaScript permite tanto bases como exponentes negativos, pero existen algunas consideraciones importantes sobre c\u00f3mo se comporta con estos valores. Veamos:</p>"},{"location":"javascript/operador-exponenciacion/#bases-negativas","title":"Bases Negativas:","text":"<p>Cuando la base es negativa el resultado depende de si el exponente es par o impar. Si el exponente es par, el resultado ser\u00e1 positivo; si es impar, el resultado ser\u00e1 negativo.</p> javascript<pre><code>const base = -2;\nconst exponentePar = 4;\nconst exponenteImpar = 3;\n\nconsole.log(base ** exponentePar);  // (par)\nconsole.log(base ** exponenteImpar); // (impar)\n</code></pre> <p>En el c\u00f3digo anterior vemos que la primera salida en consola es un numero par <code>(-2) ** 4</code> da <code>16</code>, ya que elevar un n\u00famero negativo a una potencia par siempre resulta en un valor positivo. En la segunda salida da negativo porque <code>(-2) ** 3</code> da <code>-8</code>, ya que una potencia impar mantiene el signo negativo.</p>"},{"location":"javascript/operador-exponenciacion/#exponentes-negativos","title":"Exponentes Negativos:","text":"<p>Cuando el exponente es negativo el operador devuelve el rec\u00edproco de la potencia. Esto equivale a dividir <code>1</code> entre el valor de la base elevada a la potencia positiva del exponente.</p> javascript<pre><code>const base = 5;\nconst exponenteNegativo = -2;\n\nconsole.log(base ** exponenteNegativo);  // (equivalente a 1 / 25)\n</code></pre> <p>Aqu\u00ed, <code>5 ** -2</code> es lo mismo que <code>1 / (5 ** 2)</code>, resultando en <code>0.04</code>.</p>"},{"location":"javascript/operador-exponenciacion/#exponenciacion-y-conversiones-implicitas-de-tipo","title":"Exponenciaci\u00f3n y Conversiones Impl\u00edcitas de Tipo","text":"<p>Cuando uno de los operandos del operador de exponenciaci\u00f3n es un string que representa un n\u00famero, JavaScript intentar\u00e1 convertirlo autom\u00e1ticamente a un valor num\u00e9rico antes de realizar la operaci\u00f3n. Si la conversi\u00f3n falla, el resultado ser\u00e1 <code>NaN</code>.</p> <p>Ejemplo de Conversi\u00f3n Impl\u00edcita:</p> javascript<pre><code>console.log(\"2\" ** 3);  // (convierte \"2\" a n\u00famero)\nconsole.log(2 ** \"3\");  // (convierte \"3\" a n\u00famero)\nconsole.log(\"Hola\" ** 2);  // (no se puede convertir)\n</code></pre> <p>JavaScript utiliza el m\u00e9todo <code>Number()</code> para intentar convertir strings en valores num\u00e9ricos y si el string no es convertible (como en <code>\"Hola\"</code>), el resultado es <code>NaN</code>.</p>"},{"location":"javascript/operador-exponenciacion/#prioridad-del-operador-de-exponenciacion","title":"Prioridad del Operador de Exponenciaci\u00f3n","text":"<p>El operador de exponenciaci\u00f3n tiene una prioridad alta en JavaScript, incluso m\u00e1s alta que los operadores de multiplicaci\u00f3n y divisi\u00f3n. Esto significa que cualquier operaci\u00f3n de exponenciaci\u00f3n se evaluar\u00e1 antes que multiplicaciones o divisiones, a menos que se utilicen par\u00e9ntesis para controlar el orden de ejecuci\u00f3n.</p> <p>Ejemplo de Prioridad:</p> javascript<pre><code>const resultado = 2 * 3 ** 2;\n\nconsole.log(resultado);\n</code></pre> <p>En este caso, <code>3 ** 2</code> se eval\u00faa primero, y luego el resultado (<code>9</code>) se multiplica por <code>2</code>. Para alterar el orden de ejecuci\u00f3n, se pueden usar par\u00e9ntesis:</p> javascript<pre><code>let resultado = (2 * 3) ** 2;\n\nconsole.log(resultado);\n</code></pre> <p>Aqu\u00ed, <code>2 * 3</code> se eval\u00faa primero, y el resultado (<code>6</code>) se eleva a <code>2</code>.</p>"},{"location":"javascript/operador-exponenciacion/#consideraciones-para-usar-exponenciacion","title":"Consideraciones para Usar Exponenciaci\u00f3n","text":"<ul> <li>Conoce el Comportamiento con Negativos: Entiende c\u00f3mo <code>**</code> afecta a bases y exponentes negativos, especialmente en c\u00e1lculos donde el signo es importante.</li> <li>Aprovecha las Conversiones Impl\u00edcitas: Si los operandos son strings num\u00e9ricos, JavaScript los convierte autom\u00e1ticamente, pero aseg\u00farate de que los datos sean num\u00e9ricos para evitar <code>NaN</code>.</li> <li>Usa Par\u00e9ntesis para Controlar el Orden de Evaluaci\u00f3n: Debido a la alta prioridad de <code>**</code>, los par\u00e9ntesis pueden ayudar a evitar c\u00e1lculos inesperados.</li> </ul>"},{"location":"javascript/operador-exponenciacion/#conclusion","title":"Conclusi\u00f3n","text":"<p>El operador de exponenciaci\u00f3n (<code>**</code>) en JavaScript es una herramienta poderosa para elevar valores a una potencia, \u00fatil en aplicaciones matem\u00e1ticas, cient\u00edficas y financieras. Con su alta prioridad y su capacidad de manejar bases y exponentes negativos, este operador simplifica muchos c\u00e1lculos que antes requer\u00edan <code>Math.pow</code>. Al comprender su funcionamiento y buenas pr\u00e1cticas, puedes aprovechar al m\u00e1ximo este operador en tus proyectos.</p> <p></p>"},{"location":"javascript/operador-fusion-nulos/","title":"Operador de Fusi\u00f3n de Nulos","text":""},{"location":"javascript/operador-fusion-nulos/#operador-de-fusion-de-nulos","title":"Operador de Fusi\u00f3n de Nulos","text":"<p>Introducido en ES2020, el operador de fusi\u00f3n de nulos (<code>??</code>) es una soluci\u00f3n elegante para asignar valores predeterminados solo cuando una variable es <code>null</code> o <code>undefined</code>. A diferencia del operador l\u00f3gico <code>||</code>, que trata valores \u201cfalsy\u201d como <code>0</code>, <code>false</code> o <code>\"\"</code> de manera similar a <code>null</code>, el operador <code>??</code> preserva estos valores v\u00e1lidos, ofreciendo un control m\u00e1s preciso sobre los datos opcionales.</p> <p>En este art\u00edculo desglosaremos c\u00f3mo funciona el operador de fusi\u00f3n de nulos (coalescente nulo), por qu\u00e9 es superior en ciertos casos y c\u00f3mo puedes utilizarlo para escribir c\u00f3digo m\u00e1s limpio y confiable al gestionar valores predeterminados.</p>"},{"location":"javascript/operador-fusion-nulos/#que-es-el-operador-de-fusion-de-nulos","title":"\u00bfQu\u00e9 es el Operador de Fusi\u00f3n de Nulos?","text":"<p>El operador de fusi\u00f3n de nulos (<code>??</code>) es una entidad que eval\u00faa el valor de la izquierda y si es <code>null</code> o <code>undefined</code>, devuelve el valor de la derecha. Si el valor de la izquierda es cualquier otro valor, incluyendo <code>0</code>, <code>\"\"</code>, o <code>false</code>, devuelve dicho valor sin pasar al valor predeterminado de la derecha.</p> javascript<pre><code>const resultado = exprIzquierda ?? exprDerecha;\n</code></pre> <ul> <li><code>exprIzquierda</code> es el valor que se eval\u00faa primero.</li> <li><code>exprDerecha</code> es el valor que se asigna solo si <code>exprIzquierda</code> es <code>null</code> o <code>ndefined</code>.</li> </ul> <p>T\u00e9cnicamente el operador coalescente nulo es equivalente al siguiente bloque:</p> javascript<pre><code>const result = value1;\n\nif(result === null || result === undefined) {\n result = value2;\n}\n</code></pre> <p>Veamos otro ejemplo b\u00e1sico donde la variable <code>edad</code> se establecer\u00e1 en <code>28</code> ya que el primer valor es indefinido, por lo que el operador de fusi\u00f3n de nulos devuelve el segundo valor (<code>28</code>).</p> javascript<pre><code>const edad = undefined ?? 28;\n\nconsole.log(edad);\n</code></pre> <p>El operador de fusi\u00f3n de nulos es \u00fatil para proporcionar valores predeterminados en caso de que el valor inicial sea nulo o indefinido, lo que simplifica y hace m\u00e1s legible el c\u00f3digo.</p>"},{"location":"javascript/operador-fusion-nulos/#ejemplos-de-uso-asignacion-de-valores-predeterminados","title":"Ejemplos de Uso: Asignaci\u00f3n de Valores Predeterminados","text":"<p>El operador de fusi\u00f3n de nulos es \u00fatil para asignar un valor predeterminado solo cuando una variable es <code>null</code> o <code>undefined</code>.</p> javascript<pre><code>const nombreUsuario = null;\nconst nombre = nombreUsuario ?? \"Invitado\";\n\nconsole.log(nombre);\n</code></pre> <p>En el anterior ejemplo <code>nombreUsuario</code> es <code>null</code>, por lo que <code>nombre</code> toma el valor <code>\"Invitado\"</code>. Si <code>nombreUsuario</code> hubiera tenido un valor distinto de <code>null</code> o <code>undefined</code>, <code>nombre</code> se habr\u00eda asignado con ese valor.</p>"},{"location":"javascript/operador-fusion-nulos/#evitar-sobrescribir-valores-falsy","title":"Evitar Sobrescribir Valores \u201cFalsy\u201d","text":"<p>A diferencia del operador <code>||</code> el operador <code>??</code> permite retener valores \u201cfalsy\u201d como <code>0</code>, <code>false</code>, y <code>\"\"</code>, en lugar de reemplazarlos con un valor predeterminado.</p> javascript<pre><code>const puntuacion = 0;\nconst puntuacionFinal = puntuacion ?? 100;\n\nconsole.log(puntuacionFinal);\n</code></pre> <p>En el anterior ejemplo <code>puntuacion</code> es <code>0</code>, un valor \u201cfalsy\u201d pero v\u00e1lido, por lo que <code>puntuacionFinal</code> toma el valor <code>0</code> en lugar de <code>100</code>.</p>"},{"location":"javascript/operador-fusion-nulos/#diferencia-entre-el-operador-logico-or-y-fusion-de-nulos","title":"Diferencia entre el operador l\u00f3gico OR y Fusi\u00f3n de Nulos","text":"<p>El operador l\u00f3gico OR <code>||</code> tambi\u00e9n se usa para asignar valores predeterminados, pero considera cualquier valor \u201cfalsy\u201d como <code>false</code>, <code>0</code>, <code>NaN</code>, <code>\"\"</code>, <code>null</code>, o <code>undefined</code>. Esto significa que el operador <code>||</code> sustituir\u00e1 valores que pueden ser v\u00e1lidos en algunos casos.</p> <p>Ejemplo Comparativo:</p> javascript<pre><code>const texto = \"\";\nconst mensaje1 = texto || \"Texto predeterminado\";\nconst mensaje2 = texto ?? \"Texto predeterminado\";\n\nconsole.log(mensaje1);\nconsole.log(mensaje2);\n</code></pre> <p>En el ejemplo anterior <code>||</code> reemplaza el string vac\u00edo <code>\"\"</code> por <code>\"Texto predeterminado\"</code>, mientras que <code>??</code> respeta <code>\"\"</code> como un valor v\u00e1lido.</p> <p>Usa <code>??</code> cuando desees conservar valores \u201cfalsy\u201d como <code>0</code>, <code>false</code>, o <code>\"\"</code>, y reserva <code>||</code> para asignaciones donde cualquier valor \u201cfalsy\u201d deba ser reemplazado.</p>"},{"location":"javascript/operador-fusion-nulos/#el-operador-de-fusion-de-nulos-y-su-cortocircuito","title":"El Operador de Fusi\u00f3n de Nulos y su Cortocircuito","text":"<p>Al igual que los operadores l\u00f3gicos, el operador de fusi\u00f3n de nulos tambi\u00e9n presenta un comportamiento de cortocircuito.</p> <p>Funcionamiento del Cortocircuito: El operador de fusi\u00f3n de nulos no eval\u00faa el segundo valor si el primer operando no es <code>undefined</code> ni <code>null</code>. Esto significa que si el primer valor ya es un valor definido, no se eval\u00faa ni se ejecuta la segunda expresi\u00f3n.</p> javascript<pre><code>const result = 1 ?? console.log('Hola JavaScript');\n</code></pre> <p>En el anterior ejemplo vemos como el primer valor es <code>1</code> (su tipo no equivale a <code>null</code> ni <code>undefined</code>), el operador de fusi\u00f3n de nulos no necesita evaluar la segunda expresi\u00f3n <code>console.log('Hi')</code>. Por lo tanto, no se mostrar\u00e1 el mensaje \u201cHola JavaScript\u201d en la consola.</p> javascript<pre><code>const result = undefined ?? console.log('Hola Programador');\n</code></pre> <p>En este caso, como el primer valor es <code>undefined</code> el operador de fusi\u00f3n de nulos evaluar\u00e1 la segunda expresi\u00f3n <code>console.log('Hola Programador')</code> y mostrar\u00e1 su valor en la consola.</p> <p>Ventajas del Cortocircuito:</p> <ul> <li>Mejora el rendimiento al evitar evaluaciones innecesarias.</li> <li>Aumenta la eficiencia del c\u00f3digo al evitar operaciones redundantes.</li> <li>Garantiza un comportamiento predecible al priorizar la eficacia sobre la evaluaci\u00f3n exhaustiva.</li> </ul>"},{"location":"javascript/operador-fusion-nulos/#encadenamiento-con-operadores-logicos-y-fusion-de-nulos","title":"Encadenamiento con Operadores L\u00f3gicos y Fusi\u00f3n de Nulos","text":"<p>Cuando se utilizan operadores l\u00f3gicos como OR y AND junto con el operador de fusi\u00f3n de nulos, es importante considerar la precedencia de los operadores para evitar errores sint\u00e1cticos.</p> javascript<pre><code>const result = null || undefined ?? 'OK';\n\nconsole.log(result)\n</code></pre> <p>En este ejemplo se produce un error de sintaxis porque la combinaci\u00f3n directa del operador OR con el operador de fusi\u00f3n de nulos no sigue la precedencia de los operadores.</p> <p>Para evitar este error se recomienda utilizar par\u00e9ntesis para especificar expl\u00edcitamente la precedencia de los operadores:</p> javascript<pre><code>const result = (null || undefined) ?? 'OK';\n\nconsole.log(result);\n</code></pre> <p>Al envolver la expresi\u00f3n a la izquierda del operador de fusi\u00f3n de nulos entre par\u00e9ntesis, se asegura que la evaluaci\u00f3n se realice de manera correcta y sin errores sint\u00e1cticos.</p> <p> Al encadenar operadores l\u00f3gicos con el operador de fusi\u00f3n de nulos, es esencial prestar atenci\u00f3n a la precedencia de los operadores y utilizar par\u00e9ntesis para garantizar una evaluaci\u00f3n correcta y evitar errores sint\u00e1cticos en JavaScript.</p> <p></p>"},{"location":"javascript/operador-fusion-nulos/#buenas-practicas-al-usar-el-operador-de-fusion-de-nulos","title":"Buenas Pr\u00e1cticas al Usar El Operador de Fusi\u00f3n de Nulos","text":"<ul> <li>Prefiere <code>??</code> para Valores Opcionales: Utiliza este operador para asignar valores predeterminados solo cuando la variable puede ser <code>null</code> o <code>undefined</code>, sin afectar valores como <code>0</code>, <code>\"\"</code>, o <code>false</code>.</li> <li>Usa <code>||</code> para Asegurar Valores \u201cTruthy\u201d: Si necesitas una asignaci\u00f3n m\u00e1s flexible que reemplace cualquier valor \u201cfalsy\u201d, <code>||</code> puede ser m\u00e1s adecuado.</li> <li>Evita Mezclar <code>??</code> con Otros Operadores L\u00f3gicos sin Par\u00e9ntesis: JavaScript no permite combinar <code>??</code> con <code>&amp;&amp;</code> o <code>||</code> sin usar par\u00e9ntesis, ya que puede causar ambig\u00fcedad en la evaluaci\u00f3n de las expresiones.</li> </ul>"},{"location":"javascript/operador-fusion-nulos/#conclusion","title":"Conclusi\u00f3n","text":"<p>El operador de fusi\u00f3n de nulos (<code>??</code>) en JavaScript permite asignar valores de manera segura solo cuando una variable es <code>null</code> o <code>undefined</code>, sin reemplazar otros valores \u201cfalsy\u201d como <code>0</code>, <code>false</code>, o <code>\"\"</code>. Al entender la diferencia entre <code>??</code> y <code>||</code>, puedes controlar mejor las asignaciones condicionales en tu c\u00f3digo, evitando sobrescribir valores v\u00e1lidos. Este operador es especialmente \u00fatil en la configuraci\u00f3n de valores predeterminados y en la verificaci\u00f3n de propiedades opcionales en objetos.</p> <p></p>"},{"location":"javascript/operador-resto/","title":"Operador de Resto","text":""},{"location":"javascript/operador-resto/#operador-de-resto","title":"Operador de Resto","text":"<p>En JavaScript, el operador de resto, utilizado mediante el s\u00edmbolo (<code>%</code>) se usa com\u00fanmente para calcular el residuo de una divisi\u00f3n. Aunque en muchos lenguajes de programaci\u00f3n este operador se llama \u201cm\u00f3dulo\u201d, en JavaScript act\u00faa t\u00e9cnicamente como un operador de resto, lo cual implica un comportamiento ligeramente diferente.</p>"},{"location":"javascript/operador-resto/#que-es-el-operador-de-resto-en-javascript","title":"\u00bfQu\u00e9 es el Operador de Resto en JavaScript?","text":"<p>El operador <code>%</code> calcula el resto de dividir el primer operando por el segundo. La sintaxis b\u00e1sica es:</p> javascript<pre><code>resultado = a % b;\n</code></pre> <p>En el anterior c\u00f3digo <code>a</code> es el dividendo y <code>b</code> es el divisor. El resultado es el residuo de dividir <code>a</code> por <code>b</code>, conservando el mismo signo que el dividendo.</p> <p> El resto (o remainder) en una operaci\u00f3n de divisi\u00f3n, donde si el dividendo es positivo, el resto ser\u00e1 positivo, y si el dividendo es negativo, el resto tambi\u00e9n ser\u00e1 negativo.</p> <p></p>"},{"location":"javascript/operador-resto/#diferencia-entre-resto-y-modulo","title":"Diferencia entre Resto y M\u00f3dulo","text":"<p>Aunque el operador <code>%</code> suele denominarse \u201cm\u00f3dulo\u201d en otros lenguajes (como Python), en JavaScript opera como un resto. La diferencia clave es que, en el operador de m\u00f3dulo verdadero, el resultado siempre es positivo, mientras que en el operador de resto el resultado sigue el signo del dividendo. Por ejemplo:</p> <ul> <li>En JavaScript (resto): <code>-10 % 3</code> devuelve <code>-1</code>.</li> <li>En Python (m\u00f3dulo): <code>-10 % 3</code> devuelve <code>2</code>.</li> </ul> <p>Implementaci\u00f3n de un M\u00f3dulo Verdadero en JavaScript:</p> <p>Si necesitas un resultado de m\u00f3dulo positivo (como en otros lenguajes) puedes crear una funci\u00f3n personalizada:</p> javascript<pre><code>function modulo(a, b) {\n  return ((a % b) + b) % b;\n}\n\nconsole.log(modulo(-10, 3));\n</code></pre> <p>Esta funci\u00f3n asegura que el resultado sea siempre positivo, imitando el comportamiento de un operador de m\u00f3dulo verdadero.</p>"},{"location":"javascript/operador-resto/#operador-de-resto-con-numeros-negativos","title":"Operador de Resto con N\u00fameros Negativos","text":"<p>El operador de resto devuelve el residuo con el mismo signo que el dividendo (primer operando). Este comportamiento puede ser inesperado para quienes est\u00e1n acostumbrados a trabajar con el m\u00f3dulo en otros lenguajes.</p> javascript<pre><code>const a = -10;\nconst b = 3;\nconsole.log(\"Primer resultado: \" + a % b);\n\nconst c = 10;\nconst d = -3;\nconsole.log(\"Segundo resultado: \" + c % d);\n</code></pre> <p>En los ejemplos anteriores:</p> <ul> <li><code>-10 % 3</code> devuelve <code>-1</code>, porque el signo del residuo sigue el signo del dividendo (<code>-10</code>).</li> <li><code>10 % -3</code> devuelve <code>1</code>, con el mismo signo positivo que <code>10</code>.</li> </ul> <p>Esta diferencia en el signo puede afectar el resultado de c\u00e1lculos c\u00edclicos o patrones sim\u00e9tricos en el desarrollo.</p>"},{"location":"javascript/operador-resto/#uso-del-operador-de-resto-para-determinar-paridad","title":"Uso del Operador de Resto para Determinar Paridad","text":"<p>El operador de resto es \u00fatil para determinar si un n\u00famero es par o impar. Un n\u00famero es par si el resto de dividirlo entre <code>2</code> es <code>0</code>; si el resto es <code>1</code>, el n\u00famero es impar.</p> <p>Ejemplo de Verificaci\u00f3n de Paridad:</p> javascript<pre><code>const numero = 7;\n\nif (numero % 2 === 0) {\n  console.log(`El n\u00famero ${numero} es par`);\n} else {\n  console.log(`El n\u00famero ${numero} es impar`);\n}\n</code></pre> <p>En el anterior ejemplo: <code>7 % 2</code> devuelve <code>1</code>, indicando que <code>7</code> es impar. Esta l\u00f3gica es fundamental para validaciones y ciclos.</p>"},{"location":"javascript/operador-resto/#conversiones-y-uso-de-resto-con-tipos-no-numericos","title":"Conversiones y Uso de Resto con Tipos No Num\u00e9ricos","text":"<p>JavaScript permite usar el operador de resto con strings y otros tipos de datos, realizando conversiones autom\u00e1ticas. El operador convierte ambos operandos a n\u00fameros antes de ejecutar la operaci\u00f3n.</p>"},{"location":"javascript/operador-resto/#ejemplo-de-conversion-implicita","title":"Ejemplo de Conversi\u00f3n Impl\u00edcita:","text":"javascript<pre><code>console.log(\"10\" % 3);  // (convierte \"10\" a n\u00famero)\nconsole.log(\"Hola\" % 2);  // (no se puede convertir a n\u00famero)\n</code></pre> <p>En el primer caso, <code>\"10\"</code> se convierte a 10 para realizar el c\u00e1lculo. En el segundo, <code>\"Hola\"</code> no puede convertirse, por lo que el resultado es <code>NaN</code>.</p>"},{"location":"javascript/operador-resto/#aplicaciones-comunes-del-operador-de-resto","title":"Aplicaciones Comunes del Operador de Resto","text":"<ol> <li>Contadores C\u00edclicos: Cuando se necesita reiniciar un contador al alcanzar un valor m\u00e1ximo este operador es ideal. Esto es \u00fatil en ciclos de colores, rotaci\u00f3n de elementos en arrays, entre otros.</li> </ol> javascript<pre><code>const limite = 5;\n\nfor (let i = 0; i &lt; 10; i++) {\n  console.log(i % limite);\n}\n</code></pre> <p>En este ciclo, <code>i % limite</code> reinicia el contador a <code>0</code> cuando <code>i</code> alcanza el limite.</p> <ol> <li>Validaci\u00f3n de M\u00faltiplos: El operador <code>%</code> permite validar si un n\u00famero es m\u00faltiplo de otro. Esto es \u00fatil en algoritmos donde se aplican reglas a m\u00faltiplos espec\u00edficos (por ejemplo, n\u00fameros divisibles por <code>3</code> o <code>5</code>).</li> </ol> javascript<pre><code>const numero = 15;\n\nif (numero % 5 === 0) {\n    console.log(`${numero} es m\u00faltiplo de 5`);\n}\n</code></pre> <p>Si <code>numero % 5</code> devuelve <code>0</code>, significa que <code>numero</code> es divisible por <code>5</code>.</p> <ol> <li>Alternancia en Estructuras Repetitivas: El operador de resto / m\u00f3dulo permite alternar entre diferentes opciones dentro de un ciclo, como cambiar de color o patr\u00f3n.</li> </ol> javascript<pre><code>const colores = [\"rojo\", \"verde\", \"azul\"];\n\nfor (let i = 0; i &lt; 6; i++) {\n  console.log(colores[i % colores.length]);\n}\n</code></pre>"},{"location":"javascript/operador-resto/#consideraciones-con-el-operador-de-resto","title":"Consideraciones con el Operador de Resto","text":"<ol> <li>Conoce el Signo del Resultado: El signo sigue al dividendo, lo cual es importante en ciclos sim\u00e9tricos.</li> <li>Comprende las Conversiones Impl\u00edcitas: <code>%</code> convierte strings num\u00e9ricos autom\u00e1ticamente; si falla, el resultado es <code>NaN</code>.</li> <li>Usa <code>%</code> para Alternancias y Ciclos: En estructuras repetitivas este operador permite crear patrones c\u00edclicos sin condicionales adicionales.</li> <li>Aplicaciones Matem\u00e1ticas y Condicionales: Utiliza este operador en c\u00e1lculos matem\u00e1ticos avanzados, como comprobaci\u00f3n de m\u00faltiplos.</li> </ol>"},{"location":"javascript/operador-resto/#conclusion","title":"Conclusi\u00f3n","text":"<p>El operador de resto (<code>%</code>) en JavaScript es una herramienta vers\u00e1til para c\u00e1lculos de residuo, validaci\u00f3n de m\u00faltiplos y patrones c\u00edclicos. Conocer las diferencias entre resto y m\u00f3dulo, junto con aplicaciones pr\u00e1cticas, asegura un uso preciso en desarrollo. En el pr\u00f3ximo art\u00edculo, veremos el Operador de Exponenciaci\u00f3n (<code>**</code>) en JavaScript.</p> <p></p>"},{"location":"javascript/operadores-aritmeticos/","title":"Operadores Aritm\u00e9ticos","text":""},{"location":"javascript/operadores-aritmeticos/#operadores-aritmeticos","title":"Operadores Aritm\u00e9ticos","text":"<p>Los operadores aritm\u00e9ticos en JavaScript permiten realizar c\u00e1lculos matem\u00e1ticos b\u00e1sicos u avanzados. Adem\u00e1s de las operaciones b\u00e1sicas conocidas, estos operadores interact\u00faan de diferentes formas con distintos tipos de datos, incluyendo conversiones autom\u00e1ticas y objetos.</p> <p>Este art\u00edculo explora cada operador aritm\u00e9tico, sus caracter\u00edsticas especiales y sus aplicaciones pr\u00e1cticas.</p>"},{"location":"javascript/operadores-aritmeticos/#que-son-los-operadores-aritmeticos","title":"\u00bfQu\u00e9 son los Operadores Aritm\u00e9ticos?","text":"<p>Los operadores aritm\u00e9ticos son s\u00edmbolos que indican al int\u00e9rprete la realizaciones de operaciones matem\u00e1ticas entre valores. Aunque se usan principalmente para operaciones num\u00e9ricas, tambi\u00e9n pueden interact\u00faan con otros tipos de datos como por ejemplo, los strings u objetos, generando as\u00ed conversiones autom\u00e1ticas o comportamientos especiales.</p>"},{"location":"javascript/operadores-aritmeticos/#tipos-de-operadores-aritmeticos-en-javascript","title":"Tipos de Operadores Aritm\u00e9ticos en JavaScript","text":"<p>JavaScript ofrece una serie de operadores aritm\u00e9ticos est\u00e1ndar que son fundamentales para realizar operaciones matem\u00e1ticas. Estos son:</p> <ul> <li>Suma (<code>+</code>)</li> <li>Resta (<code>-</code>)</li> <li>Multiplicaci\u00f3n (<code>*</code>)</li> <li>Divisi\u00f3n (<code>/</code>)</li> <li>M\u00f3dulo o Resto (<code>%</code>)</li> <li>Exponenciaci\u00f3n (<code>**</code>)</li> </ul>"},{"location":"javascript/operadores-aritmeticos/#operador-de-suma","title":"Operador de Suma","text":"<p>El operador de suma <code>+</code> permite la adicci\u00f3n de valores num\u00e9ricos. Adem\u00e1s, cuando uno de los operandos es un string, este operador act\u00faa como operador de concatenaci\u00f3n, uniendo el texto de ambos lados.</p> <p>Ejemplo de Suma y Concatenaci\u00f3n:</p> javascript<pre><code>const a = 10;\nconst b = 5;\nconsole.log(a + b);\n\nconst saludo = \"Hola, \";\nconst nombre = \"JavaScript\";\nconst mensaje = saludo + nombre;\nconsole.log(mensaje);\n</code></pre> <p>Uso con N\u00fameros Negativos: Si uno de los valores es negativo, la operaci\u00f3n aritm\u00e9tica los suma o resta seg\u00fan corresponda.</p> javascript<pre><code>const x = -7;\nconst y = 3;\nconsole.log(x + y);\n</code></pre>"},{"location":"javascript/operadores-aritmeticos/#conversion-implicita-con-el-operador","title":"Conversi\u00f3n Impl\u00edcita con el Operador <code>+</code>","text":"<p>JavaScript realiza conversiones autom\u00e1ticas en ciertos casos. Cuando <code>+</code> combina un n\u00famero con un string, convierte autom\u00e1ticamente el n\u00famero a texto para concatenarlo en lugar de realizar una suma.</p> javascript<pre><code>const numero = 5; // tipo numbre\nconst texto = \" es un n\u00famero\"; // tipo string\n\nconsole.log(numero + texto);\n</code></pre> <p>Esto ocurre porque el operador <code>+</code> tiene una doble funci\u00f3n: suma y concatenaci\u00f3n. Si uno de los operandos es un string, el interprete de JavaScript considera que el contexto es textual y convierte el n\u00famero en string.</p>"},{"location":"javascript/operadores-aritmeticos/#operador-de-resta","title":"Operador de Resta","text":"<p>El operador de resta (<code>-</code>) en JavaScript calcula la diferencia entre dos valores num\u00e9ricos. Tambi\u00e9n se utiliza para operar con valores negativos siguiendo las reglas matem\u00e1ticas est\u00e1ndar.</p> javascript<pre><code>const a = 10;\nconst b = 5;\nconst result = a - b;\n\nconsole.log(result);\n</code></pre> <p>Resta de variables con valores negativos:</p> <p>La resta de variables con valores negativos en JavaScript sigue las mismas reglas matem\u00e1ticas que la resta de n\u00fameros positivos. Cuando restas un n\u00famero negativo de otro n\u00famero, est\u00e1s sumando el valor absoluto del n\u00famero negativo al primer n\u00famero.</p> javascript<pre><code>const numero1 = -10;\nconst numero2 = -5;\n\nconsole.log(numero1 - numero2);\n</code></pre>"},{"location":"javascript/operadores-aritmeticos/#conversion-implicita-en-resta","title":"Conversi\u00f3n Impl\u00edcita en Resta","text":"<p>A diferencia de la suma, el operador de resta (<code>-</code>) no tiene un rol secundario como concatenaci\u00f3n de strings. Esto significa que si uno de los operandos es un string que contiene un n\u00famero, el interprete intentar\u00e1 convertirlo a un n\u00famero mediante coerci\u00f3n impl\u00edcita para poder realizar la operaci\u00f3n. Este proceso se basa en el m\u00e9todo <code>Number()</code>, el cual intenta transformar el string a un n\u00famero. Si la conversi\u00f3n falla, el resultado ser\u00e1 <code>NaN</code>.</p> javascript<pre><code>const x = \"10\";\nconst y = 5;\n\nconsole.log(x - y);  // (convierte \"10\" a 10)\n</code></pre> <p>Este proceso evita errores y permite restas con datos que puedan estar almacenados como texto num\u00e9rico.</p>"},{"location":"javascript/operadores-aritmeticos/#operador-de-multiplicacion","title":"Operador de Multiplicaci\u00f3n","text":"<p>El operador de multiplicaci\u00f3n (<code>*</code>) en JavaScript multiplica dos valores y devuelve su producto. Si uno de los valores es negativo, el resultado tambi\u00e9n ser\u00e1 negativo, b\u00e1sicamente sigue las reglas matem\u00e1ticas est\u00e1ndar.</p> javascript<pre><code>const result = 2 * 3;\n\nconsole.log(result);\n</code></pre>"},{"location":"javascript/operadores-aritmeticos/#conversiones-en-multiplicacion","title":"Conversiones en Multiplicaci\u00f3n","text":"<p>Al igual que en la resta, si uno de los operandos es un string que contiene un n\u00famero, el interprete de JavaScript intenta convertirlo a un valor num\u00e9rico utilizando la funci\u00f3n Number(). Este proceso de conversi\u00f3n impl\u00edcita permite realizar la operaci\u00f3n sin necesidad de una conversi\u00f3n manual, esto siempre y cuando el string represente un valor num\u00e9rico v\u00e1lido.</p> javascript<pre><code>const x = \"3\";\nconst y = 4;\n\nconsole.log(x * y);\n</code></pre> <p>Si el string no representa un n\u00famero, el resultado ser\u00e1 <code>NaN</code>, indicando que la conversi\u00f3n fall\u00f3.</p>"},{"location":"javascript/operadores-aritmeticos/#operador-de-division","title":"Operador de Divisi\u00f3n","text":"<p>El operador de divisi\u00f3n (<code>/</code>) en JavaScript divide un valor entre otro y devuelve el cociente. Si el divisor es <code>0</code>, el resultado ser\u00e1 <code>Infinity</code> o <code>-Infinity</code>, dependiendo del signo del dividendo.</p> javascript<pre><code>const result = 20 / 10;\n\nconsole.log(result);\n</code></pre>"},{"location":"javascript/operadores-aritmeticos/#division-de-valores-no-numericos","title":"Divisi\u00f3n de Valores No Num\u00e9ricos","text":"<p>Cuando uno de los operandos es un string que representa un n\u00famero, JavaScript utiliza la conversi\u00f3n impl\u00edcita para transformar el string a un n\u00famero si es posible. Si el valor no es num\u00e9rico, el resultado es <code>NaN</code>.</p> javascript<pre><code>console.log(\"20\" / 2);\nconsole.log(\"Hola\" / 2);\n</code></pre> <p>El interprete del lenguaje intenta convertir el string <code>\u201c20\u201d</code> a un n\u00famero y logra hacer la divisi\u00f3n. Sin embargo, cuando el string no es convertible, como en <code>\"Hola\"</code>, el resultado es <code>NaN</code>.</p>"},{"location":"javascript/operadores-aritmeticos/#operadores-aritmeticos-con-objetos-en-javascript","title":"Operadores Aritm\u00e9ticos con Objetos en JavaScript","text":"<p>Cuando se aplican operadores aritm\u00e9ticos a objetos, JavaScript intenta convertirlos en valores primitivos mediante el m\u00e9todo <code>valueOf()</code> o <code>toString()</code>. Si el objeto tiene un m\u00e9todo <code>valueOf()</code> que devuelve un n\u00famero, este se utiliza para la operaci\u00f3n. Si <code>valueOf()</code> no existe o devuelve un valor no num\u00e9rico, JavaScript intenta usar <code>toString()</code>.</p> <p>Ejemplo con Objetos Personalizados:</p> javascript<pre><code>const objeto = {\n  valueOf() {\n    return 10;\n  }\n};\n\nconsole.log(objeto + 5);\nconsole.log(objeto * 2);\n</code></pre> <p>JavaScript invoca <code>valueOf()</code> para obtener un valor num\u00e9rico del objeto, permitiendo que el operador realice la operaci\u00f3n aritm\u00e9tica.</p>"},{"location":"javascript/operadores-aritmeticos/#precision-y-problemas-con-decimales-en-javascript","title":"Precisi\u00f3n y Problemas con Decimales en JavaScript","text":"<p>JavaScript utiliza el formato de punto flotante de doble precisi\u00f3n (IEEE 754) para representar n\u00fameros, lo que puede ocasionar errores de precisi\u00f3n al realizar operaciones con decimales. Estos errores se deben a que ciertos valores no pueden representarse exactamente en binario, lo que genera resultados inesperados.</p> javascript<pre><code>const x = 0.1;\nconst y = 0.2;\n\nconsole.log(x + y);\n</code></pre> <p>En este caso, la suma de <code>0.1</code> y <code>0.2</code> no es exactamente <code>0.3</code> debido a las limitaciones del formato binario.</p> <p>C\u00f3mo solucionar estos problemas:</p> <ul> <li>Redondeo de resultados: Puedes redondear el resultado a un n\u00famero fijo de decimales usando el <code>m\u00e9todo</code> <code>toFixed()</code> o el constructor <code>Number</code>.</li> <li>Trabajar con enteros: Otra t\u00e9cnica es evitar los decimales durante los c\u00e1lculos multiplicando los n\u00fameros por una potencia de 10 antes de operar y dividi\u00e9ndolos al final.</li> </ul> <p>Si necesitas mayor precisi\u00f3n en operaciones complejas, considera utilizar librer\u00edas especializadas como Big.js o Decimal.js, que manejan n\u00fameros decimales con exactitud.</p>"},{"location":"javascript/operadores-aritmeticos/#prioridad-de-los-operadores-aritmeticos","title":"Prioridad de los Operadores Aritm\u00e9ticos","text":"<p>En JavaScript, los operadores aritm\u00e9ticos se eval\u00faan siguiendo un orden de prioridad predefinido, lo que afecta c\u00f3mo se ejecutan las operaciones en expresiones complejas. Este orden es:</p> <ol> <li>Exponenciaci\u00f3n (<code>**</code>)</li> <li>Multiplicaci\u00f3n (<code>*</code>), Divisi\u00f3n (<code>/</code>) y M\u00f3dulo (<code>%</code>)</li> <li>Suma (<code>+</code>) y Resta (<code>-</code>)</li> </ol> <p>Los operadores con mayor prioridad se eval\u00faan antes. Cuando los operadores tienen la misma prioridad, se ejecutan de izquierda a derecha, excepto la exponenciaci\u00f3n (<code>**</code>), que se eval\u00faa de derecha a izquierda.</p> javascript<pre><code>const resultado = 5 + 2 * 3 ** 2;\n\nconsole.log(resultado);\n</code></pre> <p>Explicaci\u00f3n del ejemplo:</p> <ol> <li>Finalmente, se suma: <code>5 + 18</code> \u2192 <code>23</code>.</li> <li>Primero, se eval\u00faa la exponenciaci\u00f3n: <code>3 ** 2</code> \u2192 <code>9</code>.</li> <li>Luego, se realiza la multiplicaci\u00f3n: <code>2 * 9</code> \u2192 <code>18</code>.</li> </ol> <p>Para cambiar el orden en el que se ejecutan las operaciones puedes usar par\u00e9ntesis, que tienen la prioridad m\u00e1s alta. Esto tambi\u00e9n mejora la legibilidad del c\u00f3digo:</p> javascript<pre><code>const resultado = (5 + 2) * (3 ** 2);\n\nconsole.log(resultado);\n</code></pre> <p>En este caso:</p> <ol> <li>Primero se eval\u00faan las expresiones dentro de los par\u00e9ntesis: <code>5 + 2</code> \u2192 <code>7</code> y <code>3 ** 2</code> \u2192 <code>9</code>.</li> <li>Luego, se realiza la multiplicaci\u00f3n: <code>7 * 9</code> \u2192 <code>63</code>.</li> </ol>"},{"location":"javascript/operadores-aritmeticos/#buenas-practicas-en-el-uso-de-operadores-aritmeticos","title":"Buenas Pr\u00e1cticas en el uso de Operadores Aritm\u00e9ticos","text":"<ul> <li>Usa Par\u00e9ntesis para Claridad: Aunque los operadores tienen prioridad, los par\u00e9ntesis ayudan a que el c\u00f3digo sea m\u00e1s legible.</li> <li>Controla Conversiones Impl\u00edcitas: Conoce c\u00f3mo cada operador convierte valores al usarse con diferentes tipos de datos.</li> <li>Evita Errores de Precisi\u00f3n con Decimales: Considera redondear o manejar decimales con m\u00e9todos adicionales si se requiere precisi\u00f3n.</li> </ul>"},{"location":"javascript/operadores-aritmeticos/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los operadores aritm\u00e9ticos en JavaScript ofrecen gran versatilidad para trabajar con n\u00fameros y datos en el c\u00f3digo. Entender c\u00f3mo operan con distintos tipos, como strings y objetos, as\u00ed como los problemas de precisi\u00f3n con decimales, ayuda a escribir c\u00f3digo preciso y funcional.</p> <p>En el siguiente art\u00edculo profundizaremos en los Operadores de Resto que nos permite obtener el resto de una divisi\u00f3n entre dos n\u00fameros.</p> <p></p>"},{"location":"javascript/operadores-asignacion-logica/","title":"Operadores de Asignaci\u00f3n L\u00f3gica","text":""},{"location":"javascript/operadores-asignacion-logica/#operadores-de-asignacion-logica","title":"Operadores de Asignaci\u00f3n L\u00f3gica","text":"<p>Los operadores de asignaci\u00f3n l\u00f3gica combinan una operaci\u00f3n l\u00f3gica (AND, OR o fusi\u00f3n de nulos) con una asignaci\u00f3n. Esto permite evaluar una condici\u00f3n y asignar el resultado a una variable solo si se cumple el criterio del operador l\u00f3gico correspondiente.</p> <p>En JavaScript, los operadores de asignaci\u00f3n l\u00f3gica son:</p> <ul> <li><code>&amp;&amp;=</code>: Asignaci\u00f3n condicional usando AND.</li> <li><code>||=</code>: Asignaci\u00f3n condicional usando OR.</li> <li><code>??=</code>: Asignaci\u00f3n condicional usando fusi\u00f3n de nulos.</li> </ul> <p> Estos operadores son particularmente \u00fatiles para establecer valores predeterminados y para simplificar el c\u00f3digo que de otra manera requerir\u00eda estructuras condicionales m\u00e1s complejas.</p> <p></p> <p>La siguiente tabla muestra la equivalencia de los operadores de asignaci\u00f3n l\u00f3gica:</p> Asignaci\u00f3n L\u00f3gica Operadores L\u00f3gicos x ||= y x || (x = y) x &amp;&amp;= y x &amp;&amp; (x = y) x ??= y x ?? (x = y)"},{"location":"javascript/operadores-asignacion-logica/#operador-de-asignacion-logica-or","title":"Operador de Asignaci\u00f3n L\u00f3gica OR","text":"<p>El operador <code>||=</code> (OR l\u00f3gico de asignaci\u00f3n) asigna un valor a una variable solo si la variable actual tiene un valor \u201cfalsy\u201d (es decir, <code>false</code>, <code>null</code>, <code>undefined</code>, <code>0</code>, <code>NaN</code>, o <code>\"\"</code>). Si la variable ya tiene un valor \u201ctruthy\u201d (que no es <code>null</code>, <code>undefined</code>, etc.), el operador no realiza la asignaci\u00f3n.</p> javascript<pre><code>variable ||= valorPredeterminado;\n</code></pre> <p>Por ejemplo: En el siguiente ejemplo, <code>nombre</code> es una cadena vac\u00eda (<code>\"\"</code>) que se eval\u00faa como <code>false</code>. Por lo tanto, <code>nombre</code> toma el valor <code>\"Invitado\"</code></p> javascript<pre><code>let nombre = \"\";\nnombre ||= \"Invitado\";\n\nconsole.log(nombre);\n</code></pre> <p>El operador <code>||=</code> es ideal para asignar valores predeterminados o inicializar variables solo cuando su valor actual es \u201cfalsy\u201d.</p> <p>Vemos otro ejemplo:</p> javascript<pre><code>let title = 'JavaScript es Incre\u00edble';\ntitle ||= 'sin t\u00edtulo';\n\nconsole.log(title);\n</code></pre> <p>En este ejemplo la constante <code>title</code> es \u2018JavaScript es Incre\u00edble\u2019 por lo que es <code>truthy</code>. Por lo tanto el operador de asignaci\u00f3n l\u00f3gica OR (<code>||=</code>) no asigna el string \u2018sin t\u00edtulo\u2019 a la variable <code>title</code>.</p> <p>Al igual que el operador l\u00f3gico OR, la asignaci\u00f3n l\u00f3gica OR tambi\u00e9n tiene cortocircuito. Esto significa que el operador de asignaci\u00f3n l\u00f3gica OR solo realiza una asignaci\u00f3n cuando x es falsy.</p>"},{"location":"javascript/operadores-asignacion-logica/#operador-de-asignacion-logica-and","title":"Operador de Asignaci\u00f3n L\u00f3gica AND","text":"<p>El operador <code>&amp;&amp;=</code> (AND l\u00f3gico de asignaci\u00f3n) asigna un valor a una variable solo si la variable actual es \u201ctruthy\u201d (es decir, no es <code>false</code>, <code>null</code>, <code>undefined</code>, <code>0</code>, <code>NaN</code>, o <code>\"\"</code>). Si la variable es \u201cfalsy\u201d, el operador no realiza la asignaci\u00f3n.</p> javascript<pre><code>variable &amp;&amp;= nuevoValor;\n</code></pre> <p>Por ejemplo: En el siguiente ejemplo, como <code>permisos</code> es <code>true</code>, se asigna el valor <code>\"Administrador\"</code>. Si <code>permisos</code> hubiera sido <code>false</code>, la asignaci\u00f3n no se habr\u00eda ejecutado.</p> javascript<pre><code>let permisos = true;\nconst acceso = \"Administrador\";\n\npermisos &amp;&amp;= acceso;\nconsole.log(permisos);\n</code></pre> <p>Este operador es \u00fatil para actualizar un valor solo cuando se cumple una condici\u00f3n espec\u00edfica, como cuando un usuario tiene permisos o un estado est\u00e1 activo.</p>"},{"location":"javascript/operadores-asignacion-logica/#operador-de-fusion-de-nulos-de-asignacion","title":"Operador de Fusi\u00f3n de Nulos de Asignaci\u00f3n","text":"<p>El operador <code>??=</code> asigna un valor a una variable solo si esta es <code>null</code> o <code>undefined</code>. A diferencia de <code>||=</code>, el operador <code>??=</code> no considera valores <code>0</code>, <code>\"\"</code>, o <code>false</code> como <code>null</code> o <code>undefined</code>, permitiendo asignar valores predeterminados solo cuando la variable est\u00e1 realmente vac\u00eda.</p> javascript<pre><code>variable ??= valorPredeterminado;\n</code></pre> <p>Por ejemplo: En el siguiente ejemplo <code>usuario</code> es <code>null</code>, por lo que se le asigna <code>\"Invitado\"</code>. Si <code>usuario</code> hubiera sido <code>\"\"</code> o <code>0</code>, no se habr\u00eda realizado la asignaci\u00f3n.</p> javascript<pre><code>let usuario = null;\nusuario ??= \"Invitado\";\n\nconsole.log(usuario);\n</code></pre> <p>El operador <code>??=</code> es ideal para asignar valores predeterminados solo en los casos en que la variable es <code>null</code> o <code>undefined</code>, lo cual puede ser \u00fatil en la gesti\u00f3n de valores opcionales.</p> <p>Veamos otro ejemplo:</p> javascript<pre><code>const user = {\n  username: 'Satoshi'\n};\nuser.nickname ??= 'an\u00f3nimo';\n\nconsole.log(user);\n</code></pre> <p>En el anterior ejemplo <code>user.nickname</code> es <code>undefined</code>, por lo tanto es nullish. El operador de asignaci\u00f3n de fusi\u00f3n nula asigna el string \u2018an\u00f3nimo\u2019 a la propiedad <code>user.nickname</code>.</p>"},{"location":"javascript/operadores-asignacion-logica/#buenas-practicas-con-operadores-de-asignacion-logica","title":"Buenas Pr\u00e1cticas con Operadores de Asignaci\u00f3n L\u00f3gica","text":"<ul> <li>Prefiere <code>??=</code> para Valores Opcionales: Usa <code>??=</code> cuando necesitas un valor predeterminado solo si la variable es <code>null</code> o <code>undefined</code>, evitando reemplazar (<code>0</code>) o un string vac\u00edo (<code>\"\"</code>) involuntariamente.</li> <li>Usa <code>||=</code> para Valores Predeterminados Flexibles: Utiliza <code>||=</code> cuando una variable pueda tener m\u00faltiples valores \u201cfalsos\u201d (<code>0</code>, <code>NaN</code>, <code>\"\"</code>), pero quieras asignar un valor predeterminado si es necesario.</li> <li>Aprovecha <code>&amp;&amp;=</code> para Condiciones Espec\u00edficas: <code>&amp;&amp;=</code> es \u00fatil para establecer valores cuando una condici\u00f3n es verdadera, especialmente en casos donde se requiere que una variable ya tenga un valor \u201ctruthy\u201d.</li> </ul>"},{"location":"javascript/operadores-asignacion-logica/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los operadores de asignaci\u00f3n l\u00f3gica en JavaScript (<code>||=</code>, <code>&amp;&amp;=</code>, <code>??=</code>) permiten realizar asignaciones de forma condicional en una sola l\u00ednea. Cada operador tiene su propio uso, permitiendo optimizar el c\u00f3digo y evitar asignaciones innecesarias.</p> <p>En el pr\u00f3ximo art\u00edculo exploraremos Operador de Fusi\u00f3n de Nulos en JavaScript</p> <p></p>"},{"location":"javascript/operadores-asignacion/","title":"Operadores de asignaci\u00f3n","text":""},{"location":"javascript/operadores-asignacion/#operadores-de-asignacion","title":"Operadores de Asignaci\u00f3n","text":"<p>Los operadores de asignaci\u00f3n en JavaScript son esenciales para almacenar y actualizar valores en variables. Adem\u00e1s de la asignaci\u00f3n b\u00e1sica (<code>=</code>), existen operadores compuestos que permiten realizar operaciones matem\u00e1ticas y l\u00f3gicas junto con la asignaci\u00f3n en una sola l\u00ednea de c\u00f3digo.</p> <p>En este art\u00edculo exploraremos los operadores de asignaci\u00f3n est\u00e1ndar, sus caracter\u00edsticas, ejemplos y recomendaciones para optimizar su uso.</p>"},{"location":"javascript/operadores-asignacion/#que-es-un-operador-de-asignacion","title":"\u00bfQu\u00e9 es un Operador de Asignaci\u00f3n?","text":"<p>Un operador de asignaci\u00f3n es una entidad que toma el resultado de una expresi\u00f3n y lo almacena en una variable. El operador de asignaci\u00f3n m\u00e1s b\u00e1sico en JavaScript es <code>=</code>, que asigna el valor de la derecha a la variable de la izquierda.</p> <p>Ejemplo de Asignaci\u00f3n B\u00e1sica:</p> javascript<pre><code>const x = 10; // Se asigna el valor 10 a la constante x.\n</code></pre>"},{"location":"javascript/operadores-asignacion/#operadores-de-asignacion-compuestos","title":"Operadores de Asignaci\u00f3n Compuestos","text":"<p>Los operadores de asignaci\u00f3n compuestos en JavaScript realizan una operaci\u00f3n matem\u00e1tica y asignan el resultado a una variable en un solo paso. Estos operadores son ideales para mejorar la legibilidad del c\u00f3digo y optimizar operaciones repetitivas.</p>"},{"location":"javascript/operadores-asignacion/#1-suma-asignacion","title":"1. Suma Asignaci\u00f3n (<code>+=</code>)","text":"<p>El operador <code>+=</code> suma un valor a la variable existente y actualiza su valor. Es \u00fatil en operaciones como acumulaci\u00f3n de totales o incrementos en contadores.</p> javascript<pre><code>let x = 5;\nx += 3; // Equivalente a x = x + 3\n</code></pre> <p>Ejemplo de uso b\u00e1sico: Acumular un total en un bucle:</p> javascript<pre><code>let total = 0;\nfor (let i = 1; i &lt;= 5; i++) {\n  total += i; // Suma los valores del 1 al 5\n}\nconsole.log(total);\n</code></pre>"},{"location":"javascript/operadores-asignacion/#2-resta-asignacion-","title":"2. Resta Asignaci\u00f3n (<code>-=</code>)","text":"<p>El operador <code>-=</code> resta un valor de la variable y actualiza su valor. Es \u00fatil en casos como contadores decrecientes o ajustes acumulativos.</p> javascript<pre><code>let x = 10;\nx -= 4; // Equivalente a x = x - 4\n</code></pre> <p>Ejemplo de uso b\u00e1sico: Reducir el saldo de un cliente tras una compra:</p> javascript<pre><code>let saldo = 100;\nconst gasto = 25;\nsaldo -= gasto; // Reduce el saldo por el gasto\n\nconsole.log(saldo);\n</code></pre>"},{"location":"javascript/operadores-asignacion/#3-multiplicacion-asignacion","title":"3. Multiplicaci\u00f3n Asignaci\u00f3n (<code>*=</code>)","text":"<p>El operador <code>*=</code> multiplica el valor de la variable por el valor especificado y asigna el resultado.</p> javascript<pre><code>let x = 4;\nx *= 2; // Equivalente a x = x * 2\n</code></pre> <p>Ejemplo de uso b\u00e1sico: Calcular el inter\u00e9s compuesto.</p> javascript<pre><code>let capital = 1000;\nconst tasa = 1.05; // 5% anual\ncapital *= tasa; // Primer a\u00f1o\ncapital *= tasa; // Segundo a\u00f1o\n\nconsole.log(capital.toFixed(2));\n</code></pre>"},{"location":"javascript/operadores-asignacion/#4-division-asignacion","title":"4. Divisi\u00f3n Asignaci\u00f3n (<code>/=</code>)","text":"<p>El operador <code>/=</code> divide el valor de la variable entre un divisor y actualiza su valor.</p> javascript<pre><code>let x = 20;\nx /= 5; // Equivalente a x = x / 5\n</code></pre> <p>Ejemplo de uso b\u00e1sico: Repartir un monto entre varias personas.</p> javascript<pre><code>let monto = 100;\nconst personas = 4;\nmonto /= personas;\n\nconsole.log(monto); // 25\n</code></pre>"},{"location":"javascript/operadores-asignacion/#5-resto-asignacion","title":"5. Resto Asignaci\u00f3n (<code>%=</code>)","text":"<p>El operador <code>%=</code> divide el valor de la variable por el divisor y asigna el residuo resultante.</p> javascript<pre><code>let x = 10;\nx %= 3; // Equivalente a x = x % 3\n</code></pre> <p>Ejemplo de uso b\u00e1sico: Determinar si un n\u00famero es par o impar:</p> javascript<pre><code>let numero = 15;\n\nconsole.log(numero % 2 === 0 ? \"Par\" : \"Impar\");\n</code></pre>"},{"location":"javascript/operadores-asignacion/#6-exponenciacion-asignacion","title":"6. Exponenciaci\u00f3n Asignaci\u00f3n (<code>**=</code>)","text":"<p>El operador <code>**=</code> eleva el valor de la variable a la potencia especificada y actualiza su valor.</p> javascript<pre><code>let x = 3;\nx **= 2; // Equivalente a x = x ** 2\n</code></pre> <p>Ejemplo de uso b\u00e1sico: Calcular \u00e1reas o vol\u00famenes:</p> javascript<pre><code>let radio = 3;\nconst exponente = 2; // Potencia cuadrada\nlet area = Math.PI;\narea *= radio ** exponente; // \u00c1rea de un c\u00edrculo\n\nconsole.log(area.toFixed(2));\n</code></pre> <p>En la siguiente tabla se resumen los operadores de asignaci\u00f3n compuestos en JavaScript</p> Operador Significado Descripci\u00f3n a = b a = b Asigna el valor de <code>b</code> a <code>a</code> a += b a = a + b Suma el valor de <code>b</code> a <code>a</code> y asigna el resultado a <code>a</code> a -= b a = a - b Resta el valor de <code>b</code> de <code>a</code> y asigna el resultado a <code>a</code> a *= b a = a * b Multiplica <code>a</code> por el valor de <code>b</code> y asigna el resultado a <code>a</code> a /= b a = a / b Divide <code>a</code> por el valor de <code>b</code> y asigna el resultado a <code>a</code> a %= b a = a % b Calcula el m\u00f3dulo de <code>a</code> con respecto a <code>b</code> y asigna el resultado a <code>a</code> a &amp;= b a = a &amp; b Realiza la operaci\u00f3n AND entre <code>a</code> y <code>b</code> y asigna el resultado a <code>a</code> a |= b a = a | b Realiza la operaci\u00f3n OR entre <code>a</code> y <code>b</code> y asigna el resultado a <code>a</code> a ^= b a = a ^ b Realiza la operaci\u00f3n XOR entre <code>a</code> y <code>b</code> y asigna el resultado a <code>a</code> a &lt;&lt;= b a = a &lt;&lt; b Realiza el desplazamiento de bits a la izquierda en <code>a</code> por <code>b</code> posiciones y asigna el resultado a <code>a</code> a &gt;&gt;= b a = a &gt;&gt; b Realiza el desplazamiento de bits a la derecha (con signo conservado) en <code>a</code> por <code>b</code> posiciones y asigna el resultado a <code>a</code> a &gt;&gt;&gt;= b a = a &gt;&gt;&gt; b Realiza el desplazamiento de bits a la derecha (sin signo) en <code>a</code> por <code>b</code> posiciones y asigna el resultado a <code>a</code>"},{"location":"javascript/operadores-asignacion/#encadenamiento-de-operadores-de-asignacion","title":"Encadenamiento de operadores de asignaci\u00f3n","text":"<p>JavaScript permite encadenar operadores de asignaci\u00f3n para asignar el mismo valor a m\u00faltiples variables en una sola l\u00ednea. Este encadenamiento eval\u00faa la asignaci\u00f3n de derecha a izquierda. Esto puede resultar \u00fatil para asignar un mismo valor a varias variables al mismo tiempo.</p> <p>Por ejemplo, considera el siguiente c\u00f3digo:</p> javascript<pre><code>let a = 10, b = 20, c = 30;\na = b = c; // Todas las variables ahora tienen el valor 30\n</code></pre> <p>JavaScript eval\u00faa las asignaciones de derecha a izquierda. Por lo tanto, primero asigna el valor de <code>c</code> a <code>b</code>, y luego asigna el mismo valor de <code>b</code> a <code>a</code>. Como resultado, todas las variables <code>a</code>, <code>b</code> y <code>c</code> tienen el valor 30.</p> javascript<pre><code>let a, b, c;\na = b = c = 10;  // Asigna 10 a todas las variables\n\nconsole.log(a, b, c);\n</code></pre> <p>En el anterior ejemplo asigna <code>10</code> a <code>c</code>, luego <code>b</code> toma el valor de <code>c</code>, y <code>a</code> toma el valor de <code>b</code>. Todas las variables terminan con el valor <code>10</code>.</p> <p>Este tipo de encadenamiento de operadores de asignaci\u00f3n puede ser \u00fatil cuando se trabaja con variables relacionadas que deben tener el mismo valor.</p> <p> El encadenamiento puede ser \u00fatil, pero es recomendable usarlo solo en situaciones simples para mantener la claridad del c\u00f3digo.</p> <p></p>"},{"location":"javascript/operadores-asignacion/#buenas-practicas-con-operadores-de-asignacion","title":"Buenas Pr\u00e1cticas con Operadores de Asignaci\u00f3n","text":""},{"location":"javascript/operadores-asignacion/#1-usa-operadores-compuestos-para-simplificar-el-codigo","title":"1. Usa Operadores Compuestos para Simplificar el C\u00f3digo","text":"<p>Los operadores de asignaci\u00f3n compuestos (<code>+=</code>, <code>-=</code>, <code>*=</code>, etc.) reducen el c\u00f3digo y mejoran la legibilidad en operaciones repetitivas.</p>"},{"location":"javascript/operadores-asignacion/#2-encadenamiento-para-asignaciones-simultaneas","title":"2. Encadenamiento para Asignaciones Simult\u00e1neas","text":"<p>Si necesitas asignar el mismo valor a varias variables, el encadenamiento puede ser \u00fatil, pero evita su uso excesivo en casos complejos.</p>"},{"location":"javascript/operadores-asignacion/#3-familiarizate-con-la-prioridad-de-operadores","title":"3. Familiar\u00edzate con la Prioridad de Operadores","text":"<p>Recuerda que los operadores de asignaci\u00f3n tienen una prioridad baja en el orden de evaluaci\u00f3n. Esto significa que, en una expresi\u00f3n, otros operadores como <code>+</code>, <code>*</code>, etc., se eval\u00faan primero. Usa par\u00e9ntesis si necesitas alterar el orden de evaluaci\u00f3n.</p>"},{"location":"javascript/operadores-asignacion/#4-evita-modificar-objetos-directamente-con-operadores-de-asignacion","title":"4. Evita Modificar Objetos Directamente con Operadores de Asignaci\u00f3n","text":"<p>En JavaScript, asignar un objeto a otro copia la referencia del objeto, no el valor. Para modificar una copia sin afectar el objeto original, usamos t\u00e9cnicas como la desestructuraci\u00f3n o el spread operator.</p> <p>Ejemplo Incorrecto:</p> javascript<pre><code>const original = { nombre: \"Juan\" };\nconst copia = original;\ncopia.nombre = \"Ana\";\n\nconsole.log(original.nombre);\n</code></pre> <p>Ejemplo Correcto:</p> javascript<pre><code>const original = { nombre: \"Juan\" };\nconst copia = { ...original };\ncopia.nombre = \"Ana\";\n\nconsole.log(original.nombre);\n</code></pre>"},{"location":"javascript/operadores-asignacion/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los operadores de asignaci\u00f3n en JavaScript facilitan la actualizaci\u00f3n de valores en variables de una manera eficiente y concisa. Al dominar los operadores de asignaci\u00f3n compuestos y el encadenamiento, puedes escribir c\u00f3digo m\u00e1s legible y eficiente. Adem\u00e1s, aplicar buenas pr\u00e1cticas garantiza que los operadores se usen de forma clara y sin errores en el c\u00f3digo.</p> <p>En el pr\u00f3ximo art\u00edculo, exploraremos los Operadores Unarios en JavaScript, cubriendo los operadores <code>++</code>, <code>--</code>, y otros operadores espec\u00edficos para trabajar con valores individuales.</p> <p></p>"},{"location":"javascript/operadores-comparacion/","title":"Operadores de Comparaci\u00f3n","text":""},{"location":"javascript/operadores-comparacion/#operadores-de-comparacion","title":"Operadores de Comparaci\u00f3n","text":"<p>Los operadores de comparaci\u00f3n en JavaScript permiten comparar valores para evaluar condiciones. Estos son el n\u00facleo de la l\u00f3gica de un programa, permitiendo evaluar condiciones y dirigir el flujo de un script con base en resultados espec\u00edficos, ya que tomar decisiones inteligentes en c\u00f3digo depende de la capacidad de comparar valores de forma precisa y eficiente.</p> <p>En este art\u00edculo exploraremos a fondo c\u00f3mo funcionan, qu\u00e9 casos de uso resuelven y c\u00f3mo emplearlos para escribir c\u00f3digo m\u00e1s robusto y confiable.</p>"},{"location":"javascript/operadores-comparacion/#que-es-un-operador-de-comparacion","title":"\u00bfQu\u00e9 es un Operador de Comparaci\u00f3n?","text":"<p>Los operadores de comparaci\u00f3n comparan dos valores y devuelven un valor booleano (<code>true</code> o <code>false</code>). En JavaScript, estos operadores se utilizan com\u00fanmente en declaraciones condicionales para determinar el flujo del programa.</p>"},{"location":"javascript/operadores-comparacion/#operadores-de-igualdad","title":"Operadores de Igualdad","text":"<p>JavaScript ofrece dos tipos de operadores de igualdad: igualdad d\u00e9bil (<code>==</code>) y igualdad estricta (<code>===</code>). Ambos permiten comparar valores, pero se comportan de manera distinta respecto a la conversi\u00f3n de tipos.</p>"},{"location":"javascript/operadores-comparacion/#1-igualdad-debil","title":"1. Igualdad D\u00e9bil (<code>==</code>)","text":"<p>El operador <code>==</code> compara dos valores despu\u00e9s de convertir sus tipos (si es necesario). Esta conversi\u00f3n impl\u00edcita puede producir resultados inesperados si no se usa con precauci\u00f3n.</p> javascript<pre><code>console.log(5 == \"5\");  // (convierte \"5\" a n\u00famero)\nconsole.log(true == 1); // (convierte true a 1)\nconsole.log(null == undefined); // (ambos se tratan como iguales)\n</code></pre> <p>Aunque la igualdad d\u00e9bil puede ser conveniente, es recomendable evitarla para evitar errores en la l\u00f3gica del programa.</p>"},{"location":"javascript/operadores-comparacion/#2-igualdad-estricta","title":"2. Igualdad Estricta (<code>===</code>)","text":"<p>El operador <code>===</code> compara valores sin realizar ninguna conversi\u00f3n de tipos. Esto significa que ambos valores deben tener el mismo tipo y valor para que la comparaci\u00f3n sea <code>true</code>.</p> javascript<pre><code>console.log(5 === \"5\");  // (no convierte \"5\" a n\u00famero)\nconsole.log(true === 1); // (distintos tipos)\nconsole.log(null === undefined); // (diferentes valores)\n</code></pre> <p>Usa <code>===</code> siempre que sea posible, ya que proporciona una comparaci\u00f3n m\u00e1s precisa y evita errores de conversi\u00f3n de tipo.</p>"},{"location":"javascript/operadores-comparacion/#operadores-de-desigualdad","title":"Operadores de Desigualdad","text":"<p>Los operadores de desigualdad tambi\u00e9n pueden realizar comparaciones con o sin conversi\u00f3n de tipos. Existen dos variantes: desigualdad d\u00e9bil (<code>!=</code>) y desigualdad estricta (<code>!==</code>).</p>"},{"location":"javascript/operadores-comparacion/#1-desigualdad-debil","title":"1. Desigualdad D\u00e9bil (<code>!=</code>)","text":"<p>El operador <code>!=</code> compara valores y realiza una conversi\u00f3n de tipos si es necesario, devolviendo <code>true</code> si los valores son diferentes.</p> javascript<pre><code>console.log(5 != \"5\");  // (convierte \"5\" a n\u00famero)\nconsole.log(false != 0); // (convierte false a 0)\nconsole.log(null != undefined); // (ambos se consideran iguales)\n</code></pre>"},{"location":"javascript/operadores-comparacion/#2-desigualdad-estricta","title":"2. Desigualdad Estricta (<code>!==</code>)","text":"<p>El operador <code>!==</code> compara dos valores sin realizar conversi\u00f3n de tipos. Devuelve <code>true</code> solo si los valores y tipos son distintos.</p> javascript<pre><code>console.log(5 !== \"5\");  // (diferentes tipos)\nconsole.log(false !== 0); // (distintos tipos)\nconsole.log(null !== undefined); // (diferentes valores)\n</code></pre> <p>Consejo: Al igual que con <code>===</code>, usa <code>!==</code> para garantizar que la comparaci\u00f3n respete el tipo de datos y evitar conversiones impl\u00edcitas.</p>"},{"location":"javascript/operadores-comparacion/#comparacion-de-valores-mayor-que-menor-que","title":"Comparaci\u00f3n de valores Mayor que / Menor que","text":"<p>Los operadores de mayor y menor se utilizan para comparar valores num\u00e9ricos. Tambi\u00e9n pueden utilizarse con strings, donde comparan en base al orden lexicogr\u00e1fico. Estos operadores siguen las siguientes reglas:</p> <ul> <li>(Mayor que) <code>&gt;</code> : Devuelve <code>true</code> si el valor de la izquierda es mayor que el de la derecha.</li> <li>(Menor que) <code>&lt;</code> : Devuelve <code>true</code> si el valor de la izquierda es menor que el de la derecha.</li> <li>(Mayor o igual que) <code>&gt;=</code> : Devuelve <code>true</code> si el valor de la izquierda es mayor o igual al de la derecha.</li> <li>(Menor o igual que) <code>&lt;=</code> : Devuelve <code>true</code> si el valor de la izquierda es menor o igual al de la derecha.</li> </ul> <p>Ejemplo de Comparaci\u00f3n de N\u00fameros:</p> javascript<pre><code>const a = 10;\nconst b = 5;\n\nconsole.log(a &gt; b);\nconsole.log(a &lt; b);\nconsole.log(a &gt;= 10);\nconsole.log(b &lt;= 5);\n</code></pre>"},{"location":"javascript/operadores-comparacion/#comparacion-de-strings","title":"Comparaci\u00f3n de Strings","text":"<p>Cuando se comparan strings, JavaScript eval\u00faa su orden alfab\u00e9tico basado en la posici\u00f3n de los caracteres en Unicode.</p> javascript<pre><code>console.log(\"banana\" &gt; \"apple\");\nconsole.log(\"2\" &gt; \"12\"); // (compara car\u00e1cter a car\u00e1cter)\n</code></pre> <p>Para evitar confusi\u00f3n con strings num\u00e9ricos (<code>\"2\"</code> y <code>\"12\"</code>), convi\u00e9rtelos a n\u00fameros antes de comparar.</p>"},{"location":"javascript/operadores-comparacion/#comparar-un-booleano-con-otro-valor","title":"Comparar un Booleano Con Otro Valor","text":"<p>Si un valor es booleano, JavaScript lo convierte en un n\u00famero y compara el valor convertido con el otro valor; <code>true</code> se convierte a <code>1</code> y <code>false</code> se convierte a <code>0</code>.</p> javascript<pre><code>console.log(true &gt; 0);\nconsole.log(false &lt; 1);\nconsole.log(true &gt; false);\nconsole.log(false &gt; true);\nconsole.log(true &gt;= true);\nconsole.log(true &lt;= true);\nconsole.log(false &lt;= false);\nconsole.log(false &gt;= false);\n</code></pre> <p>Adem\u00e1s de las reglas anteriores, los operadores igual (<code>==</code>) y no igual (<code>!=</code>) tambi\u00e9n tienen las mismas reglas.</p>"},{"location":"javascript/operadores-comparacion/#comparacion-especial-con-objectis","title":"Comparaci\u00f3n Especial con <code>Object.is()</code>","text":"<p>El m\u00e9todo <code>Object.is()</code> es similar al operador <code>===</code> pero trata algunos casos de forma distinta, proporcionando una comparaci\u00f3n m\u00e1s precisa en ciertas situaciones:</p> <ol> <li><code>NaN</code> se considera igual a <code>NaN</code>.</li> <li><code>+0</code> y <code>-0</code> se consideran diferentes.</li> </ol> javascript<pre><code>console.log(Object.is(NaN, NaN));\nconsole.log(Object.is(+0, -0));\nconsole.log(Object.is(5, 5));\n</code></pre> <p>Cu\u00e1ndo Usar <code>Object.is()</code>: Este m\u00e9todo es \u00fatil cuando necesitas una comparaci\u00f3n estricta y quieres evitar el problema de NaN o los signos opuestos de <code>0</code>.</p>"},{"location":"javascript/operadores-comparacion/#comparar-null-y-undefined","title":"Comparar null y undefined","text":"<p>Comparar <code>null</code> y <code>undefined</code> en JavaScript es interesante. Ambos representan la ausencia de un valor pero tienen comportamientos ligeramente diferentes al compararlos entre s\u00ed o con otros valores.</p> <p>Cuando se comparan directamente <code>null</code> y <code>undefined</code> son iguales en valor, pero no en tipo (<code>null</code> es de tipo \u201cobject\u201d y <code>undefined</code> es de tipo \u201cundefined\u201d). Sin embargo, cuando se comparan con otros valores, tanto <code>null</code> como <code>undefined</code> se convierten en <code>0</code>, lo que puede generar resultados inesperados en las comparaciones num\u00e9ricas. Veamos esto en ejemplos:</p> javascript<pre><code>console.log(null == undefined);\nconsole.log(null === undefined);\n\nconsole.log(null == 0);\nconsole.log(undefined == 0);\n\nconsole.log(null &lt; 0);\nconsole.log(undefined &lt; 0);\n</code></pre>"},{"location":"javascript/operadores-comparacion/#buenas-practicas-con-operadores-de-comparacion","title":"Buenas Pr\u00e1cticas con Operadores de Comparaci\u00f3n","text":"<ol> <li>Prefiere <code>===</code> y <code>!==</code> sobre <code>==</code> y <code>!=</code>: La igualdad estricta y desigualdad estricta evitan problemas de conversi\u00f3n impl\u00edcita y garantizan comparaciones precisas.</li> <li>Usa <code>Object.is()</code> para Comparaciones Especiales: En casos donde necesites comparar <code>NaN</code> o distinguir entre <code>+0</code> y <code>-0</code>, <code>Object.is()</code> proporciona mayor precisi\u00f3n.</li> <li>Convierte Strings Num\u00e9ricos Antes de Comparar: Para evitar errores al comparar strings que representan n\u00fameros, convi\u00e9rtelos a n\u00famero con <code>+</code> o <code>Number()</code>.</li> </ol>"},{"location":"javascript/operadores-comparacion/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los operadores de comparaci\u00f3n en JavaScript son herramientas esenciales para evaluar condiciones. Comprender las diferencias entre igualdad d\u00e9bil y estricta, as\u00ed como los casos especiales de <code>Object.is()</code>, permite escribir c\u00f3digo m\u00e1s preciso y evitar errores comunes en la l\u00f3gica. Al dominar estos operadores, puedes realizar comparaciones efectivas para cualquier tipo de dato.</p> <p>En el pr\u00f3ximo art\u00edculo exploraremos los Operadores L\u00f3gicos en JavaScript y c\u00f3mo utilizarlos para combinar y evaluar condiciones m\u00faltiples.</p> <p></p>"},{"location":"javascript/operadores-logicos/","title":"Operadores l\u00f3gicos","text":""},{"location":"javascript/operadores-logicos/#operadores-logicos","title":"Operadores l\u00f3gicos","text":"<p>Los operadores l\u00f3gicos en JavaScript permiten combinar y evaluar condiciones, facilitando la toma de decisiones y el control del flujo de un programa. En este art\u00edculo, exploraremos los tres operadores l\u00f3gicos principales: <code>&amp;&amp;</code> (AND), <code>||</code> (OR) y <code>!</code> (NOT), explicando c\u00f3mo funcionan y cu\u00e1ndo usarlos en distintos contextos.</p>"},{"location":"javascript/operadores-logicos/#que-son-los-operadores-logicos","title":"\u00bfQu\u00e9 son los Operadores L\u00f3gicos?","text":"<p>Los operadores l\u00f3gicos en JavaScript son entidades que se utilizan para evaluar expresiones booleanas, devolviendo <code>true</code> o <code>false</code> seg\u00fan las condiciones evaluadas. Estos operadores son fundamentales para construir l\u00f3gica condicional en estructuras del lenguajes como if, while, y for.</p>"},{"location":"javascript/operadores-logicos/#operador-logico-and","title":"Operador L\u00f3gico AND (&amp;&amp;)","text":"<p>El operador <code>&amp;&amp;</code> (AND) eval\u00faa dos expresiones y devuelve <code>true</code> solo si ambas son verdaderas. Si alguna de las expresiones es <code>false</code>, el operador <code>&amp;&amp;</code> devuelve <code>false</code>. Este operador eval\u00faa de izquierda a derecha y usa un cortocircuito: Es decir, si la primera expresi\u00f3n es <code>false</code>, no eval\u00faa la segunda.</p> <p>Sintaxis:</p> javascript<pre><code>resultado = expr1 &amp;&amp; expr2;\n</code></pre> <p>En el siguiente ejemplo ambas condiciones pasadas deben ser verdaderas para permitir la conducci\u00f3n.</p> javascript<pre><code>const edad = 25;\nconst tieneLicencia = true;\n\nif (edad &gt;= 18 &amp;&amp; tieneLicencia) {\n  console.log(\"Puedes conducir.\");\n} else {\n  console.log(\"No puedes conducir.\");\n}\n</code></pre>"},{"location":"javascript/operadores-logicos/#cortocircuito-con","title":"Cortocircuito con <code>&amp;&amp;</code>","text":"<p>Cuando el operador <code>&amp;&amp;</code> encuentra una expresi\u00f3n <code>false</code> deja de evaluar las dem\u00e1s. Esto permite optimizar el c\u00f3digo y evita ejecutar c\u00f3digo innecesario.</p> javascript<pre><code>const resultado = false &amp;&amp; (5 / 0);\n\nconsole.log(resultado);\n</code></pre> <p>Utiliza <code>&amp;&amp;</code> para validar m\u00faltiples condiciones que deben cumplirse en su totalidad o para evitar que se ejecute c\u00f3digo innecesario si una condici\u00f3n falla.</p>"},{"location":"javascript/operadores-logicos/#operador-logico-or","title":"Operador L\u00f3gico OR (<code>||</code>)","text":"<p>El operador l\u00f3gico <code>||</code> (OR) eval\u00faa dos expresiones y devuelve <code>true</code> si al menos una de ellas es verdadera. Si ambas expresiones son <code>false</code>, entonces <code>||</code> devuelve <code>false</code>.</p> <p>Este operador tambi\u00e9n aplica cortocircuito: si la primera expresi\u00f3n es true, no eval\u00faa la segunda.</p> <p>Sintaxis:</p> javascript<pre><code>resultado = expr1 || expr2;\n</code></pre> <p>En el siguiente ejemplo: <code>usuario</code> es una cadena vac\u00eda (<code>\"\"</code>) que se eval\u00faa como <code>false</code>. Por lo tanto, <code>nombre</code> toma el valor de <code>nombrePredeterminado</code>.</p> javascript<pre><code>const usuario = \"\";\nconst nombrePredeterminado = \"Invitado\";\n\nconst nombre = usuario || nombrePredeterminado;\nconsole.log(nombre);\n</code></pre>"},{"location":"javascript/operadores-logicos/#cortocircuito-con_1","title":"Cortocircuito con <code>||</code>","text":"<p>El operador <code>||</code> detiene la evaluaci\u00f3n si encuentra un valor <code>true</code>, omitiendo el resto de las expresiones.</p> javascript<pre><code>const resultado = true || (5 / 0);\n\nconsole.log(resultado);\n</code></pre> <p>Tip de Uso: <code>||</code> es ideal para establecer valores predeterminados o para verificar que al menos una condici\u00f3n sea verdadera.</p>"},{"location":"javascript/operadores-logicos/#operador-logico-not","title":"Operador L\u00f3gico NOT (<code>!</code>)","text":"<p>El operador <code>!</code> (NOT) invierte el valor booleano de una expresi\u00f3n. Si una expresi\u00f3n es <code>true</code>, el operador NOT la convierte en <code>false</code> y viceversa. Este operador es \u00fatil para validar condiciones opuestas o para comprobar si una variable no cumple con un valor esperado.</p> <p>Sintaxis:</p> javascript<pre><code>resultado = !expr;\n</code></pre> <p>El siguiente ejemplo <code>!acceso</code> invierte el valor de <code>acceso</code> para verificar si es <code>false</code>.</p> javascript<pre><code>const acceso = false;\n\nif (!acceso) {\n  console.log(\"Acceso denegado.\");\n} else {\n  console.log(\"Bienvenido.\");\n}\n</code></pre> <p>El operador l\u00f3gico NOT funciona bas\u00e1ndose en las siguientes reglas:</p> javascript<pre><code>!a\n</code></pre> <p>Seg\u00fan la expresi\u00f3n anterior:</p> <ul> <li>Si <code>a</code> es as\u00ed <code>undefined</code>, el resultado es <code>true</code>.</li> <li>Si <code>a</code> es as\u00ed <code>null</code>, el resultado es <code>true</code>.</li> <li>Si <code>a</code> es un n\u00famero distinto de <code>0</code>, el resultado es <code>false</code>.</li> <li>Si <code>a</code> es as\u00ed <code>NaN</code>, el resultado es <code>true</code>.</li> <li>Si <code>a</code> es un objeto, el resultado es <code>false</code>.</li> <li>Si <code>a</code> es un string vac\u00edo, el resultado es verdadero. En el caso <code>a</code> de que sea un string no vac\u00edo, el resultado es <code>false</code></li> </ul> javascript<pre><code>console.log(!undefined);\nconsole.log(!null);\nconsole.log(!20);\nconsole.log(!0);\nconsole.log(!NaN);\nconsole.log(!{});\nconsole.log(!'');\nconsole.log(!'OK');\nconsole.log(!false);\nconsole.log(!true);\n</code></pre>"},{"location":"javascript/operadores-logicos/#doble-negacion","title":"Doble negaci\u00f3n (<code>!!</code>)","text":"<p>A veces es posible que veas la doble negaci\u00f3n (<code>!!</code>) en el c\u00f3digo. Este se utiliza para convertir un valor a su valor booleano real.</p> <p>El doble NOT (<code>!!</code>) convierte cualquier valor a booleano, siendo una manera r\u00e1pida de evaluar si una variable tiene un valor \u201cverdadero\u201d o \u201cfalso\u201d.</p> javascript<pre><code>const nombre = \"JavaScript\";\n\nconsole.log(!!nombre);  // (tiene un valor)\n</code></pre> <p>El resultado es el mismo que si se utilizara la funci\u00f3n booleana() . Usa <code>!!</code> para convertir expresiones en booleanos sin necesidad de una declaraci\u00f3n <code>if</code>.</p>"},{"location":"javascript/operadores-logicos/#combinacion-de-operadores-logicos","title":"Combinaci\u00f3n de Operadores L\u00f3gicos","text":"<p>JavaScript permite combinar operadores l\u00f3gicos en una sola expresi\u00f3n, lo cual es \u00fatil para evaluar m\u00faltiples condiciones. La prioridad del operador l\u00f3gico determina el orden en que se eval\u00faan las expresiones l\u00f3gicas en JavaScript. En general, el operador <code>&amp;&amp;</code> (Y l\u00f3gico) tiene mayor prioridad que el operador <code>||</code> (O l\u00f3gico). Esto significa que las expresiones con <code>&amp;&amp;</code> se eval\u00faan antes que las expresiones con <code>||</code>.</p> <p>En otras palabras, la precedencia de los operadores es el orden de evaluaci\u00f3n de los operadores l\u00f3gicos en una expresi\u00f3n.</p> <p>Ejemplo de Combinaci\u00f3n:</p> javascript<pre><code>const edad = 20;\nconst tieneLicencia = true;\nconst haTomadoCurso = false;\n\nif ((edad &gt;= 18 &amp;&amp; tieneLicencia) || haTomadoCurso) {\n  console.log(\"Puedes acceder al sistema.\");\n} else {\n  console.log(\"No tienes acceso.\");\n}\n</code></pre> <p>En el ejemplo anterior:</p> <ol> <li>Primero se eval\u00faa <code>(edad &gt;= 18 &amp;&amp; tieneLicencia)</code>, que es <code>true</code>.</li> <li>Luego se eval\u00faa <code>true || haTomadoCurso</code>, que tambi\u00e9n es <code>true</code>, por lo que la condici\u00f3n se cumple.</li> </ol> <p>Usa par\u00e9ntesis para asegurarte de que las condiciones se eval\u00faen en el orden correcto y mejorar la legibilidad del c\u00f3digo.</p>"},{"location":"javascript/operadores-logicos/#buenas-practicas-con-operadores-logicos","title":"Buenas Pr\u00e1cticas con Operadores L\u00f3gicos","text":"<ol> <li>Usa <code>&amp;&amp;</code> y <code>||</code> para Asignar Valores Predeterminados: Estos operadores pueden simplificar asignaciones de valores predeterminados y evitar el uso excesivo de <code>if</code></li> <li>Doble NOT (<code>!!</code>) para Evaluaci\u00f3n Booleana: El uso de <code>!!</code> es una forma r\u00e1pida de convertir cualquier valor en booleano, \u00fatil para verificar si una variable tiene un valor asignado.</li> <li>Evita Expresiones Demasiado Largas: Al combinar m\u00faltiples operadores l\u00f3gicos, usa par\u00e9ntesis para mantener la claridad y garantizar el orden de evaluaci\u00f3n deseado.</li> <li>Aprovecha el Cortocircuito: Usa el comportamiento de cortocircuito de <code>&amp;&amp;</code> y <code>||</code> para evitar la ejecuci\u00f3n de operaciones innecesarias y optimizar el rendimiento.</li> </ol>"},{"location":"javascript/operadores-logicos/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los operadores l\u00f3gicos en JavaScript son herramientas esenciales para evaluar m\u00faltiples condiciones y tomar decisiones complejas de forma sencilla. Al dominar <code>&amp;&amp;</code>, <code>||</code> y <code>!</code>, puedes escribir c\u00f3digo m\u00e1s claro y eficiente, permitiendo controlar el flujo de tu programa de manera precisa.</p> <p>En el pr\u00f3ximo art\u00edculo exploraremos los Operadores de Asignaci\u00f3n en JavaScript y c\u00f3mo pueden ayudarte a asignar valores de manera m\u00e1s flexible y controlada.</p> <p></p>"},{"location":"javascript/operadores-unarios/","title":"Operadores Unarios","text":""},{"location":"javascript/operadores-unarios/#operadores-unarios","title":"Operadores Unarios","text":"<p>En JavaScript, los operadores unarios son herramientas que permiten realizar transformaciones y manipulaciones sobre valores individuales con una sola instrucci\u00f3n. Desde convertir cadenas num\u00e9ricas en n\u00fameros hasta optimizar c\u00e1lculos incrementales o decrecientes, estos operadores son esenciales para resolver tareas comunes de forma elegante y eficiente.</p> <p>Los operadores unarios de conversi\u00f3n, incremento y decremento nos permiten manipular valores num\u00e9ricos de manera r\u00e1pida y eficiente. En este tutorial exploraremos c\u00f3mo funcionan y c\u00f3mo utilizarlos en diferentes contextos.</p>"},{"location":"javascript/operadores-unarios/#introduccion-a-los-operadores-unarios","title":"Introducci\u00f3n a los Operadores Unarios","text":"<p>Los operadores unarios son aquellos que trabajan con un solo valor. La siguiente lista detalla los operadores unarios y sus funciones:</p> <ul> <li>Unario Mas <code>+x</code> : Convierte un valor en n\u00famero</li> <li>Menos Unario <code>-x</code> : Convierte un valor en n\u00famero y lo niega</li> <li>Incremento (Prefijo) <code>++x</code> : A\u00f1ade uno al valor antes de su uso</li> <li>Decremento (Prefijo) <code>--x</code> : Resta uno al valor antes de su uso</li> <li>Incremento (Postfijo) <code>x++</code> : A\u00f1ade uno al valor despu\u00e9s de su uso</li> <li>Decremento (Postfijo) <code>x--</code> : Resta uno al valor despu\u00e9s de su uso</li> </ul>"},{"location":"javascript/operadores-unarios/#conversion-numerica-con-operadores-unarios","title":"Conversi\u00f3n Num\u00e9rica con Operadores Unarios","text":"<p>Los operadores unarios <code>+</code> y <code>-</code> permiten convertir un valor en n\u00famero, facilitando as\u00ed las operaciones aritm\u00e9ticas en JavaScript, especialmente cuando se trata de strings que representan n\u00fameros.</p>"},{"location":"javascript/operadores-unarios/#1-unario-mas-x","title":"1. Unario M\u00e1s (<code>+x</code>)","text":"<p>El operador unario <code>+</code> convierte un valor en n\u00famero. Es \u00fatil cuando se quiere asegurar que una variable se trate como n\u00famero, especialmente en el caso de strings num\u00e9ricos. Para esto el interprete utiliza la funci\u00f3n <code>Number()</code> siguiendo las siguientes reglas:</p> <ul> <li>Para valores booleanos, false se convierte en 0 y true en 1.</li> <li>Para strings o cadenas, se aplica una conversi\u00f3n de acuerdo con un conjunto espec\u00edfico de reglas.</li> <li>Para objetos, se llama al m\u00e9todo <code>valueOf()</code> y/o <code>toString()</code> para obtener el valor a convertir.</li> </ul> javascript<pre><code>const a = \"5\";\n\nconsole.log(+a); // (convertido a n\u00famero)\nconsole.log(typeof +a);\n</code></pre> <p>Tener en cuenta que si el valor no es un n\u00famero ni un string num\u00e9rico, el resultado ser\u00e1 <code>NaN</code> (Not-a-Number).</p> <p>Ejemplo de Conversi\u00f3n con <code>+</code>: Este operador es ideal en casos donde se reciben datos en formato de texto que deben tratarse como n\u00fameros:</p> javascript<pre><code>const stringNumerico = \"42\";\nconst suma = +stringNumerico + 8;  // Convierte \"42\" a 42 y suma 8\n\nconsole.log(suma); \n</code></pre>"},{"location":"javascript/operadores-unarios/#2-unario-menos-x","title":"2. Unario Menos (<code>-x</code>)","text":"<p>El operador <code>-</code> convierte un valor en n\u00famero y lo niega. Esto es \u00fatil para transformar un string num\u00e9rico en su equivalente negativo o para invertir el valor num\u00e9rico de una variable.</p> javascript<pre><code>const b = \"10\";\n\nconsole.log(-b);\n</code></pre>"},{"location":"javascript/operadores-unarios/#ejemplo-de-conversion-con-","title":"Ejemplo de Conversi\u00f3n con <code>-</code>","text":"javascript<pre><code>const numTexto = \"8\";\nconst resultado = -numTexto;  // Convierte \"8\" a -8\n\nconsole.log(resultado);\n</code></pre> <p>Este operador tambi\u00e9n devuelve <code>NaN</code> si el valor no se puede convertir a n\u00famero.</p>"},{"location":"javascript/operadores-unarios/#operadores-de-incremento-y-decremento","title":"Operadores de Incremento y Decremento","text":"<p>Los operadores de incremento (<code>++</code>) y decremento (<code>--</code>) aumentan o disminuyen el valor de una variable en <code>1</code>. En JavaScript se pueden utilizar en dos formas: prefijo y postfijo y el orden en que se aplica afecta el resultado.</p>"},{"location":"javascript/operadores-unarios/#1-incremento","title":"1. Incremento (<code>++</code>)","text":"<p>El operador <code>++</code> incrementa el valor de una variable en <code>1</code>. Existen dos maneras de usarlo: prefijo (<code>++x</code>) y postfijo (<code>x++</code>).</p> <p>Prefijo (<code>++x</code>): Cuando <code>++</code> se usa antes de la variable incrementa su valor inmediatamente y luego devuelve el valor incrementado. Esto es \u00fatil en casos donde el valor actualizado es necesario para la operaci\u00f3n.</p> javascript<pre><code>let x = 5;\n\nconsole.log(++x);  // incrementa antes de usar\nconsole.log(x);\n</code></pre> <p>Postfijo (<code>x++</code>): Cuando <code>++</code> se usa despu\u00e9s de la variable devuelve el valor actual y luego lo incrementa. Esto permite utilizar el valor original en una expresi\u00f3n antes de actualizarlo.</p> javascript<pre><code>let y = 5;\n\nconsole.log(y++); // usa primero, incrementa despu\u00e9s\nconsole.log(y);\n</code></pre> <p> El prefijo es preferible cuando se necesita el valor actualizado de inmediato, mientras que el postfijo es \u00fatil cuando se desea mantener el valor original temporalmente.</p> <p></p>"},{"location":"javascript/operadores-unarios/#2-decremento-","title":"2. Decremento (<code>--</code>)","text":"<p>El operador <code>--</code> funciona de manera similar a <code>++</code>, pero disminuye el valor de la variable en <code>1</code>.</p> <p>Prefijo (<code>--x</code>): Cuando <code>--</code> se usa antes de la variable, decrementa el valor inmediatamente y luego devuelve el valor decrementado.</p> javascript<pre><code>let z = 3;\n\nconsole.log(--z);\nconsole.log(z);\n</code></pre> <p>Postfijo (<code>x--</code>): Cuando <code>--</code> se usa despu\u00e9s de la variable, devuelve el valor actual y luego lo decrementa.</p> javascript<pre><code>let w = 3;\n\nconsole.log(w--);  // usa primero, decrementa despu\u00e9s\nconsole.log(w);    //\n</code></pre> <p> Como con ++, usa el prefijo para tener el valor actualizado de inmediato y el postfijo cuando necesitas el valor original primero.</p> <p></p>"},{"location":"javascript/operadores-unarios/#aplicaciones-y-buenas-practicas","title":"Aplicaciones y Buenas Pr\u00e1cticas","text":"<p>Los operadores <code>+</code> y <code>-</code> son una forma r\u00e1pida y compacta de convertir strings a n\u00fameros en lugar de usar las funciones clasicas <code>Number()</code> o <code>parseInt()</code>.</p> <p>Ejemplo de Conversi\u00f3n:</p> javascript<pre><code>const valorTexto = \"100\";\nconst resultado = +valorTexto * 2;  // Convierte a n\u00famero y multiplica\n\nconsole.log(resultado);\n</code></pre>"},{"location":"javascript/operadores-unarios/#seleccionar-entre-prefijo-y-postfijo-con-incrementodecremento","title":"Seleccionar Entre Prefijo y Postfijo con Incremento/Decremento","text":"<p>Elige prefijo o postfijo en funci\u00f3n de cu\u00e1ndo necesitas el valor actualizado. Por ejemplo, en ciclos <code>for</code>, el postfijo <code>i++</code> es com\u00fan porque se eval\u00faa la condici\u00f3n primero y se incrementa despu\u00e9s.</p> javascript<pre><code>let = 10\nfor (let i = 0; i &lt; 5; i++) {\n  console.log(i);\n}\n</code></pre>"},{"location":"javascript/operadores-unarios/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los operadores unarios de conversi\u00f3n, incremento y decremento en JavaScript son fundamentales para manipular valores de manera eficiente. Con <code>+</code> y <code>-</code>, puedes convertir strings a n\u00fameros de forma r\u00e1pida. Los operadores <code>++</code> y <code>--</code> permiten incrementar y decrementar valores de acuerdo a la necesidad de cada contexto, ya sea en prefijo o postfijo.</p> <p>En el pr\u00f3ximo art\u00edculo, exploraremos los Operadores de Comparaci\u00f3n en JavaScript, ideales para tomar decisiones y establecer condiciones en tu programa.</p> <p></p>"},{"location":"javascript/optional-catch-binding/","title":"Optional Catch Binding","text":""},{"location":"javascript/optional-catch-binding/#optional-catch-binding","title":"Optional Catch Binding","text":"<p>La introducci\u00f3n del optional catch binding (Manejo Opcional del Error en Catch) en ES2019 simplifica la sintaxis del bloque try\u2026catch al permitir omitir el identificador del error en el bloque <code>catch</code>. Esto resulta \u00fatil en casos donde no necesitas acceder al objeto de error, manteniendo tu c\u00f3digo m\u00e1s limpio y enfocado.</p> <p>En este art\u00edculo exploraremos qu\u00e9 es el optional catch binding, c\u00f3mo funciona y cu\u00e1ndo deber\u00edas usarlo, adem\u00e1s de incluir ejemplos y mejores pr\u00e1cticas.</p> <p>Sintaxis con Optional Catch Binding (desde ES2019): Antes de ES2019, el bloque <code>catch</code> deb\u00eda incluir un identificador para el error: Desde entonces puedes omitirlo si no lo necesitas:</p> javascript<pre><code>try {\n    // C\u00f3digo que puede generar un error\n} catch {\n    // C\u00f3digo para manejar el error sin acceder al objeto de error\n}\n</code></pre> <p>Esta simplificaci\u00f3n resulta \u00fatil en casos donde no necesitas analizar o registrar el error.</p>"},{"location":"javascript/optional-catch-binding/#simplificacion-del-manejo-de-errores","title":"Simplificaci\u00f3n del manejo de errores","text":"<p>En este ejemplo veremos c\u00f3mo puedes usar el optional catch binding para manejar errores de forma gen\u00e9rica, sin necesidad de capturar ni analizar el objeto de error.</p> javascript<pre><code>try {\n    JSON.parse(\"{malformedJson\"); // JSON no v\u00e1lido\n} catch {\n    console.log(\"Ocurri\u00f3 un error al analizar el JSON.\");\n}\n</code></pre> <p>En este caso intentamos analizar un JSON mal formado, lo que genera un error. El bloque <code>catch</code> captura el error y muestra un mensaje gen\u00e9rico, ya que los detalles del error no son relevantes para este caso.</p> <p>Este enfoque es ideal para mantener el c\u00f3digo limpio en situaciones donde el detalle del error no es necesario.</p>"},{"location":"javascript/optional-catch-binding/#cuando-deberias-usar-el-optional-catch-binding","title":"\u00bfCu\u00e1ndo deber\u00edas usar el Optional Catch Binding?","text":"<p>El optional catch binding es \u00fatil en situaciones donde no necesitas acceder al objeto del error. Por ejemplo:</p>"},{"location":"javascript/optional-catch-binding/#1-validacion-de-caracteristicas-del-navegador","title":"1. Validaci\u00f3n de caracter\u00edsticas del navegador","text":"<p>Cuando verificas si una funcionalidad est\u00e1 disponible en el navegador, es com\u00fan que no necesites analizar el error directamente.</p> javascript<pre><code>try {\n    document.querySelectorAll(\":scope &gt; div\");\n} catch {\n    console.log(\"El selector ':scope' no es compatible con este navegador.\");\n}\n</code></pre> <p>En este caso, simplemente mostramos un mensaje informando sobre la incompatibilidad, sin necesidad de procesar detalles del error.</p>"},{"location":"javascript/optional-catch-binding/#2-errores-genericos-con-mensajes-predefinidos","title":"2. Errores gen\u00e9ricos con mensajes predefinidos","text":"<p>Cuando un error siempre debe generar la misma respuesta, puedes simplificar el manejo con un bloque <code>catch</code> sin identificador.</p> javascript<pre><code>try {\n    let resultado = operacionCompleja();\n} catch {\n    console.log(\"Ocurri\u00f3 un error al ejecutar la operaci\u00f3n.\");\n}\n</code></pre> <p>Este enfoque es \u00fatil para operaciones complejas donde no necesitas detalles espec\u00edficos del error, sino manejar la situaci\u00f3n de manera uniforme.</p>"},{"location":"javascript/optional-catch-binding/#3-codigos-simples-de-fallback","title":"3. C\u00f3digos simples de fallback","text":"<p>En aplicaciones modernas es com\u00fan usar un bloque <code>catch</code> para implementar una funcionalidad alternativa cuando falla una operaci\u00f3n principal.</p> javascript<pre><code>try {\n    funcionalidadModerna();\n} catch {\n    funcionalidadAlternativa();\n}\n</code></pre> <p>Aqu\u00ed, si <code>funcionalidadModerna</code> no est\u00e1 disponible o falla, el programa autom\u00e1ticamente ejecuta <code>funcionalidadAlternativa</code>.</p>"},{"location":"javascript/optional-catch-binding/#ejemplo-fallback-de-funcionalidad","title":"Ejemplo: Fallback de funcionalidad","text":"<p>Para ilustrar un caso m\u00e1s completo, consideremos un ejemplo donde verificamos si una funcionalidad moderna est\u00e1 disponible y si no lo est\u00e1, usamos una alternativa.</p> javascript<pre><code>function verificarCaracteristica() {\n    try {\n        const soporte = new SomeModernFeature();\n        soporte.utilizar();\n    } catch {\n        console.log(\"Funcionalidad moderna no soportada. Usando alternativa.\");\n        funcionalidadAntigua();\n    }\n}\n\nverificarCaracteristica();\n</code></pre> <p>En el c\u00f3digo anterior pasa lo siguiente:</p> <ol> <li>Intentamos usar una funcionalidad moderna (<code>SomeModernFeature</code>) en el bloque <code>try</code>.</li> <li>Si no est\u00e1 disponible, el bloque <code>catch</code> asegura que el programa siga funcionando al ejecutar <code>funcionalidadAntigua</code>.</li> <li>No es necesario capturar el error, ya que el objetivo es garantizar un flujo alternativo.</li> </ol> <p>Este ejemplo demuestra c\u00f3mo el optional catch binding puede simplificar escenarios donde no necesitas manejar el error directamente.</p>"},{"location":"javascript/optional-catch-binding/#beneficios-del-optional-catch-binding","title":"Beneficios del Optional Catch Binding","text":"<p>El optional catch binding ofrece varias ventajas que mejoran la calidad del c\u00f3digo:</p> <ol> <li>C\u00f3digo m\u00e1s limpio: Evita declarar identificadores innecesarios, eliminando elementos redundantes.</li> <li>Mayor legibilidad: Simplifica el manejo de errores gen\u00e9ricos, haciendo que el flujo de control sea m\u00e1s claro.</li> <li>Optimizaci\u00f3n en escenarios espec\u00edficos: Es perfecto para casos donde los detalles del error no son relevantes.</li> </ol>"},{"location":"javascript/optional-catch-binding/#limitaciones-y-consideraciones","title":"Limitaciones y consideraciones","text":"<p>Aunque el optional catch binding es \u00fatil, no siempre es adecuado. Algunas cosas a tener en cuenta:</p> <ul> <li>No siempre es apropiado: Si necesitas registrar, analizar o manejar el error de manera espec\u00edfica, debes usar un identificador en el bloque <code>catch</code>.</li> <li>Compatibilidad con navegadores antiguos: Aunque la mayor\u00eda de los navegadores modernos soportan ES2019, es importante verificar si trabajas en entornos m\u00e1s antiguos.</li> </ul>"},{"location":"javascript/optional-catch-binding/#conclusion","title":"Conclusi\u00f3n","text":"<p>El optional catch binding en JavaScript es una mejora que simplifica el manejo de errores al permitirte omitir el identificador en el bloque <code>catch</code> cuando no es necesario. Esto resulta en un c\u00f3digo m\u00e1s limpio y legible, especialmente en escenarios donde el detalle del error no es relevante.</p> <p>Sin embargo, como todas las herramientas, debe usarse con cuidado, asegur\u00e1ndote de emplearlo solo cuando sea apropiado. En casos m\u00e1s complejos, donde necesitas registrar o procesar el error, el identificador sigue siendo esencial.</p> <p></p>"},{"location":"javascript/primeros-pasos/","title":"Primeros pasos","text":""},{"location":"javascript/primeros-pasos/#primeros-pasos","title":"Primeros pasos","text":"<p>JavaScript es un lenguaje de programaci\u00f3n interpretado, orientado a objetos y de alto nivel. Originalmente fue creado para a\u00f1adir interactividad en las p\u00e1ginas web, permitiendo que los sitios respondan a las acciones del usuario, como hacer clic en botones, mover el rat\u00f3n o enviar formularios. Con el paso de los a\u00f1os, su uso ha crecido y hoy en d\u00eda se utiliza tanto en el frontend (lo que ves en el navegador) como en el backend (el servidor).</p> <p>Una de las caracter\u00edsticas m\u00e1s atractivas de JavaScript es que es compatible con todos los navegadores modernos. Esto significa que puedes escribir JavaScript en cualquier p\u00e1gina HTML sin necesidad de configuraciones adicionales, funcionar\u00e1 en todos.</p>"},{"location":"javascript/primeros-pasos/#como-insertar-javascript-en-tu-html","title":"C\u00f3mo insertar JavaScript en tu HTML","text":"<p>Para empezar a usar JavaScript en tu p\u00e1gina web es fundamental saber c\u00f3mo se integra con HTML, el lenguaje de marcado que estructura las p\u00e1ginas web.</p> <p>Existen dos formas b\u00e1sicas de incluir JavaScript en un documento HTML:</p> <ol> <li>Incrustaci\u00f3n Directa: El c\u00f3digo se embebe directamente en la p\u00e1gina HTML</li> <li>Archivo Externo: Referenciar a un archivo de c\u00f3digo JavaScript externo.</li> </ol>"},{"location":"javascript/primeros-pasos/#incrustar-codigo-javascript-en-una-pagina-html","title":"Incrustar c\u00f3digo JavaScript en una p\u00e1gina HTML","text":"<p>Una forma sencilla y r\u00e1pida de comenzar a usar JavaScript es escribir el c\u00f3digo directamente en el mismo archivo HTML, dentro de etiquetas <code>&lt;script&gt;</code>. Esta t\u00e9cnica es \u00fatil para proyectos peque\u00f1os o para cuando necesitas agregar scripts espec\u00edficos que no ser\u00e1n reutilizados en otras p\u00e1ginas. Aunque esta opci\u00f3n es v\u00e1lida, no es la m\u00e1s recomendable para proyectos m\u00e1s complejos o escalables.</p> html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;title&gt;Mi P\u00e1gina Web&lt;/title&gt;\n  &lt;script&gt;\n    console.log(\"\u00a1Hola desde JavaScript!\");\n  &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;Contenido de la p\u00e1gina&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Esta forma es \u00fatil para peque\u00f1os fragmentos de c\u00f3digo o para ejecutar scripts espec\u00edficos en una p\u00e1gina en especifico.</p>"},{"location":"javascript/primeros-pasos/#incluir-un-archivo-javascript-externo","title":"Incluir un archivo JavaScript externo","text":"<p>A medida que los proyectos crecen y se vuelven m\u00e1s complejos, es buena pr\u00e1ctica separar el c\u00f3digo JavaScript en archivos independientes con extensi\u00f3n <code>.js</code> Estos archivos se enlazan al documento HTML a trav\u00e9s de la etiqueta <code>&lt;script&gt;</code> con el atributo que define la fuente de origen <code>src</code>.</p> <p>Esta forma permite un c\u00f3digo m\u00e1s organizado, facilita el mantenimiento y la reutilizaci\u00f3n del c\u00f3digo en diferentes partes del proyecto.</p> html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n&lt;head&gt;\n  &lt;title&gt;Mi P\u00e1gina Web&lt;/title&gt;\n  &lt;script src=\"./script.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;Contenido de la p\u00e1gina&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>En este caso, el archivo <code>script.js</code> est\u00e1 en el mismo directorio que el archivo <code>.html</code>.</p> <p>Usar archivos JavaScript externos es especialmente \u00fatil cuando trabajas en equipo, ya que permite que m\u00faltiples personas trabajen en diferentes archivos de manera simult\u00e1nea sin interferir en el c\u00f3digo HTML.</p>"},{"location":"javascript/primeros-pasos/#ventajas-de-usar-archivos-externos","title":"Ventajas de Usar Archivos Externos","text":"<p>El uso de archivos externos en lugar de incrustar el c\u00f3digo JavaScript directamente en el HTML tiene varias ventajas:</p> <ul> <li>Reutilizaci\u00f3n: Puedes usar el mismo archivo JavaScript en diferentes p\u00e1ginas de tu sitio web sin necesidad de copiar y pegar el c\u00f3digo en cada una de ellas.</li> <li>Mantenimiento: Separar la estructura HTML del comportamiento JavaScript facilita hacer cambios en el c\u00f3digo sin afectar el contenido visual de la p\u00e1gina.</li> <li>Mejoras de rendimiento: Los navegadores modernos pueden almacenar en cach\u00e9 los archivos JavaScript externos, lo que reduce el tiempo de carga en visitas posteriores a la p\u00e1gina.</li> </ul>"},{"location":"javascript/primeros-pasos/#ruta-del-archivo-externo","title":"Ruta del Archivo Externo:","text":"<p>La ruta del archivo externo te permite enlazar archivos desde otros directorios utilizando <code>..</code> para navegar hacia arriba en la jerarqu\u00eda de directorios.</p> html<pre><code>&lt;script src=\"../public/js/script.js\"&gt;&lt;/script&gt;\n</code></pre> <p>En el ejemplo anterior \u201c<code>..</code>\u201d indica que estamos retrocediendo un nivel en la jerarqu\u00eda de directorios. Luego, accedemos al directorio \u201cpublic\u201d, despu\u00e9s al subdirectorio \u201cjs\u201d y finalmente al archivo \u201c<code>script.js</code>\u201d.</p>"},{"location":"javascript/primeros-pasos/#enlace-a-archivos-externos-de-terceros","title":"Enlace a Archivos Externos de Terceros:","text":"<p>Tambi\u00e9n es posible enlazar archivos JavaScript alojados en servidores externos, como bibliotecas o CDNs. Un ejemplo com\u00fan es la inclusi\u00f3n de jQuery desde su CDN.</p> html<pre><code>&lt;script src=\"https://code.jquery.com/jquery-3.6.0.min.js\"&gt;&lt;/script&gt;\n</code></pre>"},{"location":"javascript/primeros-pasos/#incluir-multiples-archivos-javascript-en-un-archivo","title":"Incluir M\u00faltiples Archivos JavaScript en un Archivo","text":"<p>Incluir m\u00faltiples archivos JavaScript en una p\u00e1gina web es posible mediante la inclusi\u00f3n de varias etiquetas <code>&lt;script&gt;</code> en el c\u00f3digo HTML. El motor JavaScript interpreta estos archivos en el orden en que aparecen.</p> <p>Por ejemplo: html<pre><code>&lt;script src=\"js/functions.js\"&gt;&lt;/script&gt;\n&lt;script src=\"js/app.js\"&gt;&lt;/script&gt;\n</code></pre></p> <p>En este ejemplo, el motor JavaScript interpreta primero el archivo <code>functions.js</code> y luego <code>app.js</code>, en secuencia. Es importante tener en cuenta este orden, ya que las funciones y variables definidas en <code>functions.js</code> estar\u00e1n disponibles para su uso en <code>app.js</code>.</p> <p>Cuando una p\u00e1gina incluye muchos archivos JavaScript externos, puede ocurrir que la p\u00e1gina se muestre en blanco durante la fase de renderizado. Para evitar este problema, se recomienda incluir los archivos JavaScript justo antes del cierre de la etiqueta <code>&lt;/body&gt;</code>, como se muestra a continuaci\u00f3n:</p> html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;!-- Otros elementos del encabezado --&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- Contenido de la p\u00e1gina --&gt;\n\n    &lt;!-- Scripts al final del cuerpo --&gt;\n    &lt;script src=\"js/functions.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"js/app.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"javascript/primeros-pasos/#los-atributos-async-y-defer","title":"Los Atributos Async y Defer:","text":"<p>En la pr\u00e1ctica, es importante que el JavaScript no bloquee el renderizado del contenido de la p\u00e1gina, especialmente cuando se trabaja con muchos archivos o bibliotecas externas. Aqu\u00ed es donde entran en juego los atributos <code>async</code> y <code>defer</code> de la etiqueta <code>&lt;script&gt;</code>.</p>"},{"location":"javascript/primeros-pasos/#atributo-async-asincrono","title":"Atributo Async (As\u00edncrono):","text":"<p>El atributo <code>async</code> permite que el script se descargue en paralelo con la p\u00e1gina. Esto puede mejorar la velocidad de carga porque el navegador no tiene que esperar a que el script se descargue y ejecute antes de continuar renderizando el resto del contenido.</p> <p>Sin embargo <code>async</code> no garantiza que los scripts se ejecuten en el orden en que se declaran, lo que puede causar problemas si un script depende de otro.</p> html<pre><code>&lt;script async src=\"js/functions.js\"&gt;&lt;/script&gt;\n&lt;script async src=\"js/app.js\"&gt;&lt;/script&gt;\n</code></pre> <p>En el ejemplo anterior el archivo <code>app.js</code> podr\u00eda ejecutarse antes que el archivo <code>functions.js</code>. Por lo tanto, debes asegurarte de que no exista dependencia entre ellos.</p>"},{"location":"javascript/primeros-pasos/#atributo-defer-diferir","title":"Atributo Defer (Diferir):","text":"<p>El atributo <code>defer</code> por otro lado, asegura que los scripts se ejecuten en el orden en que aparecen en el documento HTML. Adem\u00e1s, garantiza que el script no se ejecute hasta que el navegador haya terminado de procesar completamente el HTML, lo que puede ser \u00fatil para asegurarse de que el DOM est\u00e9 listo para interactuar con el JavaScript.</p> html<pre><code>&lt;script defer src=\"js/app.js\"&gt;&lt;/script&gt;\n</code></pre> <p>Aunque coloquemos el elemento <code>&lt;script&gt;</code> en el <code>&lt;head&gt;</code>, el script esperar\u00e1 hasta que el navegador reciba el elemento <code>&lt;/html&gt;</code> de cierre para comenzar a ejecutarse.</p>"},{"location":"javascript/primeros-pasos/#buenas-practicas-en-la-inclusion-de-javascript","title":"Buenas Pr\u00e1cticas en la Inclusi\u00f3n de JavaScript","text":"<p>A medida que los proyectos web crecen, es \u00fatil seguir ciertas pr\u00e1cticas recomendadas para asegurarse de que el c\u00f3digo sea mantenible, eficiente y f\u00e1cil de entender para otros desarrolladores.</p> <ol> <li>Ubicaci\u00f3n de las etiquetas <code>&lt;script&gt;</code>: Aunque puedes colocar las etiquetas <code>&lt;script&gt;</code> en la cabecera del documento HTML (<code>&lt;head&gt;</code>), una mejor pr\u00e1ctica es colocarlas justo antes de la etiqueta de cierre del cuerpo (<code>&lt;/body&gt;</code>). Esto asegura que el contenido de la p\u00e1gina se cargue antes de ejecutar cualquier script, mejorando la experiencia del usuario y la percepci\u00f3n de la velocidad de carga de la p\u00e1gina.</li> <li>Modularidad: A medida que tu c\u00f3digo JavaScript crece, es recomendable dividirlo en m\u00f3dulos. Desde la llegada de ES6, JavaScript soporta m\u00f3dulos nativos, lo que facilita la organizaci\u00f3n del c\u00f3digo en partes reutilizables y bien definidas.</li> <li>Uso de herramientas para mejorar el c\u00f3digo: Para mantener una alta calidad en el c\u00f3digo, herramientas como ESLint y Prettier juegan un papel importante. Estas herramientas analizan el c\u00f3digo en busca de errores de sintaxis, inconsistencias o malas pr\u00e1cticas. Adem\u00e1s, pueden formatear autom\u00e1ticamente el c\u00f3digo para seguir un estilo consistente.</li> </ol>"},{"location":"javascript/primeros-pasos/#compatibilidad-con-todos-los-navegadores","title":"Compatibilidad con Todos los Navegadores","text":"<p>Uno de los aspectos m\u00e1s importantes al trabajar con JavaScript es asegurarse de que tu c\u00f3digo funcione correctamente en diferentes navegadores. Aunque la mayor\u00eda de los navegadores modernos soportan las \u00faltimas caracter\u00edsticas de JavaScript, algunos, especialmente los m\u00e1s antiguos, pueden no ser compatibles con ciertas funciones avanzadas.</p>"},{"location":"javascript/primeros-pasos/#uso-de-polyfills","title":"Uso de Polyfills","text":"<p>Los polyfills son fragmentos de c\u00f3digo que permiten que las funcionalidades modernas de JavaScript se ejecuten en navegadores antiguos. Por ejemplo, si deseas usar la funci\u00f3n <code>Array.prototype.includes()</code>, que no est\u00e1 disponible en todos los navegadores, puedes incluir un polyfill para asegurarte de que funcione en navegadores que no soportan esta funci\u00f3n.</p>"},{"location":"javascript/primeros-pasos/#conclusion","title":"Conclusi\u00f3n:","text":"<p>JavaScript es un lenguaje extremadamente poderoso y vers\u00e1til que ha evolucionado significativamente desde sus inicios. Saber c\u00f3mo integrarlo correctamente en tus proyectos HTML es solo el primer paso para desbloquear su potencial. Al seguir buenas pr\u00e1cticas, usar m\u00f3dulos y aprovechar las herramientas disponibles para mejorar la calidad del c\u00f3digo, podr\u00e1s crear aplicaciones web m\u00e1s r\u00e1pidas, eficientes y f\u00e1ciles de mantener.</p> <p></p>"},{"location":"javascript/programacion-asincrona/","title":"Programaci\u00f3n As\u00edncrona","text":""},{"location":"javascript/programacion-asincrona/#introduccion-a-la-programacion-asincrona","title":"Introducci\u00f3n a la Programaci\u00f3n As\u00edncrona","text":"<p>La programaci\u00f3n as\u00edncrona es una t\u00e9cnica que permite que los programas realicen m\u00faltiples tareas de manera concurrente, sin bloquear la ejecuci\u00f3n del c\u00f3digo. En JavaScript, la programaci\u00f3n as\u00edncrona es especialmente importante debido a la naturaleza de su entorno, donde muchas operaciones como solicitudes de red, acceso a bases de datos y temporizadores, son inherentemente as\u00edncronas.</p> <p>En este art\u00edculo exploraremos qu\u00e9 es la programaci\u00f3n as\u00edncrona, por qu\u00e9 es necesaria en JavaScript y los diferentes enfoques para manejarla.</p>"},{"location":"javascript/programacion-asincrona/#que-es-la-programacion-asincrona","title":"\u00bfQu\u00e9 es la Programaci\u00f3n As\u00edncrona?","text":"<p>La programaci\u00f3n as\u00edncrona permite ejecutar tareas en paralelo o de manera concurrente sin bloquear el flujo principal del programa. A diferencia de la programaci\u00f3n s\u00edncrona, donde cada tarea debe completarse antes de pasar a la siguiente, la programaci\u00f3n as\u00edncrona permite que otras tareas se ejecuten mientras una operaci\u00f3n espera una respuesta.</p>"},{"location":"javascript/programacion-asincrona/#programacion-sincrona-vs-asincrona","title":"Programaci\u00f3n S\u00edncrona vs. As\u00edncrona","text":"<ul> <li>S\u00edncrona: El c\u00f3digo se ejecuta l\u00ednea por l\u00ednea. Si una operaci\u00f3n tarda en completarse, bloquea el flujo hasta que termina.</li> <li>As\u00edncrona: Permite que el c\u00f3digo siga ejecut\u00e1ndose mientras una operaci\u00f3n a largo plazo (como una solicitud HTTP) se resuelve.</li> </ul> <p>Ejemplo de Comportamiento S\u00edncrono</p> javascript<pre><code>console.log(\"Inicio\");\n\nfunction tareaLarga() {\n    // Simula una operaci\u00f3n que tarda en completarse\n    for (let i = 0; i &lt; 1e9; i++) {}\n        console.log(\"Tarea Larga Completada\");\n}\n\ntareaLarga();\n\nconsole.log(\"Fin\");\n</code></pre> <p>En el ejemplo anterior la ejecuci\u00f3n de la funci\u00f3n <code>tareaLarga</code> bloquea el flujo del programa, haciendo que la l\u00ednea <code>console.log(\"Fin\")</code> no se ejecute hasta que la tarea termine.</p>"},{"location":"javascript/programacion-asincrona/#por-que-es-necesaria-la-programacion-asincrona-en-javascript","title":"\u00bfPor qu\u00e9 es Necesaria la Programaci\u00f3n As\u00edncrona en JavaScript?","text":"<p>JavaScript es un lenguaje de un solo hilo, lo que significa que solo puede ejecutar una tarea a la vez. Sin programaci\u00f3n as\u00edncrona, cualquier operaci\u00f3n que tome mucho tiempo, como una solicitud de red o la lectura de un archivo bloquear\u00eda la ejecuci\u00f3n del resto del c\u00f3digo. Esto har\u00eda que la aplicaci\u00f3n se sienta lenta o incluso no responda.</p> <p>Ejemplos de Casos que Requieren Programaci\u00f3n As\u00edncrona</p> <p>Solicitudes HTTP: Realizar llamadas a APIs o cargar datos de un servidor.   Operaciones con archivos: Leer o escribir archivos en sistemas locales o en servidores.   Temporizadores: Ejecuciones diferidas o peri\u00f3dicas con <code>setTimeout</code> o <code>setInterval</code>.   Acceso a bases de datos: Operaciones de lectura o escritura en bases de datos que pueden tomar tiempo.</p> <p>Al manejar estas operaciones de manera as\u00edncrona, se mejora la experiencia del usuario al permitir que la interfaz contin\u00fae respondiendo mientras se completan las tareas de fondo.</p>"},{"location":"javascript/programacion-asincrona/#enfoques-para-la-programacion-asincrona-en-javascript","title":"Enfoques para la Programaci\u00f3n As\u00edncrona en JavaScript","text":"<p>JavaScript ofrece diferentes formas para manejar la programaci\u00f3n as\u00edncrona, que han evolucionado con el tiempo. Los enfoques m\u00e1s comunes incluyen:</p>"},{"location":"javascript/programacion-asincrona/#1-callbacks","title":"1. Callbacks","text":"<p>Los callbacks son funciones que se pasan como argumento a otra funci\u00f3n y se ejecutan despu\u00e9s de que la operaci\u00f3n as\u00edncrona se haya completado. Estas fueron el primer enfoque utilizado en JavaScript para manejar la asincron\u00eda.</p> javascript<pre><code>function hacerAlgo(callback) {\n    console.log(\"Comenzando tarea...\");\n    setTimeout(() =&gt; {\n        console.log(\"Tarea completada\");\n        callback();\n    }, 2000);\n}\n\nhacerAlgo(() =&gt; {\n    console.log(\"Callback ejecutado despu\u00e9s de la tarea\");\n});\n</code></pre> <p>El problema con los callbacks es que pueden llevar al \u201cCallback Hell\u201d cuando hay m\u00faltiples operaciones anidadas.</p>"},{"location":"javascript/programacion-asincrona/#2-promesas","title":"2. Promesas","text":"<p>Las promesas son objetos que representan la eventual finalizaci\u00f3n (o falla) de una operaci\u00f3n as\u00edncrona y su valor resultante. Fueron introducidas en ES6 para mejorar el manejo de la asincron\u00eda y evitar la anidaci\u00f3n excesiva de callbacks.</p> javascript<pre><code>let promesa = new Promise((resolve, reject) =&gt; {\n    let exito = true;\n\n    if (exito) {\n        resolve(\"Operaci\u00f3n exitosa\");\n    } else {\n        reject(\"Ocurri\u00f3 un error\");\n    }\n});\n\npromesa\n    .then(resultado =&gt; console.log(resultado))\n    .catch(error =&gt; console.log(error));\n</code></pre>"},{"location":"javascript/programacion-asincrona/#3-asyncawait","title":"3. Async/Await","text":"<p>Async/Await es una sintaxis introducida en ES8 que permite escribir c\u00f3digo as\u00edncrono de manera m\u00e1s clara y estructurada, similar al c\u00f3digo s\u00edncrono. Est\u00e1 basado en promesas, pero hace que el manejo de la asincron\u00eda sea m\u00e1s f\u00e1cil de entender.</p> javascript<pre><code>async function tareaAsincrona() {\n    try {\n        let resultado = await new Promise(resolve =&gt; setTimeout(() =&gt; resolve(\"Operaci\u00f3n exitosa\"), 2000));\n        console.log(resultado);\n    } catch (error) {\n        console.log(error);\n    }\n}\n\ntareaAsincrona();\n</code></pre> <p>El uso de <code>async/await</code> simplifica el manejo de errores y la lectura del flujo as\u00edncrono.</p>"},{"location":"javascript/programacion-asincrona/#el-event-loop-en-javascript","title":"El Event Loop en JavaScript","text":"<p>El Event Loop es un mecanismo que maneja la ejecuci\u00f3n de c\u00f3digo as\u00edncrono en JavaScript. Permite que el c\u00f3digo contin\u00fae ejecut\u00e1ndose mientras se completan las tareas as\u00edncronas. Funciona mediante una cola de tareas, donde se agregan las operaciones as\u00edncronas, y las ejecuta una vez que el stack de llamadas est\u00e1 vac\u00edo.</p>"},{"location":"javascript/programacion-asincrona/#como-funciona-el-event-loop","title":"C\u00f3mo Funciona el Event Loop","text":"<ol> <li>Stack de Llamadas: Contiene las funciones que est\u00e1n en ejecuci\u00f3n.</li> <li>Cola de Tareas: Contiene las operaciones as\u00edncronas que est\u00e1n esperando para ser ejecutadas.</li> <li>Event Loop: Supervisa el stack y la cola, ejecutando las tareas pendientes cuando el stack est\u00e1 vac\u00edo.</li> </ol>"},{"location":"javascript/programacion-asincrona/#conclusion","title":"Conclusi\u00f3n","text":"<p>La programaci\u00f3n as\u00edncrona en JavaScript es esencial para desarrollar aplicaciones eficientes y responsivas. Permite que el c\u00f3digo maneje operaciones largas sin bloquear el flujo principal lo que mejora la experiencia del usuario. En esta secci\u00f3n, profundizaremos en temas como promesas, async/await y t\u00e9cnicas avanzadas para gestionar la asincron\u00eda.</p> <p>En el pr\u00f3ximo art\u00edculo, exploraremos las promesas en JavaScript, qu\u00e9 son y c\u00f3mo usarlas para manejar la programaci\u00f3n as\u00edncrona.</p> <p></p>"},{"location":"javascript/promesas/","title":"Promesas","text":""},{"location":"javascript/promesas/#promesas","title":"Promesas","text":"<p>Las promesas en JavaScript son una herramienta esencial para manejar operaciones as\u00edncronas de manera estructurada y predecible. Representan la eventual finalizaci\u00f3n (o falla) de una operaci\u00f3n y permiten escribir c\u00f3digo m\u00e1s limpio y mantenible que los callbacks tradicionales.</p> <p>En este art\u00edculo exploraremos qu\u00e9 son las promesas, qu\u00e9 problemas resuelven y c\u00f3mo se utilizan, con ejemplos pr\u00e1cticos para una comprensi\u00f3n completa.</p>"},{"location":"javascript/promesas/#que-es-una-promesa","title":"\u00bfQu\u00e9 es una promesa?","text":"<p>b\u00e1sicamente, una promesa es un objeto que representa un valor que puede estar disponible en el presente, en el futuro o nunca. Este objeto tiene tres estados posibles:</p> <ol> <li>Pendiente (<code>pending</code>): La operaci\u00f3n a\u00fan no ha finalizado.</li> <li>Resuelta (<code>fulfilled</code>): La operaci\u00f3n se complet\u00f3 con \u00e9xito y la promesa tiene un valor resultante.</li> <li>Rechazada (<code>rejected</code>): La operaci\u00f3n fall\u00f3 y la promesa tiene un motivo de error.</li> </ol> <p>Ejemplo b\u00e1sico:</p> javascript<pre><code>const promesa = new Promise((resolve, reject) =&gt; {\n    const exito = true;\n\n    if (exito) {\n        resolve(\"Operaci\u00f3n exitosa\");\n    } else {\n        reject(\"Error en la operaci\u00f3n\");\n    }\n});\n</code></pre> <ul> <li><code>resolve(valor)</code>: Cambia el estado de la promesa a fulfilled y proporciona el resultado.</li> <li><code>reject(error)</code>: Cambia el estado de la promesa a rejected y proporciona un motivo de error.</li> </ul> <p>El estado de una promesa cambia de <code>pending</code> a <code>fulfilled</code> o <code>rejected</code> cuando la operaci\u00f3n as\u00edncrona termina y no puede cambiar de nuevo.</p>"},{"location":"javascript/promesas/#que-problemas-resuelven-las-promesas","title":"\u00bfQu\u00e9 Problemas Resuelven las Promesas?","text":"<p>Antes de que las promesas fueran introducidas en versi\u00f3n de ES6, la forma principal de manejar la programaci\u00f3n as\u00edncrona en JavaScript era mediante callbacks. Aunque estos funcionan, tienen algunas desventajas importantes:</p> <ul> <li>Callback Hell: Cuando se anidan m\u00faltiples callbacks, el c\u00f3digo se vuelve dif\u00edcil de leer y mantener.</li> <li>Manejo de Errores Complejo: La gesti\u00f3n de errores en callbacks anidados puede ser complicada.</li> <li>Invocaci\u00f3n de M\u00faltiples Callbacks: Puede haber errores si un callback se llama varias veces, lo cual es dif\u00edcil de controlar.</li> </ul> <p>Las promesas resuelven estos problemas al proporcionar una estructura m\u00e1s limpia para manejar las operaciones as\u00edncronas, con un enfoque basado en m\u00e9todos para manejar el resultado o el error.</p>"},{"location":"javascript/promesas/#creacion-de-una-promesa-en-javascript","title":"Creaci\u00f3n de una Promesa en JavaScript","text":"<p>Para crear una promesa en JavaScript, se utiliza el constructor <code>Promise</code>, que toma una funci\u00f3n ejecutora como argumento. Esta funci\u00f3n ejecutora recibe dos par\u00e1metros: <code>resolve</code> y <code>reject</code>, que se utilizan para resolver o rechazar la promesa.</p> javascript<pre><code>const promesa = new Promise((resolve, reject) =&gt; {\n    const exito = true;\n\n    if (exito) {\n        resolve(\"La operaci\u00f3n fue exitosa\");\n    } else {\n        reject(\"Ocurri\u00f3 un error en la operaci\u00f3n\");\n    }\n});\n</code></pre> <p>En este ejemplo la promesa se resuelve con <code>resolve</code> si la operaci\u00f3n tiene \u00e9xito o con <code>reject</code> si ocurre un error.</p>"},{"location":"javascript/promesas/#metodos-principales-para-manejar-una-promesa","title":"M\u00e9todos principales para manejar una promesa","text":"<p>Una vez creada una promesa se pueden utilizar los m\u00e9todos <code>then</code> y <code>catch</code> para manejar los resultados de la promesa.</p>"},{"location":"javascript/promesas/#manejar-la-promesa-resuelta-then","title":"Manejar la Promesa Resuelta: <code>then()</code>","text":"<p>El m\u00e9todo <code>then()</code> se utiliza para manejar el valor de una promesa resuelta. Recibe una funci\u00f3n que se ejecuta cuando la promesa cambia a <code>fulfilled</code>.</p> javascript<pre><code>promesa.then(resultado =&gt; {\n    // Operaci\u00f3n a ejecutar si la promesa es exitosa\n});\n</code></pre>"},{"location":"javascript/promesas/#manejar-la-promesa-rechazada-catch","title":"Manejar la Promesa Rechazada: <code>catch()</code>","text":"<p>El m\u00e9todo <code>catch()</code> se utiliza para manejar errores en la promesa. Recibe una funci\u00f3n que se ejecuta cuando la promesa es rechazada.</p> javascript<pre><code>promesa.catch(error =&gt; {\n    // Error a ejecutar si la promesa es rechazada\n});\n</code></pre>"},{"location":"javascript/promesas/#ejecutar-codigo-independientemente-del-resultado-finally","title":"Ejecutar C\u00f3digo Independientemente del Resultado: <code>finally()</code>","text":"<p>El m\u00e9todo <code>finally()</code> se ejecuta una vez que la promesa ha sido resuelta o rechazada, sin importar el resultado. Es \u00fatil para liberar recursos o realizar acciones finales.</p> javascript<pre><code>promesa.finally(() =&gt; {\n    // Tarea a ejecutar cuando finaliza la operaci\u00f3n\n});\n</code></pre>"},{"location":"javascript/promesas/#encadenamiento-de-promesas","title":"Encadenamiento de Promesas","text":"<p>Una de las caracter\u00edsticas m\u00e1s potentes de las promesas es su capacidad de encadenar m\u00faltiples operaciones as\u00edncronas de manera secuencial.</p> <p>Una de las caracter\u00edsticas m\u00e1s poderosas de las promesas es la posibilidad de encadenar m\u00faltiples operaciones as\u00edncronas. Cada <code>then()</code> devuelve una nueva promesa, lo que permite encadenar las operaciones secuencialmente.</p> <p>Ejemplo de Encadenamiento:</p> javascript<pre><code>const promesaEncadenada = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; resolve(10), 1000);\n});\n\npromesaEncadenada\n  .then(resultado =&gt; {\n    console.log(\"Resultado inicial:\", resultado); // Resultado inicial: 10\n    return resultado * 2;\n  })\n  .then(nuevoResultado =&gt; {\n    console.log(\"Doblado:\", nuevoResultado); // Doblado: 20\n    return nuevoResultado + 5;\n  })\n  .then(final =&gt; {\n    console.log(\"Resultado final:\", final); // Resultado final: 25\n  })\n  .catch(error =&gt; {\n    console.log(\"Error:\", error);\n  })\n  .finally(() =&gt; {\n    console.log(\"Operaci\u00f3n completada, ya sea \u00e9xito o error.\"); // Siempre se ejecuta\n  });\n</code></pre> <p>Ventajas del encadenamiento:</p> <ul> <li>Hace que el flujo de operaciones sea m\u00e1s claro y lineal.</li> <li>Evita la anidaci\u00f3n excesiva.</li> </ul>"},{"location":"javascript/promesas/#promesas-vs-callbacks","title":"Promesas vs. Callbacks:","text":"<p>Las promesas ofrecen varias ventajas sobre el uso tradicional de callbacks para manejar operaciones as\u00edncronas:</p> <p>Legibilidad:</p> <ul> <li>Promesas: Ofrecen una sintaxis m\u00e1s clara, evitando la anidaci\u00f3n excesiva que ocurre con los callbacks. Esto hace que el flujo de operaciones sea m\u00e1s f\u00e1cil de seguir y entender.</li> <li>Callbacks: Pueden ser dif\u00edciles de leer y mantener, especialmente cuando se anidan m\u00faltiples operaciones, lo que lleva al problema conocido como \u201cCallback Hell\u201d.</li> </ul> <p>Manejo de errores:</p> <p>Promesas: Centralizan el manejo de errores con el m\u00e9todo .catch(), que captura cualquier fallo en la cadena de operaciones as\u00edncronas, facilitando su gesti\u00f3n.   Callbacks: Requieren manejar los errores manualmente en cada nivel de anidaci\u00f3n, lo que incrementa la complejidad del c\u00f3digo y la posibilidad de omitir errores.</p> <p>Encadenamiento:</p> <p>Promesas: Permiten un flujo lineal y predecible mediante el uso de <code>.then()</code>, lo que mejora la estructura y claridad del c\u00f3digo.   Callbacks: El encadenamiento de operaciones implica anidar callbacks, lo que puede resultar en un c\u00f3digo desorganizado y dif\u00edcil de depurar.</p>"},{"location":"javascript/promesas/#buenas-practicas-al-usar-promesas","title":"Buenas pr\u00e1cticas al usar promesas","text":"<ol> <li>Siempre maneja los errores: Usa <code>.catch()</code> para capturar cualquier error en la cadena de promesas.</li> <li>Usa <code>finally</code> para tareas finales: \u00datil para liberar recursos o realizar acciones finales independientemente del resultado.</li> <li>Evita promesas excesivamente anidadas: Encadena operaciones en lugar de anidar <code>.then()</code>.</li> </ol> javascript<pre><code>promesa\n  .then(resultado =&gt; {\n    // Operaci\u00f3n exitosa\n  })\n  .catch(error =&gt; {\n    // Manejo de errores\n  })\n  .finally(() =&gt; {\n    // Acci\u00f3n final\n  });\n</code></pre>"},{"location":"javascript/promesas/#conclusion","title":"Conclusi\u00f3n","text":"<p>Las promesas en JavaScript representan una mejora significativa en el manejo de operaciones as\u00edncronas. Ofrecen una forma clara y estructurada de manejar tareas largas o complejas, haciendo el c\u00f3digo m\u00e1s legible y f\u00e1cil de mantener. Comprender c\u00f3mo crear, manejar y encadenar promesas es esencial para desarrollar aplicaciones modernas y responsivas.</p> <p>En el siguiente art\u00edculo abordaremos el encadenamiento de promesas, c\u00f3mo se puede simplificar el flujo de trabajo y qu\u00e9 t\u00e9cnicas usar para manejar la programaci\u00f3n as\u00edncrona de manera efectiva.</p> <p></p>"},{"location":"javascript/que-es-javascript/","title":"\u00bfQu\u00e9 es JavaScript?","text":""},{"location":"javascript/que-es-javascript/#que-es-javascript","title":"\u00bfQu\u00e9 es JavaScript?","text":"<p>JavaScript es un lenguaje de programaci\u00f3n vers\u00e1til y ampliamente utilizado en el desarrollo web. Este fue dise\u00f1ado inicialmente para interactuar con elementos de p\u00e1ginas web y hoy d\u00eda permite a los desarrolladores implementar aplicaciones complejas, incluso afueras del entorno web.</p> <p>Dentro de los navegadores web, JavaScript consta de tres partes principales:</p> <ul> <li>ECMAScript: proporciona la funcionalidad principal.</li> <li>DOM (Document Object Model): proporciona interfaces para interactuar con elementos en p\u00e1ginas web.</li> <li>BOM (Browser Object Model): proporciona la API para interactuar con el navegador web.</li> </ul> <p>JavaScript es una poderosa herramienta para agregar interactividad y dinamismo a las p\u00e1ginas web, desempe\u00f1ando un papel fundamental como la tercera capa de las tecnolog\u00edas web est\u00e1ndar junto a HTML y CSS.</p> <p> M\u00e1s all\u00e1 de solo mejorar la funcionalidad de una p\u00e1gina, JavaScript permite crear experiencias de usuario m\u00e1s ricas e inmersivas. Desde la validaci\u00f3n instant\u00e1nea de formularios hasta la creaci\u00f3n de aplicaciones complejas y din\u00e1micas, pasando por la visualizaci\u00f3n de datos en tiempo real y el desarrollo de interfaces de usuario interactivas. Las posibilidades con JavaScript son casi ilimitadas.</p> <p></p> <p>Con el advenimiento de bibliotecas y frameworks modernos como React, Angular y Vue.js entre otros, el desarrollo web con JavaScript ha alcanzado un nuevo nivel de sofisticaci\u00f3n y eficiencia, permitiendo a los desarrolladores construir aplicaciones web m\u00e1s r\u00e1pidas, escalables y est\u00e9ticamente atractivas.</p>"},{"location":"javascript/que-es-javascript/#como-funciona-javascript","title":"\u00bfC\u00f3mo funciona JavaScript?","text":"<p>Cuando una p\u00e1gina web se carga en un navegador, el proceso de renderizado comienza con la descarga y an\u00e1lisis del HTML y el CSS asociados. Una vez que estos recursos se han descargado y analizado el navegador procede a ejecutar cualquier c\u00f3digo JavaScript presente en la p\u00e1gina. Esta etapa es la mas importante para la interactividad y dinamismo ya que permite que el sitio web responda a la interacci\u00f3n del usuario de manera activa.</p> <p>Por ejemplo, JavaScript puede agregar o eliminar elementos del DOM en funci\u00f3n de las acciones del usuario, como hacer clic en un bot\u00f3n o ingresar datos en un formulario. Adem\u00e1s, el script puede manipular estilos CSS y realizar solicitudes de red para cargar datos adicionales, todo en tiempo real sin necesidad de recargar la p\u00e1gina u aplicaci\u00f3n.</p>"},{"location":"javascript/que-es-javascript/#motores-javascript","title":"Motores JavaScript","text":"<p>El motor JavaScript es un componente esencial de los navegadores web, son el encargado de interpretar y ejecutar el c\u00f3digo JavaScript. Est\u00e1 compuesto por un analizador para examinar el c\u00f3digo, un compilador para convertirlo en c\u00f3digo de m\u00e1quina y un int\u00e9rprete para ejecutar el c\u00f3digo compilado.</p> <p>Los navegadores utilizan diversos motores de JavaScript para ejecutar el c\u00f3digo de manera eficiente. Algunos de los motores m\u00e1s destacados son V8 en Chrome, SpiderMonkey en Firefox y JavaScriptCore en Safari.</p> <p>Inicialmente los motores JavaScript se implementaban como int\u00e9rpretes. Sin embargo, en la actualidad los motores modernos se basan com\u00fanmente en compiladores (just-in-time) que convierten el c\u00f3digo JavaScript en c\u00f3digo de bytes para mejorar el rendimiento.</p>"},{"location":"javascript/que-es-javascript/#javascript-lado-del-cliente-vs-servidor","title":"JavaScript: lado del cliente vs servidor","text":"<p>JavaScript es un lenguaje de programaci\u00f3n que se puede utilizar tanto en el cliente como en el servidor. Aqu\u00ed tienes un resumen de las diferencias entre ambos:</p>"},{"location":"javascript/que-es-javascript/#javascript-del-lado-del-cliente-client-side","title":"JavaScript del Lado del Cliente (Client-Side):","text":"<ul> <li>Se ejecuta en el navegador del usuario.</li> <li>Se utiliza para crear interacciones din\u00e1micas en la p\u00e1gina web.</li> <li>Ejemplos incluyen animaciones, formularios interactivos y contenido que cambia sin recargar la p\u00e1gina.</li> </ul>"},{"location":"javascript/que-es-javascript/#javascript-del-lado-del-servidor-server-side","title":"JavaScript del Lado del Servidor (Server-Side):","text":"<ul> <li>Se ejecuta en el servidor, en plataformas como Node.js.</li> <li>Se utiliza para manejar solicitudes, interactuar con bases de datos y servir contenido din\u00e1mico al cliente.</li> <li>Ejemplos incluyen autenticaci\u00f3n de usuarios, operaciones con bases de datos y generaci\u00f3n de p\u00e1ginas web din\u00e1micas.</li> </ul> <p>Ambos lados trabajan juntos para ofrecer una experiencia web completa y funcional.</p>"},{"location":"javascript/que-es-javascript/#resumen-de-la-historia-de-javascript","title":"Resumen de la historia de JavaScript","text":"<p>JavaScript fue desarrollado por Brendan Eich de Netscape en 1995, inicialmente conocido como Mocha y luego renombrado como LiveScript. Netscape decidi\u00f3 cambiar el nombre a JavaScript para aprovechar la popularidad de Java, coincidiendo con el lanzamiento de Netscape Navigator 2.</p> <p>Netscape lanz\u00f3 JavaScript 1.1 con Netscape Navigator 3, mientras que Microsoft present\u00f3 Internet Explorer 3 (IE 3) con su propia implementaci\u00f3n llamada JScript. Esto dio lugar a dos versiones de JavaScript en el mercado.</p> <p>En 1997, JavaScript 1.1 se propuso a la European Computer Manufacturers Association (ECMA) para su estandarizaci\u00f3n. El Comit\u00e9 T\u00e9cnico #39 (TC39) fue asignado para estandarizar el lenguaje, dando lugar a ECMAScript, una especificaci\u00f3n para un lenguaje de secuencias de comandos multiplataforma.</p> <p>ECMA-262 fue la norma resultante, y ECMAScript fue adoptado por la Organizaci\u00f3n Internacional de Normalizaci\u00f3n (ISO/IEC), estableciendo un est\u00e1ndar para el lenguaje de programaci\u00f3n JavaScript moderno.</p>"},{"location":"javascript/que-es-javascript/#primer-vistazo-del-lenguaje","title":"Primer vistazo del lenguaje","text":"<p>El siguiente apartado ofrece una s\u00f3lida introducci\u00f3n al c\u00f3digo de JavaScript. Si a\u00fan no est\u00e1s familiarizado con \u00e9l, est\u00e1 bien. Tendr\u00e1s la oportunidad de aprender en el pr\u00f3ximo tutorial.</p>"},{"location":"javascript/que-es-javascript/#declarar-variables","title":"Declarar variables","text":"<p>Para definir una variable en JavaScript utilizamos la palabra clave <code>var</code>:</p> javascript<pre><code>var name = \"James\";\nvar age = 20;\n</code></pre> <p>JavaScript tambi\u00e9n introdujo una nueva forma de declarar variables con la palabra clave <code>let</code>:</p> javascript<pre><code>let x = 10;\nlet y = 20;\n</code></pre> <p> Hablaremos m\u00e1s sobre las diferencias entre var y let en pr\u00f3ximos tutoriales, pero por ahora es una buena pr\u00e1ctica utilizar let para declarar variables.</p> <p></p>"},{"location":"javascript/que-es-javascript/#definir-funciones","title":"Definir Funciones","text":"<p>Para declarar una funci\u00f3n en JavaScript, usamos la palabra clave <code>function</code>:</p> javascript<pre><code>function add(a, b) {\n  return a + b;\n}\n</code></pre> <p>Esta funci\u00f3n <code>add()</code> toma dos argumentos y devuelve su suma. Para llamar a la funci\u00f3n utilizamos la siguiente sintaxis:</p> javascript<pre><code>let x = 10;\nlet y = 20;\n\nfunction add(a, b) {\n  return a + b;\n}\nlet result = add(x, y);\n\nconsole.log(result);\n</code></pre> <p>En el anterior ejemplo pasamos las variables <code>x</code> y <code>y</code> como argumentos a la funci\u00f3n <code>add()</code> y almacenamos el resultado en la variable <code>result</code>.</p>"},{"location":"javascript/que-es-javascript/#condicionales","title":"Condicionales","text":"<p>JavaScript tambi\u00e9n nos proporciona declaraciones de condici\u00f3n como <code>if-else</code> y <code>switch</code>. Por ejemplo:</p> javascript<pre><code>function divide(a, b) {\n  if (b === 0) {\n    throw 'Divisi\u00f3n por cero';\n  }\n  return a / b;\n}\n</code></pre> <p>En esta funci\u00f3n <code>divide()</code> verificamos si el denominador <code>b</code> es cero. Si es as\u00ed, lanzamos una excepci\u00f3n. De lo contrario, devolvemos el resultado de <code>a/b</code>.</p>"},{"location":"javascript/que-es-javascript/#arrays-matrices","title":"Arrays (Matrices)","text":"<p>Para declarar un array en JavaScript, utilizamos la siguiente sintaxis:</p> javascript<pre><code>let items = [];\n</code></pre> <p>Tambi\u00e9n puedes declarar un array con elementos iniciales:</p> javascript<pre><code>let items = [1, 2, 3];\n</code></pre> <p>Para iterar sobre los elementos del array, puedes usar un bucle <code>for</code>:</p> javascript<pre><code>let items = [1, 2, 3];\n\nfor (let i = 0; i &lt; items.length; i++) {\n  console.log(items[i]);\n}\n</code></pre> <p>Alternativamente, puedes utilizar el bucle <code>for...of</code> introducido en ES6:</p> javascript<pre><code>let items = [1, 2, 3];\n\nfor(let item of items) {\n    console.log(item);\n}\n</code></pre> <p>Este ejemplo introductorio te ha dado un primer vistazo a algunos de los conceptos b\u00e1sicos de JavaScript. En los pr\u00f3ximos tutoriales, profundizaremos a\u00fan m\u00e1s en el lenguaje y aprenderemos a utilizarlo de manera m\u00e1s efectiva.</p> <p>A medida que la web contin\u00faa evolucionando, JavaScript se afianza como una herramienta fundamental en el desarrollo web moderno. Con su versatilidad y capacidades en constante expansi\u00f3n, este lenguaje de programaci\u00f3n permite a los desarrolladores crear experiencias de usuario cada vez m\u00e1s ricas e interactivas, tanto en el lado del cliente como del servidor.</p> <p></p>"},{"location":"javascript/scope/","title":"Variable Scope","text":""},{"location":"javascript/scope/#variable-scope-alcances-de-las-variables","title":"Variable Scope: Alcances de las Variables","text":"<p>El alcance (scope) de una variable en JavaScript define d\u00f3nde es visible y accesible dentro del c\u00f3digo. Comprender los diferentes tipos de alcance es importante para escribir c\u00f3digo m\u00e1s limpio, predecible y eficiente.</p> <p>En este art\u00edculo exploraremos los tres tipos principales de scope en JavaScript: global, local y de bloque, as\u00ed como conceptos adicionales como la cadena de alcance (scope chain) y las fugas de variables globales.</p>"},{"location":"javascript/scope/#que-es-el-scope-en-javascript","title":"\u00bfQu\u00e9 es el Scope en JavaScript?","text":"<p>El alcance determina la visibilidad y accesibilidad de una variable en el programa. Cuando una variable se declara, su alcance define las partes del c\u00f3digo que pueden acceder a ella. JavaScript proporciona los siguientes tipos principales de scope:</p> <ol> <li>Scope global: Las variables declaradas fuera de cualquier funci\u00f3n o bloque pertenecen al scope global.</li> <li>Scope local (de funci\u00f3n): Las variables declaradas dentro de una funci\u00f3n solo son accesibles dentro de esa funci\u00f3n.</li> <li>Scope de bloque: Introducido con ES6, aplica a variables declaradas con <code>let</code> y <code>const</code> dentro de bloques <code>{}</code>.</li> </ol> <p></p>"},{"location":"javascript/scope/#alcance-goblal","title":"Alcance Goblal","text":"<p>Las variables definidas en el scope global o alcance global son accesibles desde cualquier parte del programa. Se crean al declarar una variable fuera de funciones o bloques.</p> javascript<pre><code>var mensaje = \"Hola desde el global\";\n\nfunction saludar() {\n    console.log(mensaje); // Accede a la variable global\n}\n\nsaludar();\nconsole.log(mensaje); // Tambi\u00e9n accesible aqu\u00ed\n</code></pre> <p>En el c\u00f3digo anterior, <code>mensaje</code> es una variable global. Puede ser utilizada tanto dentro como fuera de la funci\u00f3n <code>saludar</code>.</p> <p>Aunque las variables globales pueden parecer convenientes, abusar de ellas puede causar problemas de mantenimiento y depuraci\u00f3n en programas grandes.</p>"},{"location":"javascript/scope/#alcance-local","title":"Alcance Local","text":"<p>Las variables declaradas dentro de una funci\u00f3n son locales a esa funci\u00f3n. No son accesibles fuera de su contexto.</p> javascript<pre><code>function decirHola() {\n    var saludo = \"Hola desde el local\";\n    console.log(saludo); // \"Hola desde el local\"\n}\n\ndecirHola();\nconsole.log(saludo); // ReferenceError: saludo no est\u00e1 definido\n</code></pre> <p>En el c\u00f3digo anterior <code>saludo</code> es una variable local declarada dentro de la funci\u00f3n <code>decirHola</code>. No se puede acceder a <code>saludo</code> desde fuera de la funci\u00f3n.</p> <p>Cuando se ejecuta una funci\u00f3n, el motor de JavaScript crea un contexto de ejecuci\u00f3n para esa funci\u00f3n, aislando sus variables del resto del programa.</p>"},{"location":"javascript/scope/#alcance-de-bloque","title":"Alcance de Bloque","text":"<p>Con la introducci\u00f3n de <code>let</code> y <code>const</code> en ES6, es posible declarar variables limitadas a un bloque <code>{}</code>. Esto incluye estructuras como <code>if</code>, <code>for</code> o cualquier otro bloque de c\u00f3digo.</p> javascript<pre><code>if (true) {\n    let mensaje = \"Hola desde el bloque\";\n    console.log(mensaje); // \"Hola desde el bloque\"\n}\n\nconsole.log(mensaje); // ReferenceError: mensaje no est\u00e1 definido\n</code></pre> <p>La variable <code>mensaje</code> solo es accesible dentro del bloque <code>if</code>. Al intentar acceder a <code>mensaje</code> fuera del bloque, se genera un error.</p> <p>El scope de bloque ayuda a reducir errores relacionados con variables que se comparten entre bloques, mejorando la claridad del c\u00f3digo.</p>"},{"location":"javascript/scope/#la-cadena-de-scope-scope-chain","title":"La Cadena de Scope (Scope Chain)","text":"<p>Cuando JavaScript busca una variable, primero verifica el contexto actual. Si no la encuentra, sube al siguiente nivel del alcance actual (funci\u00f3n contenedora o global). Este proceso se llama scope chain.</p> javascript<pre><code>var mensaje = \"Hola desde el global\";\n\nfunction mostrarMensaje() {\n    console.log(mensaje); // Busca en el scope local, luego global\n}\n\nmostrarMensaje(); // \"Hola desde el global\"\n</code></pre> <p>En el ejemplo anterior, Si <code>mensaje</code> no estuviera declarado globalmente, JavaScript arrojar\u00eda un error. La cadena de scope asegura que el motor busque la variable en contextos externos.</p>"},{"location":"javascript/scope/#fugas-de-variables-globales","title":"Fugas de Variables Globales","text":"<p>Una variable global puede crearse accidentalmente si no se declara con <code>var</code>, <code>let</code> o <code>const</code>. Esto ocurre porque JavaScript asigna autom\u00e1ticamente la variable al objeto global.</p> javascript<pre><code>function contador() {\n    numero = 10; // No se declara expl\u00edcitamente\n    return numero;\n}\n\nconsole.log(contador()); // 10\nconsole.log(numero); // 10 (se crea en el scope global)\n</code></pre> <p>Soluci\u00f3n: Usa <code>\"use strict\"</code> para evitar fugas de variables globales. Esto asegura que las variables no declaradas arrojen un error.</p> javascript<pre><code>\"use strict\";\n\nfunction contador() {\n    numero = 10; // ReferenceError: numero no est\u00e1 definido\n    return numero;\n}\n\ncontador();\n</code></pre>"},{"location":"javascript/scope/#buenas-practicas-para-el-uso-del-scope","title":"Buenas Pr\u00e1cticas para el Uso del Scope","text":"<ol> <li>Prefiere <code>let</code> y <code>const</code> sobre <code>var</code>: Ayudan a evitar problemas de alcance y hacen el c\u00f3digo m\u00e1s predecible.</li> <li>Mant\u00e9n las variables lo m\u00e1s locales posible: Esto reduce el riesgo de conflictos y facilita el mantenimiento.</li> <li>Evita fugas de variables globales: Siempre declara tus variables expl\u00edcitamente.</li> <li>Usa <code>const</code> para valores inmutables: Define variables que no cambian con <code>const</code> para proteger su estado.</li> </ol>"},{"location":"javascript/scope/#conclusion","title":"Conclusi\u00f3n","text":"<p>El scope es uno de los pilares fundamentales para escribir c\u00f3digo JavaScript eficiente y f\u00e1cil de depurar. Conocer los tipos de alcance, desde el global hasta el de bloque, te permitir\u00e1 tomar decisiones m\u00e1s informadas al declarar variables y estructurar tu c\u00f3digo.</p> <p></p>"},{"location":"javascript/set/","title":"Set","text":""},{"location":"javascript/set/#set","title":"Set","text":"<p>El objeto <code>Set</code> es una estructura de datos que permite almacenar valores \u00fanicos de cualquier tipo, ya sean primitivos u objetos. A diferencia de los arrays, un <code>Set</code> elimina autom\u00e1ticamente los valores duplicados, lo que lo convierte en una herramienta ideal para manejar colecciones de datos \u00fanicas de manera eficiente.</p>"},{"location":"javascript/set/#que-es-un-set-en-javascript","title":"\u00bfQu\u00e9 es un Set en JavaScript?","text":"<p>Un <code>Set</code> es una colecci\u00f3n ordenada de valores que asegura que cada elemento sea \u00fanico. Esto significa que no puede contener dos elementos con el mismo valor, aunque estos valores pueden ser de cualquier tipo, incluidos objetos y funciones.</p>"},{"location":"javascript/set/#por-que-usar-set-en-lugar-de-un-array","title":"\u00bfPor qu\u00e9 usar Set en lugar de un Array?","text":"<p>Aunque los arrays son muy vers\u00e1tiles, no eliminan autom\u00e1ticamente los valores duplicados y pueden ser menos eficientes en ciertas operaciones, como b\u00fasqueda o eliminaci\u00f3n de elementos. Por esta raz\u00f3n <code>Set</code> es \u00fatil en escenarios como:</p> <ul> <li>Eliminar duplicados en listas grandes.</li> <li>Realizar operaciones de conjuntos (uni\u00f3n, intersecci\u00f3n, diferencia).</li> <li>Mantener datos \u00fanicos con b\u00fasquedas r\u00e1pidas.</li> </ul> <p>Sintaxis B\u00e1sica:</p> javascript<pre><code>const conjunto = new Set();\n</code></pre> <p>Tambi\u00e9n se puede inicializar con un array de valores:</p> javascript<pre><code>const conjunto = new Set([1, 2, 3, 4, 4]);\n\nconsole.log(conjunto);\n</code></pre>"},{"location":"javascript/set/#propiedades-y-metodos-principales-de-set","title":"Propiedades y M\u00e9todos Principales de Set","text":"<p>El objeto <code>Set</code> incluye propiedades y m\u00e9todos para gestionar f\u00e1cilmente sus elementos.</p>"},{"location":"javascript/set/#propiedad-size","title":"Propiedad <code>size</code>","text":"<p>La propiedad <code>size</code> devuelve el n\u00famero total de elementos \u00fanicos almacenados en el <code>Set</code>.</p> javascript<pre><code>const conjunto = new Set([1, 2, 3, 3]);\n\nconsole.log(conjunto.size);\n</code></pre> <p>A diferencia de los arrays, no necesitas preocuparte por duplicados ni escribir c\u00f3digo adicional para contarlos.</p>"},{"location":"javascript/set/#metodo-addvalue","title":"M\u00e9todo <code>add(value)</code>","text":"<p>El m\u00e9todo <code>add</code> permite a\u00f1adir un valor al <code>Set</code>. Si el valor ya existe, no se a\u00f1adir\u00e1 nuevamente. Este m\u00e9todo es ideal cuando necesitas construir una colecci\u00f3n \u00fanica de valores din\u00e1micamente, como cuando recorres una lista de elementos.</p> javascript<pre><code>const conjunto = new Set();\nconjunto.add(10);\nconjunto.add(20);\nconjunto.add(10); // Ignorado porque ya existe\n\nconsole.log(conjunto);\n</code></pre>"},{"location":"javascript/set/#metodo-deletevalue","title":"M\u00e9todo <code>delete(value)</code>","text":"<p>El m\u00e9todo <code>delete</code> elimina un valor espec\u00edfico del <code>Set</code>. Devuelve <code>true</code> si el valor fue eliminado y <code>false</code> si no exist\u00eda.</p> javascript<pre><code>const conjunto = new Set();\nconjunto.add(10);\nconjunto.add(20);\nconjunto.add(10);\nconjunto.delete(10);\n\nconsole.log(conjunto);\n</code></pre> <p>Este m\u00e9todo es eficiente para eliminar valores sin necesidad de recorrer manualmente toda la colecci\u00f3n, como sucede con los arrays.</p>"},{"location":"javascript/set/#metodo-hasvalue","title":"M\u00e9todo <code>has(value)</code>","text":"<p>El m\u00e9todo <code>has</code> comprueba si un valor existe en el <code>Set</code> y devuelve un booleano (<code>true</code> o <code>false</code>). Es \u00fatil para verificar la existencia de un valor antes de realizar una operaci\u00f3n, como agregarlo o eliminarlo.</p> javascript<pre><code>const conjunto = new Set();\nconjunto.add(10);\nconjunto.add(20);\nconjunto.add(10);\n\nconsole.log(conjunto.has(20));\nconsole.log(conjunto.has(30));\n</code></pre>"},{"location":"javascript/set/#metodo-clear","title":"M\u00e9todo <code>clear()</code>","text":"<p>El m\u00e9todo <code>clear</code> elimina todos los valores del <code>Set</code> reinici\u00e1ndolo completamente. Es pr\u00e1ctico cuando necesitas vaciar una colecci\u00f3n temporal en lugar de crear un nuevo <code>Set</code>.</p> javascript<pre><code>const conjunto = new Set();\nconjunto.add(10);\nconjunto.add(20);\nconjunto.add(10);\nconjunto.clear();\n\nconsole.log(conjunto.size);\n</code></pre>"},{"location":"javascript/set/#operaciones-de-conjunto-con-set","title":"Operaciones de Conjunto con <code>Set</code>","text":"<p>Adem\u00e1s de almacenar valores \u00fanicos, <code>Set</code> facilita la implementaci\u00f3n de operaciones de conjunto comunes como uni\u00f3n, intersecci\u00f3n y diferencia. Estas operaciones son esenciales en muchas aplicaciones matem\u00e1ticas y algor\u00edtmicas.</p>"},{"location":"javascript/set/#union","title":"Uni\u00f3n","text":"<p>La uni\u00f3n combina todos los valores \u00fanicos de dos conjuntos. Esto se logra utilizando el operador <code>spread (...)</code> para combinar los elementos de ambos <code>Set</code>. Es \u00fatil cuando necesitas combinar listas de datos sin duplicados, como registros de usuarios o productos en diferentes bases de datos.</p> javascript<pre><code>const conjuntoA = new Set([1, 2, 3]);\nconst conjuntoB = new Set([3, 4, 5]);\n\nconst union = new Set([...conjuntoA, ...conjuntoB]);\nconsole.log(union);\n</code></pre>"},{"location":"javascript/set/#interseccion","title":"Intersecci\u00f3n","text":"<p>La intersecci\u00f3n devuelve los valores que son comunes entre dos conjuntos. Esto se logra utilizando el m\u00e9todo <code>filter</code> para comprobar qu\u00e9 valores de un conjunto existen en el otro. En aplicaciones pr\u00e1cticas, puedes usar la intersecci\u00f3n para encontrar elementos compartidos entre dos grupos, como usuarios que pertenecen a dos listas de correos diferentes.</p> javascript<pre><code>const conjuntoA = new Set([1, 2, 3]);\nconst conjuntoB = new Set([3, 4, 5]);\n\nconst interseccion = new Set(\n    [...conjuntoA].filter((valor) =&gt; conjuntoB.has(valor))\n);\nconsole.log(interseccion);\n</code></pre>"},{"location":"javascript/set/#diferencia","title":"Diferencia","text":"<p>La diferencia devuelve los valores que est\u00e1n en un conjunto pero no en el otro. Esto es \u00fatil para identificar elementos \u00fanicos en un grupo. Es com\u00fan en casos como detectar elementos que faltan en una lista o verificar datos eliminados.</p> javascript<pre><code>const conjuntoA = new Set([1, 2, 3]);\nconst conjuntoB = new Set([3, 4, 5]);\n\nconst diferencia = new Set(\n    [...conjuntoA].filter((valor) =&gt; !conjuntoB.has(valor))\n);\nconsole.log(diferencia);\n</code></pre>"},{"location":"javascript/set/#ejemplo-basico-filtrar-palabras-unicas","title":"Ejemplo B\u00e1sico: Filtrar Palabras \u00danicas","text":"<p>Supongamos que necesitas identificar todas las palabras \u00fanicas en una oraci\u00f3n. Con un <code>Set</code>, esto se logra de manera eficiente:</p> javascript<pre><code>const texto = 'JavaScript es divertido, JavaScript es poderoso';\nconst palabras = texto.toLowerCase().split(/\\W+/);\n\nconst unicas = new Set(palabras);\nconsole.log(unicas);\n</code></pre> <p>En casos como an\u00e1lisis de texto o procesamiento de datos, los <code>Set</code> permiten obtener resultados \u00fanicos con un c\u00f3digo m\u00e1s simple.</p>"},{"location":"javascript/set/#diferencias-entre-set-y-arrays","title":"Diferencias entre Set y Arrays","text":"<p>Aunque los arrays y los <code>Set</code> tienen caracter\u00edsticas similares, sus diferencias clave determinan cu\u00e1ndo es mejor usar cada uno.</p> Caracter\u00edstica Set Array Valores \u00danicos S\u00ed No Eliminaci\u00f3n de Duplicados Autom\u00e1tica Requiere c\u00f3digo adicional Rendimiento en B\u00fasqueda Mejor Menos eficiente"},{"location":"javascript/set/#conclusion","title":"Conclusi\u00f3n","text":"<p>El objeto <code>Set</code> en JavaScript es una herramienta poderosa para manejar datos \u00fanicos de manera eficiente. Desde eliminar duplicados hasta realizar operaciones de conjunto como uni\u00f3n e intersecci\u00f3n, <code>Set</code> es una alternativa vers\u00e1til a los arrays en muchos casos. Comprender sus m\u00e9todos y usos te ayudar\u00e1 a escribir c\u00f3digo m\u00e1s limpio, optimizado y profesional.</p> <p></p>"},{"location":"javascript/sintaxis-javascript/","title":"Sintaxis de JavaScript","text":""},{"location":"javascript/sintaxis-javascript/#sintaxis-de-javascript-fundamentos-y-elementos-clave","title":"Sintaxis de JavaScript: Fundamentos y Elementos Clave","text":"<p>La sintaxis de JavaScript define las reglas y estructuras que se deben seguir para escribir c\u00f3digo v\u00e1lido. Es fundamental comprender los conceptos b\u00e1sicos para evitar errores y aprovechar al m\u00e1ximo las capacidades del lenguaje. En este art\u00edculo exploraremos los aspectos esenciales de la sintaxis de JavaScript, incluyendo declaraciones, identificadores, comentarios, expresiones y palabras reservadas.</p>"},{"location":"javascript/sintaxis-javascript/#declaraciones-en-javascript","title":"Declaraciones en JavaScript","text":"<p>Las declaraciones son instrucciones que indican al programa que realice una acci\u00f3n espec\u00edfica, como asignar un valor a una variable, llamar a una funci\u00f3n o ejecutar un bucle. En JavaScript, las declaraciones generalmente terminan con un punto y coma (<code>;</code>), aunque no es obligatorio se recomienda para mejorar la legibilidad y evitar errores.</p> <p>Las declaraciones son la base para construir cualquier l\u00f3gica en JavaScript. Cada l\u00ednea de c\u00f3digo ejecutable en un programa se considera una declaraci\u00f3n.</p>"},{"location":"javascript/sintaxis-javascript/#ejemplo-de-declaracion","title":"Ejemplo de Declaraci\u00f3n:","text":"javascript<pre><code>const mensaje = \"Hola, mundo\";\nconsole.log(mensaje);\n</code></pre> <p>En el ejemplo anterior la primera declaraci\u00f3n asigna un valor a la variable <code>mensaje</code>, mientras que la segunda muestra el valor en la consola.</p> <p>Buenas pr\u00e1cticas: Es recomendable seguir estas pautas para que el c\u00f3digo sea m\u00e1s legible:</p> <ul> <li>Usar una declaraci\u00f3n por l\u00ednea: Evita combinar m\u00faltiples declaraciones en una sola l\u00ednea.</li> <li>Terminar cada declaraci\u00f3n con un punto y coma (<code>;</code>): Aunque JavaScript puede interpretar las declaraciones sin \u00e9l, es mejor incluirlo para prevenir errores en c\u00f3digo m\u00e1s complejo.</li> </ul>"},{"location":"javascript/sintaxis-javascript/#bloques-en-javascript","title":"Bloques en JavaScript","text":"<p>Los bloques de c\u00f3digo son secuencias de declaraciones agrupadas entre llaves {\u2026}. Estos son comunes en las estructuras de control como los bucles y funciones, adem\u00e1s estos permiten controlar el \u00e1mbito (scope) de las variables.</p> <p>Los bloques permiten organizar el c\u00f3digo en secciones manejables delimitando su \u00e1mbito. Esto es especialmente \u00fatil cuando se trabaja con estructuras de control, como condicionales y bucles para asegurar que el flujo del programa se comporte de manera esperada.</p> javascript<pre><code>const condicion = true;\n\nif (condicion) {\n  // Declaraciones dentro del bloque if\n} else {\n  // Declaraciones dentro del bloque else\n}\n\nwhile (condicion) {\n  // Declaraciones dentro del bloque while\n}\n</code></pre> <p>En el anterior snippet se muestra como los bloques ayudan a definir las acciones a realizar en diferentes condiciones o repeticiones.</p> <p> Es importante recordar que JavaScript utiliza el alcance l\u00e9xico, lo que significa que las variables declaradas dentro de un bloque estar\u00e1n disponibles solo dentro de ese bloque y de los bloques internos, pero no fuera de ellos.</p> <p></p>"},{"location":"javascript/sintaxis-javascript/#identificadores-en-javascript","title":"Identificadores en JavaScript","text":"<p>Los identificadores son nombres que se utilizan para referirse a variables, funciones, clases y otros elementos del programa. Estos deben seguir ciertas reglas de nomenclatura. Ejemplo: Deben comenzar con una letra, guion bajo (<code>_</code>) o signo de d\u00f3lar (<code>$</code>) y pueden contener letras, n\u00fameros, guiones bajos y signos de d\u00f3lar.</p> <p>Elegir identificadores claros y descriptivos es importante para que el c\u00f3digo sea f\u00e1cil de entender. Adem\u00e1s, es fundamental seguir las convenciones y reglas de nomenclatura para evitar errores.</p> <p>Ejemplo: Identificadores v\u00e1lidos:</p> javascript<pre><code>let nombreUsuario = \"Carlos\";\nlet _resultado = 100;\nlet $totalVentas = 5000;\n</code></pre> <p> Ten en cuenta que la letra inicial no se limita al conjunto de caracteres ASCII y puede incluir caracteres ASCII extendidos o Unicode, aunque no se recomienda su uso.</p> <p></p> <p>Reglas importantes:</p> <ul> <li>Los identificadores son sensibles a may\u00fasculas y min\u00fasculas (<code>variable</code> y <code>Variable</code> se consideran diferentes).</li> <li>No se pueden utilizar palabras clave reservadas como identificadores, ya que est\u00e1n reservadas para funciones espec\u00edficas del lenguaje.</li> </ul>"},{"location":"javascript/sintaxis-javascript/#javascript-es-case-sensitive","title":"JavaScript es Case Sensitive","text":"<p>Los identificadores en JavaScript son sensibles a may\u00fasculas y min\u00fasculas. Esto significa que el lenguaje trata las letras may\u00fasculas y min\u00fasculas como caracteres diferentes. Por lo tanto, en el siguiente ejemplo los identificadores <code>message</code> y <code>Message</code> ser\u00edan considerados dos variables distintas.</p> javascript<pre><code>var message = \"Hola, esto es un mensaje.\";\nvar Message = \"Esto es otro mensaje.\";\n\nconsole.log(message);\nconsole.log(Message);\n</code></pre> <p>Es importante recordar esta distinci\u00f3n al nombrar tus variables y al referenciarlas m\u00e1s adelante en tu c\u00f3digo para evitar confusiones o errores inesperados.</p>"},{"location":"javascript/sintaxis-javascript/#comentarios-en-javascript","title":"Comentarios en JavaScript","text":"<p>Los comentarios son partes del c\u00f3digo que se ignoran durante la ejecuci\u00f3n del programa. Se utilizan para documentar el c\u00f3digo, explicar el prop\u00f3sito de ciertas secciones o anotar cosas que se deben hacer.</p> <p>El uso de comentarios es una pr\u00e1ctica com\u00fan para mejorar la legibilidad del c\u00f3digo y facilitar la colaboraci\u00f3n entre desarrolladores, proporcionando una mejor comprensi\u00f3n del prop\u00f3sito de las instrucciones o dejando notas \u00fatiles.</p>"},{"location":"javascript/sintaxis-javascript/#comentarios-de-una-sola-linea","title":"Comentarios de Una Sola L\u00ednea:","text":"<p>Para crear un comentario de una sola l\u00ednea en JavaScript, simplemente debes a\u00f1adir dos barras inclinadas (<code>//</code>) antes del texto que actuar\u00e1 como comentario.</p> javascript<pre><code>// Esto es un comentario de una sola l\u00ednea\n</code></pre>"},{"location":"javascript/sintaxis-javascript/#comentarios-de-bloque","title":"Comentarios de Bloque","text":"<p>Para crear un comentario de bloque o de varias l\u00edneas en JavaScript, utilizamos una barra inclinada seguida de un asterisco (<code>/*</code>) para iniciar el comentario y a\u00f1adimos un asterisco seguido de una barra inclinada (<code>*/</code>) para finalizarlo.</p> javascript<pre><code>/* \n  Esto es un comentario \n  de m\u00faltiples l\u00edneas \n*/\n</code></pre> <p> Utilizar comentarios de manera efectiva puede ayudar a identificar r\u00e1pidamente secciones clave del c\u00f3digo y entender su prop\u00f3sito.</p> <p></p>"},{"location":"javascript/sintaxis-javascript/#expresiones-en-javascript","title":"Expresiones en JavaScript","text":"<p>Una expresi\u00f3n es cualquier combinaci\u00f3n de valores, variables, operadores y funciones que se eval\u00faa para producir un resultado. Las expresiones son esenciales en JavaScript ya que permiten realizar operaciones y evaluar condiciones.</p> <p>Las expresiones son las piezas b\u00e1sicas y pueden ser tan simples como un valor num\u00e9rico o tan complejas como una combinaci\u00f3n de m\u00faltiples operadores y funciones.</p>"},{"location":"javascript/sintaxis-javascript/#tipos-comunes-de-expresiones","title":"Tipos Comunes de Expresiones:","text":"<ol> <li>Expresiones aritm\u00e9ticas: Las expresiones aritm\u00e9ticas son \u00fatiles para c\u00e1lculos matem\u00e1ticos, como sumar, restar, multiplicar o dividir.</li> </ol> javascript<pre><code>const suma = 5 + 3;\n</code></pre> <ol> <li>Expresiones l\u00f3gicas: Eval\u00faan condiciones y devuelven valores booleanos (<code>true</code> o <code>false</code>). Son comunes en las estructuras de control, como <code>if</code>, <code>while</code> y <code>for</code>, donde las condiciones determinan el flujo de ejecuci\u00f3n.</li> </ol> javascript<pre><code>const esMayor = 10 &gt; 5;\n</code></pre> <ol> <li>Expresiones de asignaci\u00f3n: Permiten almacenar el resultado de una operaci\u00f3n o valor en una variable para su uso posterior.</li> </ol> javascript<pre><code>const resultado = 20;\n</code></pre> <p>B\u00e1sicamente las expresiones son la base de los c\u00e1lculos, la l\u00f3gica y la programaci\u00f3n en general.</p>"},{"location":"javascript/sintaxis-javascript/#palabras-clave-y-palabras-reservadas","title":"Palabras Clave y Palabras Reservadas","text":"<p>JavaScript tiene palabras clave reservadas para usos espec\u00edficos y exclusivos del lenguaje. Estas palabras no se pueden usar como nombres de variables, funciones o identificadores ya que est\u00e1n destinadas a funciones espec\u00edficas, como declarar variables, definir funciones o controlar el flujo del programa.</p> <p>La siguiente tabla muestra las palabras reservadas de JavaScript tal como se definen en ECMA-262:</p> Claves break case catch continue debugger default else export extends function if import new return super throw try null void while with class delete finally in switch typeof yield const do for instanceof this var <p>Adem\u00e1s de las palabras clave reservadas, ECMA-252 tambi\u00e9n define una lista de futuras palabras reservadas que no se pueden utilizar como identificadores o nombres de propiedad:</p> Claves enum implements let protected private public await interface package implements public <p>Conocer las palabras clave es importante para evitar errores de sintaxis y comprender mejor las funciones internas del lenguaje.</p>"},{"location":"javascript/sintaxis-javascript/#conclusion","title":"Conclusi\u00f3n","text":"<p>Comprender la sintaxis de JavaScript es fundamental para escribir c\u00f3digo correctamente. Conocer los conceptos b\u00e1sicos como declaraciones, bloques, identificadores, comentarios, expresiones y palabras clave te permitir\u00e1 avanzar con confianza en el aprendizaje de JavaScript. Estos fundamentos son esenciales para construir aplicaciones m\u00e1s complejas y aprovechar al m\u00e1ximo las capacidades del lenguaje.</p> <p>En el siguiente art\u00edculo exploraremos las variables en JavaScript, c\u00f3mo se declaran y gestionan, as\u00ed como las diferencias entre <code>var</code>, <code>let</code> y <code>const</code>.</p> <p></p>"},{"location":"javascript/string/","title":"Cadena de Caracteres","text":""},{"location":"javascript/string/#strings-cadena-de-caracteres","title":"Strings: Cadena de Caracteres","text":"<p>En el mundo de la programaci\u00f3n las cadenas de caracteres o strings son una de las estructuras de datos m\u00e1s utilizadas. Estas representan texto y permiten manipular datos textuales de manera flexible. En JavaScript, los strings son valores primitivos que se pueden utilizar para manejar y procesar texto en aplicaciones web.</p> <p>En este art\u00edculo exploraremos c\u00f3mo crear, manipular y utilizar strings en JavaScript, abarcando su uso com\u00fan y buenas pr\u00e1cticas.</p>"},{"location":"javascript/string/#creacion-de-strings-en-javascript","title":"Creaci\u00f3n de Strings en JavaScript","text":"<p>Un string no es m\u00e1s que una colecci\u00f3n de caracteres, como letras, n\u00fameros y s\u00edmbolos y se puede crear utilizando comillas simples (<code>' '</code>), dobles (<code>\" \"</code>) o comillas invertidas (`<code></code>`). Cada una tiene sus propios casos de uso:</p> <ul> <li>Comillas simples y dobles se utilizan indistintamente para crear cadenas literales y se recomiendan cuando no se necesita interpolaci\u00f3n.</li> <li>Comillas invertidas (template literals), introducidas en ES6, permiten crear cadenas m\u00e1s din\u00e1micas mediante la interpolaci\u00f3n de variables y el soporte para cadenas multil\u00ednea.</li> </ul> <p>Ejemplos de Creaci\u00f3n de Strings:</p> javascript<pre><code>const saludo = \"Hola, mundo\";\nconst nombre = 'Juan P\u00e9rez';\nconst mensaje = `Bienvenido, ${nombre}!`;  // Template literal con interpolaci\u00f3n\n</code></pre> <p>Las comillas invertidas son especialmente \u00fatiles cuando se necesita incluir variables dentro del string o definir cadenas con saltos de l\u00ednea.</p>"},{"location":"javascript/string/#constructor-de-strings","title":"Constructor de Strings","text":"<p>Adem\u00e1s de crear cadenas utilizando la notaci\u00f3n literal, JavaScript proporciona un constructor de objeto llamado <code>String()</code> que permite crear objetos de tipo cadena.</p> javascript<pre><code>const myString = new String('Hola mundo');\n\nconsole.log(myString);\n</code></pre> <p>En el ejemplo anterior utilizamos el constructor <code>String()</code> para crear un nuevo objeto de cadena con el valor <code>\"Hola mundo\"</code>. Es importante tener en cuenta que aunque esto crea una cadena de caracteres, en la pr\u00e1ctica es m\u00e1s com\u00fan y preferible usar la notaci\u00f3n literal de cadena debido a su simplicidad y claridad.</p>"},{"location":"javascript/string/#longitud-de-un-string","title":"Longitud de un String","text":"<p>Conocer la longitud de un string es importante para validar entradas de texto o para manipular los caracteres de manera precisa. En JavaScript, la propiedad <code>length</code> permite obtener el n\u00famero de caracteres que componen una cadena.</p> javascript<pre><code>let mensaje = \"Hola, JavaScript!\";\n\nconsole.log(mensaje.length);\n</code></pre> <p>En este caso <code>length</code> devuelve el n\u00famero total de caracteres, incluidos los espacios y los signos de puntuaci\u00f3n.</p> <p> Es importante tener en cuenta que en JavaScript existe el tipo String (con la primera letra en may\u00fascula), el cual es el tipo de contenedor primitivo para las cadenas. Esto significa que se pueden acceder a todas las propiedades y m\u00e9todos del tipo String desde una cadena primitiva.</p> <p></p>"},{"location":"javascript/string/#acceso-a-los-caracteres-de-un-string","title":"Acceso a los Caracteres de un String","text":"<p>En JavaScript puedes acceder a los caracteres individuales de un string usando el \u00edndice, de manera similar a c\u00f3mo acceder\u00edas a los elementos de un array. Los \u00edndices comienzan en <code>0</code>, lo que significa que el primer car\u00e1cter est\u00e1 en la posici\u00f3n <code>0</code>.</p> <p>Ejemplo de Acceso a Caracteres:</p> javascript<pre><code>const texto = \"JavaScript!!\";\n\nconsole.log(texto[0]);\nconsole.log(texto[4]);\n</code></pre> <p>Este enfoque es \u00fatil cuando necesitas recorrer una cadena o extraer caracteres espec\u00edficos.</p> <p>Para acceder al \u00faltimo car\u00e1cter de un string puedes utilizar el \u00edndice <code>length - 1</code>.</p> javascript<pre><code>const texto = \"JavaScript!!\";\n\nconsole.log(texto[texto.length -1]);\n</code></pre> <p>Es importante recordar que las cadenas en JavaScript son inmutables, lo que significa que no puedes cambiar un car\u00e1cter directamente usando esta notaci\u00f3n.</p>"},{"location":"javascript/string/#manipulacion-de-strings","title":"Manipulaci\u00f3n de Strings","text":"<p>Aunque los strings en JavaScript son inmutables (no pueden ser modificados directamente), puedes crear nuevas cadenas a partir de las existentes. La manipulaci\u00f3n de strings es esencial para formatear texto o combinar diferentes partes de una cadena.</p>"},{"location":"javascript/string/#1-concatenacion","title":"1. Concatenaci\u00f3n","text":"<p>La concatenaci\u00f3n se refiere a unir dos o m\u00e1s cadenas para formar una nueva. Puedes utilizar el operador <code>+</code> o <code>+=</code> para realizar la operaci\u00f3n.</p> javascript<pre><code>const nombre = \"Juan\";\nconst apellido = \"P\u00e9rez\";\nconst nombreCompleto = nombre + \" \" + apellido;\n\nconsole.log(nombreCompleto);\n</code></pre> <p>Este m\u00e9todo es una forma sencilla y com\u00fan de crear cadenas m\u00e1s complejas a partir de valores m\u00e1s simples.</p>"},{"location":"javascript/string/#2-concatenacion-con-template-literals","title":"2. Concatenaci\u00f3n con Template Literals","text":"<p>Los template literals ofrecen una forma m\u00e1s moderna y conveniente de concatenar strings. Al utilizar comillas invertidas (``) puedes incluir variables directamente en el texto con la sintaxis <code>${variable}</code>.</p> javascript<pre><code>const producto = \"Camisa\";\nconst cantidad = 3;\nconst mensaje = `Tienes ${cantidad} ${producto}s en tu carrito.`;\n\nconsole.log(mensaje);\n</code></pre> <p>Esta t\u00e9cnica no solo facilita la concatenaci\u00f3n, sino que tambi\u00e9n permite el uso de saltos de l\u00ednea y otros caracteres especiales sin necesidad de escape adicional.</p>"},{"location":"javascript/string/#caracteres-especiales-en-strings","title":"Caracteres Especiales en Strings","text":"<p>Los caracteres especiales son secuencias de escape que permiten incluir en el string elementos que no se pueden escribir directamente, como saltos de l\u00ednea, comillas o caracteres Unicode.</p> <p>Ejemplos de Caracteres Especiales</p> <ul> <li>Salto de l\u00ednea (<code>\\n</code>): Inserta un salto de l\u00ednea.</li> <li>Tabulaci\u00f3n (<code>\\t</code>): Inserta un tabulador.</li> <li>Comillas: Utiliza <code>'</code> o <code>\"</code> para insertar comillas simples o dobles.</li> </ul> javascript<pre><code>const textoEspecial = \"Primera l\u00ednea\\nSegunda l\u00ednea\";\n\nconsole.log(textoEspecial); \n</code></pre> <p>El uso de caracteres especiales es \u00fatil para formatear texto en mensajes de consola, archivos de texto y contenido HTML.</p>"},{"location":"javascript/string/#convertir-otros-tipos-de-datos-a-strings","title":"Convertir Otros Tipos de Datos a Strings","text":"<p>En muchas situaciones es necesario convertir otros tipos de datos a cadenas. JavaScript ofrece varias formas de realizar esta conversi\u00f3n, lo cual es \u00fatil para mostrar valores num\u00e9ricos, booleanos u otros datos como texto.</p> <p>Puedes convertir a string utilizando <code>String()</code> o <code>.toString()</code>:</p> javascript<pre><code>const numero = 123;\nconst textoNumero = numero.toString();\nconsole.log(textoNumero);\n\nconst booleano = true;\nconst textoBooleano = String(booleano);\nconsole.log(textoBooleano);\n</code></pre> <p>Estas conversiones son esenciales para la manipulaci\u00f3n de datos y la creaci\u00f3n de mensajes din\u00e1micos.</p> <p>Tambien es importante destacar que el m\u00e9todo <code>toString()</code> no funciona para valores <code>undefined</code> y <code>null</code>. Ademas, cuando se convierte una cadena a booleano, no se puede revertir el proceso.</p>"},{"location":"javascript/string/#comparacion-de-strings","title":"Comparaci\u00f3n de Strings","text":"<p>Comparar cadenas de caracteres en JavaScript se hace utilizando operadores de comparaci\u00f3n (<code>&lt;</code>, <code>&gt;</code>, <code>==</code>, <code>===</code>). La comparaci\u00f3n de strings es sensible al orden lexicogr\u00e1fico (alfab\u00e9tico), donde el valor de cada car\u00e1cter se basa en su c\u00f3digo Unicode.</p> javascript<pre><code>const str1 = \"apple\";\nconst str2 = \"banana\";\n\nconsole.log(str1 &lt; str2);\n</code></pre> <p>En el ejemplo anterior <code>\"apple\"</code> es menor que <code>\"banana\"</code> porque la letra \u201ca\u201d tiene un c\u00f3digo Unicode menor que la letra \u201cb\u201d.</p> <p>Para comparaciones m\u00e1s espec\u00edficas, como el ordenamiento en diferentes idiomas, puedes usar <code>localeCompare()</code>:</p> javascript<pre><code>const str1 = \"apple\";\nconst str2 = \"banana\";\n\nconsole.log(str1.localeCompare(str2));\n</code></pre> <p>El m\u00e9todo <code>localeCompare()</code> devuelve un n\u00famero que indica si la cadena actual es menor, igual o mayor que la cadena comparada.</p>"},{"location":"javascript/string/#otros-metodos-utiles","title":"Otros M\u00e9todos \u00datiles","text":"<p>Las cadenas de caracteres en JavaScript ofrecen una variedad de m\u00e9todos integrados para su manipulaci\u00f3n. Entre ellos se encuentran <code>split()</code>, <code>substring()</code>, <code>indexOf()</code>, <code>toUpperCase()</code>, <code>toLowerCase()</code>, entre otros. Estos m\u00e9todos se exploran y detallan en tutoriales espec\u00edficos.</p>"},{"location":"javascript/string/#conclusion","title":"Conclusi\u00f3n","text":"<p>Las cadenas de caracteres en JavaScript son fundamentales para trabajar con datos textuales. Conocer las t\u00e9cnicas para crear, manipular y comparar strings te ayudar\u00e1 a manejar informaci\u00f3n textual de manera m\u00e1s efectiva en tus programas.</p> <p>En el siguiente art\u00edculo exploraremos la diferencia entre valores primitivos y valores de referencia en JavaScript, c\u00f3mo afectan la mutabilidad y el comportamiento de los datos en el lenguaje.</p> <p></p>"},{"location":"javascript/throw/","title":"Lanzar Excepciones con throw","text":""},{"location":"javascript/throw/#lanzar-excepciones-con-throw","title":"Lanzar Excepciones con throw","text":"<p>El manejo de errores en JavaScript no solo implica capturar problemas con try\u2026catch, sino tambi\u00e9n lanzar excepciones cuando se detectan situaciones inv\u00e1lidas o inesperadas. El uso de la instrucci\u00f3n <code>throw</code> permite detener la ejecuci\u00f3n de un programa y definir un mensaje de error o un objeto de excepci\u00f3n que detalla lo ocurrido.</p> <p>En este art\u00edculo exploraremos c\u00f3mo usar <code>throw</code> para manejar errores de manera proactiva y c\u00f3mo personalizar los mensajes para mejorar la depuraci\u00f3n y la experiencia del usuario.</p>"},{"location":"javascript/throw/#que-es-la-instruccion-throw-en-javascript","title":"\u00bfQu\u00e9 es la instrucci\u00f3n throw en JavaScript?","text":"<p>La instrucci\u00f3n <code>throw</code> en JavaScript se utiliza para lanzar excepciones, las cuales pueden ser manejadas con un bloque <code>try...catch</code>. Cuando el motor de JavaScript encuentra una instrucci\u00f3n <code>throw</code> pasa lo siguiente:</p> <ol> <li>Detiene inmediatamente la ejecuci\u00f3n del c\u00f3digo en el bloque actual.</li> <li>Busca el bloque <code>catch</code> m\u00e1s cercano en la pila de llamadas.</li> <li>Si no encuentra un bloque <code>catch</code>, el script se detiene y el error se muestra en la consola.</li> </ol>"},{"location":"javascript/throw/#sintaxis-basica","title":"Sintaxis b\u00e1sica:","text":"javascript<pre><code>throw expresi\u00f3n;\n</code></pre> <p><code>expresi\u00f3n</code>: Define el valor de la excepci\u00f3n. Puede ser un string, un n\u00famero, un objeto o una instancia de la clase <code>Error</code>.</p>"},{"location":"javascript/throw/#ejemplo-basico-lanzar-excepciones-con-throw","title":"Ejemplo b\u00e1sico: Lanzar excepciones con throw","text":"<p>En muchas situaciones es necesario detener la ejecuci\u00f3n de una funci\u00f3n si las entradas proporcionadas no cumplen con las expectativas. <code>throw</code> permite lanzar una excepci\u00f3n en estos casos, proporcionando un mensaje descriptivo que facilita identificar el problema.</p> <p>En el siguiente ejemplo validamos los argumentos de una funci\u00f3n <code>sumar</code>. Si los argumentos no son n\u00fameros, se generar\u00e1 una excepci\u00f3n con un mensaje claro que ser\u00e1 manejado en un bloque <code>try...catch</code>.</p> javascript<pre><code>function sumar(x, y) {\n    if (typeof x !== 'number') {\n        throw 'El primer argumento debe ser un n\u00famero';\n    }\n    if (typeof y !== 'number') {\n        throw 'El segundo argumento debe ser un n\u00famero';\n    }\n    return x + y;\n}\n\ntry {\n    const resultado = sumar('a', 10); // Error: El primer argumento no es un n\u00famero\n    console.log(\"Resultado:\", resultado);\n} catch (error) {\n    console.log(\"Error capturado:\", error);\n}\n</code></pre> <p>Explicaci\u00f3n del ejemplo</p> <ol> <li>La funci\u00f3n <code>sumar</code> valida los tipos de sus argumentos con <code>typeof</code>.</li> <li>Si alg\u00fan argumento no es un n\u00famero, lanza una excepci\u00f3n con <code>throw</code> y un mensaje descriptivo.</li> <li>El bloque <code>try</code> intenta ejecutar la funci\u00f3n, pero al detectar un error, el control pasa al bloque <code>catch</code>, donde se captura y muestra el mensaje.</li> </ol> <p>Este ejemplo muestra c\u00f3mo <code>throw</code> puede ser una herramienta eficaz para validar datos y detener el flujo cuando las entradas no son v\u00e1lidas, lo que resulta en un programa m\u00e1s robusto y confiable.</p>"},{"location":"javascript/throw/#usando-throw-con-objetos-de-la-clase-error","title":"Usando throw con objetos de la clase Error","text":"<p>Es com\u00fan usar instancias de la clase <code>Error</code> en lugar de cadenas simples para lanzar excepciones, ya que estas proporcionan m\u00e1s contexto, como el nombre del error y un mensaje detallado.</p> javascript<pre><code>function dividir(a, b) {\n    if (b === 0) {\n        throw new Error(\"No se puede dividir por cero.\");\n    }\n    return a / b;\n}\n\ntry {\n    const resultado = dividir(10, 0);\n    console.log(\"Resultado:\", resultado);\n} catch (error) {\n    console.log(error.name + \":\", error.message);\n}\n</code></pre> <p>Explicaci\u00f3n del ejemplo</p> <ol> <li>Si el divisor es igual a cero, se lanza un objeto de la clase <code>Error</code> con un mensaje descriptivo.</li> <li>El bloque <code>catch</code> captura la excepci\u00f3n y accede a las propiedades <code>name</code> y <code>message</code> para mostrar un mensaje claro.</li> </ol> <p>Usar objetos <code>Error</code> facilita la identificaci\u00f3n y manejo de excepciones en aplicaciones complejas.</p>"},{"location":"javascript/throw/#crear-excepciones-personalizadas","title":"Crear excepciones personalizadas","text":"<p>En algunos casos, puede ser \u00fatil crear clases personalizadas para manejar errores espec\u00edficos en tu aplicaci\u00f3n. Esto permite distinguir entre diferentes tipos de excepciones.</p> javascript<pre><code>class NumberError extends Error {\n    constructor(valor) {\n        super(`\"${valor}\" no es un n\u00famero v\u00e1lido.`);\n        this.name = \"NumberError\";\n    }\n}\n\nfunction validarNumero(valor) {\n    if (typeof valor !== 'number') {\n        throw new NumberError(valor);\n    }\n}\n\ntry {\n    validarNumero(\"texto\");\n} catch (error) {\n    console.log(error.name + \":\", error.message);\n}\n</code></pre> <p>Explicaci\u00f3n del ejemplo</p> <ol> <li>Se define la clase <code>NumberError</code> que extiende la clase <code>Error</code> y personaliza su mensaje.</li> <li>En la funci\u00f3n <code>validarNumero</code>, se lanza una instancia de <code>NumberError</code> si el argumento no es un n\u00famero.</li> <li>El bloque <code>catch</code> captura la excepci\u00f3n personalizada y muestra su tipo (<code>name</code>) y mensaje.</li> </ol> <p>Este enfoque permite manejar errores de manera m\u00e1s espec\u00edfica, facilitando el dise\u00f1o de sistemas robustos y escalables.</p>"},{"location":"javascript/throw/#buenas-practicas-al-usar-throw","title":"Buenas pr\u00e1cticas al usar throw","text":"<ol> <li>Usa mensajes claros y descriptivos: Aseg\u00farate de que los mensajes de las excepciones expliquen claramente el problema y c\u00f3mo solucionarlo.</li> <li>Prefiere objetos <code>Error</code>: Usar objetos <code>Error</code> en lugar de cadenas simples proporciona m\u00e1s contexto y facilita la depuraci\u00f3n.</li> <li>Distingue tipos de errores: Si tu aplicaci\u00f3n tiene m\u00faltiples tipos de errores, considera usar clases personalizadas para diferenciarlos.</li> <li>No abuses de <code>throw</code>: \u00dasalo solo para errores que realmente interrumpan el flujo l\u00f3gico del programa. Para casos menores, considera validaciones simples.</li> </ol>"},{"location":"javascript/throw/#conclusion","title":"Conclusi\u00f3n","text":"<p>La instrucci\u00f3n <code>throw</code> en JavaScript es una herramienta poderosa para manejar errores de manera proactiva, permitiendo detener la ejecuci\u00f3n cuando algo no va como se espera. Desde lanzar excepciones con mensajes personalizados hasta crear clases espec\u00edficas para errores, el uso adecuado de <code>throw</code> puede hacer que tus aplicaciones sean m\u00e1s robustas y f\u00e1ciles de depurar.</p> <p></p>"},{"location":"javascript/tipos-de-datos/","title":"Tipos de datos","text":""},{"location":"javascript/tipos-de-datos/#tipos-de-datos","title":"Tipos de datos","text":"<p>En JavaScript los tipos de datos son fundamentales para gestionar y manipular la informaci\u00f3n. Entender los diferentes tipos y c\u00f3mo funcionan es esencial para escribir c\u00f3digo eficiente. JavaScript tiene varios tipos de datos que se dividen en dos categor\u00edas principales: primitivos y de referencia. En este art\u00edculo, exploraremos cada tipo de dato en JavaScript, c\u00f3mo funcionan y ejemplos pr\u00e1cticos para ilustrar su uso.</p>"},{"location":"javascript/tipos-de-datos/#conocer-el-tipo-de-dato-en-javascript","title":"Conocer el Tipo de Dato en JavaScript","text":"<p>JavaScript es un lenguaje de tipado din\u00e1mico, lo que significa que una variable puede contener valores de diferentes tipos sin estar vinculada a uno espec\u00edfico. Por ejemplo:</p> javascript<pre><code>let score = 10;      // score es un n\u00famero\nscore = true;        // score ahora es un booleano\nscore = \"ganador\";   // score ahora es una cadena de texto\n</code></pre> <p>Por lo tanto es importante determinar el tipo actual del valor almacenado en una variable. Para hacerlo utilizamos el operador <code>typeof</code>.</p> javascript<pre><code>let score = 10;\nconsole.log(typeof(score));\n\nscore = false; \nconsole.log(typeof(score));\n\nscore = \"Hi\";\nconsole.log(typeof(score));\n</code></pre> <p>Ahora que sabemos identificar el tipo de dato de una variable, podemos conocer como estos est\u00e1n definidos en JavaScript. Comencemos con los primitivos:</p>"},{"location":"javascript/tipos-de-datos/#tipos-de-datos-primitivos","title":"Tipos de Datos Primitivos","text":"<p>Los tipos primitivos son los m\u00e1s b\u00e1sicos y simples en JavaScript. Estos se caracterizan por ser inmutables, lo que significa que su valor no se puede cambiar una vez creado.</p> <p>Los tipos de datos primitivos en JavaScript son: <code>null</code>, <code>undefined</code>, <code>boolean</code>, <code>number</code>, <code>string</code>, <code>symbol</code>, <code>bigint</code></p>"},{"location":"javascript/tipos-de-datos/#1-tipo-indefinido-undefined","title":"1. Tipo Indefinido: <code>undefined</code>","text":"<p>El tipo de dato <code>undefined</code> es una propiedad del objeto global y se utiliza para representar una variable que se ha declarado pero a la que a\u00fan no se le ha asignado un valor. Es decir, representa la ausencia de un valor definido.</p> javascript<pre><code>let score;\n\nconsole.log(score);\nconsole.log(typeof score);\n</code></pre>"},{"location":"javascript/tipos-de-datos/#2-tipo-nulo-null","title":"2. Tipo Nulo: <code>null</code>","text":"<p>En JavaScript el valor <code>null</code> representa la ausencia intencional de un valor. Es uno de los valores primitivos y se utiliza cuando se quiere indicar que una variable no tiene un valor asignado o que est\u00e1 \u201cvac\u00eda\u201d.</p> javascript<pre><code>let score = null;\n\nif (score === null) {\n  console.log('Aun no tienes un score iniciado');\n} else {\n  console.log(\"Tu score es \" + score);\n}\n</code></pre> <p>A diferencia de <code>undefined</code>, <code>null</code> se asigna expl\u00edcitamente a una variable como representaci\u00f3n de la ausencia de valor.</p>"},{"location":"javascript/tipos-de-datos/#3-tipo-numero-number","title":"3. Tipo N\u00famero: <code>number</code>","text":"<p>El tipo de dato <code>number</code> incluye tanto n\u00fameros enteros como n\u00fameros decimales. En JavaScript no hay distinci\u00f3n entre n\u00fameros enteros e \u00edndices flotantes.</p> javascript<pre><code>const entero = 42;\nconst decimal = 3.14;\nconst negativo = -10;\n</code></pre> <p>Casos especiales de <code>number</code></p> <ul> <li><code>Infinity</code>: Resultado de dividir un n\u00famero por cero.</li> <li><code>-Infinity</code>: Resultado de dividir un n\u00famero negativo por cero.</li> <li><code>NaN</code> (Not a Number): Indica que un valor no es num\u00e9rico.</li> </ul> javascript<pre><code>console.log(1 / 0);\nconsole.log(-1 / 0);\nconsole.log(\"hola\" * 2);\n</code></pre>"},{"location":"javascript/tipos-de-datos/#4-tipo-cadena-de-caracteres-string","title":"4. Tipo Cadena de Caracteres: <code>string</code>","text":"<p>El tipo de dato string o cadena se utiliza para representar una secuencia de caracteres y es uno de los tipos de datos m\u00e1s utilizados en JavaScript. Se puede definir con comillas simples, dobles o acento grave para los template literals, que permiten interpolaci\u00f3n de variables.</p> javascript<pre><code>let saludo = \"Hola\";\nlet nombre = 'Mundo';\nlet mensaje = `Hola, ${nombre}!`;  // Template literal\n\nconsole.log(mensaje);\n</code></pre> <p> Los tipos strings en JavaScript son inmutables, lo que quiere decir que no se pueden modificar una vez creadas. No obstante, puedes crear una nueva cadena a partir de una existente.</p> <p></p>"},{"location":"javascript/tipos-de-datos/#5-tipo-booleano-boolean","title":"5. Tipo Booleano: <code>boolean</code>","text":"<p>El tipo de dato <code>boolean</code> representa un valor l\u00f3gico que puede ser <code>true</code> o <code>false</code> (verdadero / falso). Es com\u00fanmente utilizado en condiciones y comparaciones.</p> javascript<pre><code>let esMayor = 10 &gt; 5;  // true\nlet esIgual = 10 === \"10\";  // false\n</code></pre> <p>Es importante destacar que en JavaScript algunos valores se consideran \u201c<code>falsy</code>\u201d o equivalentes a <code>false</code> cuando se eval\u00faan en un contexto booleano. Estos incluyen <code>0</code>, <code>-0</code>, <code>null</code>, <code>false</code>, <code>NaN</code>, <code>undefined</code> y un string vacio <code>\"\"</code>.</p> <p>Por otro lado, todos los dem\u00e1s valores se consideran \u201c<code>truthy</code>\u201d o equivalentes a <code>true</code>, incluyendo objetos, arreglos y cadenas no vac\u00edas.</p>"},{"location":"javascript/tipos-de-datos/#6-tipo-simbolo-symbol","title":"6. Tipo S\u00edmbolo: <code>Symbol</code>","text":"<p>El tipo <code>symbol</code> es un valor \u00fanico e inmutable usado com\u00fanmente como identificador para las propiedades de los objetos. Cada vez que se crea un <code>symbol</code> es \u00fanico.</p> javascript<pre><code>let id1 = Symbol(\"id\");\nlet id2 = Symbol(\"id\");\n\nconsole.log(id1 === id2);\n</code></pre> <p>La funci\u00f3n <code>Symbol()</code> crea un nuevo valor \u00fanico cada vez que se llama. Por lo tanto si intentamos comparar sus valores, obtendremos el valor booleano <code>false</code>:</p> javascript<pre><code>console.log(Symbol() == Symbol());\n</code></pre>"},{"location":"javascript/tipos-de-datos/#7-tipo-bigint","title":"7. Tipo Bigint","text":"<p>El tipo bigInt en JavaScript es un primitivo que se introdujo para representar n\u00fameros enteros m\u00e1s grandes que el valor m\u00e1ximo que puede manejar el tipo <code>Number</code> (que es <code>2^53 \u2013 1</code>). A diferencia de los n\u00fameros regulares, estos pueden ser grandes y precisos.</p> javascript<pre><code>let pageView = 9007199254740991n;\n\nconsole.log(typeof(pageView));\n</code></pre>"},{"location":"javascript/tipos-de-datos/#tipos-de-datos-de-referencia","title":"Tipos de Datos de Referencia","text":"<p>Los tipos no primitivos tambi\u00e9n conocidos como tipos de referencia, son m\u00e1s complejos, estos pueden contener una colecci\u00f3n de valores y tienen comportamientos m\u00e1s din\u00e1micos. Estos incluyen: <code>objects</code> (Objetos, Fechas, Arrays y Funciones)</p>"},{"location":"javascript/tipos-de-datos/#objetos-object","title":"Objetos (<code>Object</code>)","text":"javascript<pre><code>let persona = {\n  nombre: \"Juan\",\n  edad: 30,\n  saludar: function() {\n    console.log(\"Hola, soy \" + this.nombre);\n  }\n};\n\npersona.saludar();\n</code></pre>"},{"location":"javascript/tipos-de-datos/#funciones","title":"Funciones","text":"<p>En JavaScript las funciones son objetos ciudadanos de primera clase, lo que significa que se pueden almacenar en variables, pasarlas como argumentos y devolverlas como resultado.</p> javascript<pre><code>function sumar(a, b) {\n    return a + b;\n}\n\nconsole.log(sumar(5, 3));\n</code></pre>"},{"location":"javascript/tipos-de-datos/#fechas-date","title":"Fechas (<code>Date</code>)","text":"<p>El objeto <code>Date</code> se utiliza para trabajar con fechas y horas.</p> javascript<pre><code>const hoy = new Date();\n\nconsole.log(hoy.toDateString());\n</code></pre>"},{"location":"javascript/tipos-de-datos/#diferencias-entre-tipos-primitivos-y-referenciados","title":"Diferencias Entre Tipos Primitivos y Referenciados","text":"<p>Mutabilidad:</p> <ul> <li>Los tipos primitivos son inmutables. Modificar un valor primitivo crea un nuevo valor.</li> <li>Los tipos de referencia son mutables. Cambiar una propiedad de un objeto afecta directamente el valor.</li> </ul> <p>Asignaci\u00f3n y Comparaci\u00f3n:</p> <ul> <li>Cuando se asigna un tipo primitivo, se copia el valor. Con los datos de tipos referencia, se copia la referencia en memoria.</li> <li>Los tipos de referencia se comparan por su referencia, no por su contenido.</li> </ul>"},{"location":"javascript/tipos-de-datos/#conversion-entre-tipos-de-datos","title":"Conversi\u00f3n entre tipos de datos","text":"<p>Una de las potentes caracter\u00edsticas de JavaScript es su capacidad para convertir entre distintos tipos de datos. Esto puede hacerse utilizando las funciones de conversi\u00f3n incorporadas, como <code>Number()</code>, <code>String()</code> y <code>Boolean()</code>.</p> <p>Estas funciones pueden utilizarse para convertir un valor de un tipo de datos en un valor de un tipo de datos diferente sin cambiar los datos subyacentes. Pero de esto hablamos en profundidad en otros tutoriales.</p>"},{"location":"javascript/tipos-de-datos/#conclusion","title":"Conclusi\u00f3n","text":"<p>Entender los tipos de datos en JavaScript es clave para manipular la informaci\u00f3n correctamente. Al aprender sobre los tipos primitivos y de referencia, as\u00ed como sus diferencias, puedes evitar errores comunes y escribir c\u00f3digo m\u00e1s robusto.</p> <p>En el siguiente art\u00edculo nos sumergiremos en el manejo de n\u00fameros en JavaScript, abordando operaciones matem\u00e1ticas y trucos para trabajar con precisi\u00f3n.</p> <p></p>"},{"location":"javascript/try-catch-finally/","title":"try catch finally","text":""},{"location":"javascript/try-catch-finally/#try-catch-finally","title":"try catch finally","text":"<p>El bloque try catch finally en JavaScript ampl\u00eda la funcionalidad de la estructura try\u2026catch, permitiendo ejecutar un bloque de c\u00f3digo adicional, sin importar si en el proceso de ejecuci\u00f3n de la estructura ocurri\u00f3 o no un error. Este enfoque es ideal para limpiar recursos o realizar tareas que deben ejecutarse siempre, como cerrar conexiones o liberar memoria.</p> <p>En este art\u00edculo exploraremos c\u00f3mo funciona <code>try...catch...finally</code>, ejemplos de uso y las buenas pr\u00e1cticas para integrarlo en tu c\u00f3digo.</p>"},{"location":"javascript/try-catch-finally/#que-es-try-catch-finally","title":"\u00bfQu\u00e9 es try catch finally?","text":"<p>La instrucci\u00f3n try catch finally en JavaScript permite manejar excepciones y garantizar que un bloque de c\u00f3digo final se ejecute siempre. Este bloque adicional, denominado <code>finally</code>, se ejecuta despu\u00e9s de que los bloques <code>try</code> y <code>catch</code> hayan completado su ejecuci\u00f3n, independientemente de si ocurri\u00f3 un error o no.</p> <p>Sintaxis b\u00e1sica</p> javascript<pre><code>try {\n    // C\u00f3digo que puede generar errores\n} catch (error) {\n    // C\u00f3digo para manejar errores\n} finally {\n    // C\u00f3digo que siempre se ejecutar\u00e1\n}\n</code></pre>"},{"location":"javascript/try-catch-finally/#ejemplo-basico-ejecucion-garantizada","title":"Ejemplo b\u00e1sico: Ejecuci\u00f3n garantizada","text":"<p>En el siguiente ejemplo se demuestra c\u00f3mo <code>finally</code> garantiza la ejecuci\u00f3n de un bloque final, incluso si ocurre un error.</p> javascript<pre><code>let resultado = 0;\n\ntry {\n    resultado = add(10, 20); // La funci\u00f3n `add` no est\u00e1 definida\n} catch (e) {\n    console.log(\"Error capturado:\", e.message);\n} finally {\n    console.log(\"Bloque finally ejecutado.\");\n    console.log(\"Resultado actual:\", resultado);\n}\n</code></pre> <p>Explicaci\u00f3n del ejemplo</p> <ol> <li>Se inicializa la variable <code>resultado</code> con <code>0</code>.</li> <li>En el bloque <code>try</code>, se intenta ejecutar la funci\u00f3n <code>add</code>, que no est\u00e1 definida, lo que genera un <code>ReferenceError</code>.</li> <li>El bloque <code>catch</code> captura el error y muestra el mensaje de error.</li> <li>El bloque <code>finally</code> se ejecuta siempre, mostrando el valor actual de <code>resultado</code>, que no cambi\u00f3 porque ocurri\u00f3 un error.</li> </ol>"},{"location":"javascript/try-catch-finally/#validacion-con-un-calculo-siempre-ejecutado","title":"Validaci\u00f3n con un c\u00e1lculo siempre ejecutado","text":"<p>Cuando realizamos operaciones matem\u00e1ticas como divisiones, es importante verificar que los datos sean v\u00e1lidos para evitar errores como dividir entre cero. En este ejemplo usaremos <code>try...catch...finally</code> para manejar este caso de manera efectiva.</p> <p>Adem\u00e1s de capturar y manejar errores, el bloque <code>finally</code> nos permitir\u00e1 registrar el intento de divisi\u00f3n, asegur\u00e1ndonos de que siempre tengamos un registro del c\u00e1lculo, incluso si algo sale mal.</p> javascript<pre><code>function dividir(a, b) {\n    try {\n        if (b === 0) {\n            throw new Error(\"No se puede dividir por cero.\");\n        }\n        return a / b;\n    } catch (e) {\n        console.log(\"Error:\", e.message);\n        return null;\n    } finally {\n        console.log(`Intento de divisi\u00f3n: ${a} / ${b}`);\n    }\n}\n\nconsole.log(\"Resultado:\", dividir(10, 2)); // Divisi\u00f3n v\u00e1lida\nconsole.log(\"Resultado:\", dividir(10, 0)); // Divisi\u00f3n por cero\n</code></pre> <p>Explicaci\u00f3n del ejemplo anterior:</p> <ol> <li>En el bloque <code>try</code>, se verifica si el divisor (<code>b</code>) es igual a <code>0</code> y se lanza un error en ese caso.</li> <li>Si ocurre un error, el bloque <code>catch</code> captura el mensaje y devuelve <code>null</code>.</li> <li>El bloque <code>finally</code> siempre registra el intento de divisi\u00f3n, incluso si ocurri\u00f3 un error.</li> </ol> <p>Esta implementaci\u00f3n combina la validaci\u00f3n de datos con un manejo de errores claro y un registro confiable, asegurando que el programa se mantenga robusto y f\u00e1cil de depurar.</p>"},{"location":"javascript/try-catch-finally/#interacciones-especiales-con-return","title":"Interacciones especiales con return","text":"<p>Cuando se usan declaraciones return en los bloques <code>try</code>, <code>catch</code> y <code>finally</code>, el bloque <code>finally</code> puede sobrescribir el valor de retorno.</p> javascript<pre><code>function fn() {\n    try {\n        return 1;\n    } catch {\n        return 2;\n    } finally {\n        return 3;\n    }\n}\n\nconsole.log(\"Resultado de fn():\", fn());\n</code></pre> <p>Explicaci\u00f3n del ejemplo</p> <ol> <li>El bloque <code>try</code> intenta devolver <code>1</code>.</li> <li>El bloque <code>finally</code> sobrescribe el valor de retorno con <code>3</code>, porque siempre se ejecuta despu\u00e9s de <code>try</code> y <code>catch</code>.</li> <li>El valor devuelto por la funci\u00f3n es <code>3</code>.</li> </ol> <p>Este comportamiento es \u00fatil para garantizar que ciertas tareas cr\u00edticas siempre se ejecuten, pero debe usarse con precauci\u00f3n para evitar confusiones.</p>"},{"location":"javascript/try-catch-finally/#buenas-practicas-al-usar-try-catch-finally","title":"Buenas pr\u00e1cticas al usar try catch finally","text":"<ol> <li>Usa <code>finally</code> para limpiar recursos: Libera memoria, cierra archivos abiertos o det\u00e9n procesos en ejecuci\u00f3n.</li> <li>Evita l\u00f3gica innecesaria en <code>finally</code>: Mant\u00e9n este bloque breve y enfocado en tareas esenciales.</li> <li>Ten cuidado con <code>return</code> en <code>finally</code>: Recuerda que puede sobrescribir valores de retorno del bloque <code>try</code> o <code>catch</code>.</li> <li>No abuses del bloque <code>finally</code>: No lo uses para manejar errores; su prop\u00f3sito principal es asegurar la ejecuci\u00f3n de c\u00f3digo final.</li> </ol>"},{"location":"javascript/try-catch-finally/#conclusion","title":"Conclusi\u00f3n","text":"<p>El bloque <code>try...catch...finally</code> en JavaScript ofrece una soluci\u00f3n completa para manejar errores y garantizar la ejecuci\u00f3n de tareas cr\u00edticas. Ya sea que necesites liberar recursos, registrar eventos o restablecer estados, <code>finally</code> asegura que tu c\u00f3digo siempre se ejecute, independientemente de si hubo un error.</p> <p>En el siguiente art\u00edculo exploraremos c\u00f3mo usar <code>throw</code> para lanzar excepciones personalizadas en JavaScript.</p> <p></p>"},{"location":"javascript/try-catch/","title":"try catch","text":""},{"location":"javascript/try-catch/#try-catch","title":"try catch","text":"<p>El manejo de errores en JavaScript es importante al momento de construir aplicaciones confiables y robustas. La instrucci\u00f3n try catch permite ejecutar bloques de c\u00f3digo que podr\u00edan generar errores y manejar dichos errores de manera controlada. Esto no solo previene bloqueos inesperados en tu programa, sino que tambi\u00e9n asegura una experiencia m\u00e1s fluida para el usuario.</p> <p>En este art\u00edculo exploraremos c\u00f3mo funciona <code>try...catch</code>, con ejemplos y explicaciones para que entiendas su funcionamiento.</p>"},{"location":"javascript/try-catch/#que-es-try-catch","title":"\u00bfQu\u00e9 es try catch?","text":"<p><code>try...catch</code> es una estructura de control que te permite identificar errores en tiempo de ejecuci\u00f3n y manejarlos sin detener la ejecuci\u00f3n del programa. Si ocurre un error en el bloque <code>try</code>, el control pasa al bloque <code>catch</code>, donde puedes capturar el error y decidir c\u00f3mo manejarlo.</p> <p>Sintaxis b\u00e1sica</p> javascript<pre><code>try {\n    // C\u00f3digo que podr\u00eda generar un error\n} catch (error) {\n    // C\u00f3digo para manejar el error\n}\n</code></pre> <p>El bloque <code>try</code> contiene el c\u00f3digo que deseas ejecutar. Si se genera un error, el control pasa al bloque <code>catch</code>, donde el objeto <code>error</code> proporciona detalles sobre lo que ocurri\u00f3.</p>"},{"location":"javascript/try-catch/#ejemplo-basico-llamada-a-una-funcion-inexistente","title":"Ejemplo b\u00e1sico: Llamada a una funci\u00f3n inexistente","text":"javascript<pre><code>try {\n    let resultado = suma(10, 20); // La funci\u00f3n `suma` no est\u00e1 definida\n    console.log(\"Resultado:\", resultado);\n} catch (error) {\n    console.log(\"Error capturado:\");\n    console.log(\"Nombre del error:\", error.name);\n    console.log(\"Mensaje del error:\", error.message);\n}\n\nconsole.log(\"El programa contin\u00faa ejecut\u00e1ndose.\");\n</code></pre> <p>En este caso, intentamos ejecutar una funci\u00f3n llamada <code>suma</code> que no est\u00e1 definida. Esto genera un error de tipo <code>ReferenceError</code>. Sin <code>try catch</code>, el programa se detendr\u00eda abruptamente, pero gracias a la estructura:</p> <ol> <li>El bloque <code>try</code> intenta ejecutar la operaci\u00f3n y encuentra el error.</li> <li>El control pasa al bloque <code>catch</code>, donde capturamos el error y mostramos detalles relevantes (<code>name</code> y <code>message</code>) usando <code>console.log</code>.</li> <li>Finalmente, el mensaje \u201cEl programa contin\u00faa ejecut\u00e1ndose\u201d demuestra que el programa no se interrumpi\u00f3 y puede seguir funcionando normalmente.</li> </ol>"},{"location":"javascript/try-catch/#como-usar-try-catch-para-validar-datos","title":"C\u00f3mo usar try catch para validar datos","text":"<p>Uno de los casos m\u00e1s comunes para <code>try...catch</code> es validar datos que podr\u00edan ser incorrectos o estar mal formateados. Por ejemplo, al analizar cadenas JSON, un formato inv\u00e1lido generar\u00e1 un error.</p> javascript<pre><code>try {\n    let datos = JSON.parse('{\"nombre\": \"JavaScript\"}'); // JSON v\u00e1lido\n    console.log(\"Datos analizados:\", datos);\n} catch (error) {\n    console.log(\"Error al analizar JSON:\", error.message);\n}\n</code></pre> <p>En el c\u00f3digo anterior la cadena JSON es v\u00e1lida, por lo que el bloque <code>try</code> se ejecuta sin problemas, y el resultado del an\u00e1lisis se muestra en consola. Si la cadena JSON hubiera sido inv\u00e1lida, el bloque <code>catch</code> manejar\u00eda el error generado por <code>JSON.parse</code>.</p> <p>Este patr\u00f3n es \u00fatil para prevenir errores en datos externos o de usuarios que podr\u00edan romper tu programa si no se validan correctamente.</p>"},{"location":"javascript/try-catch/#ejemplo-manejo-de-entradas-no-validas","title":"Ejemplo: Manejo de entradas no v\u00e1lidas","text":"<p>Cuando se trabaja con funciones que procesan datos din\u00e1micos, como entradas de usuarios o c\u00e1lculos matem\u00e1ticos, es importante validar esos datos antes de realizar cualquier operaci\u00f3n. En el siguiente ejemplo veremos c\u00f3mo usar try catch para manejar entradas no v\u00e1lidas y lanzar errores personalizados que describan exactamente lo que sali\u00f3 mal.</p> javascript<pre><code>function dividir(a, b) {\n    if (b === 0) {\n        throw new Error(\"No se puede dividir por cero.\");\n    }\n    return a / b;\n}\n\ntry {\n    console.log(\"Resultado:\", dividir(10, 0));\n} catch (error) {\n    console.log(\"Error capturado:\", error.message);\n}\n</code></pre> <p>En el c\u00f3digo anterior:</p> <ol> <li>Creamos una funci\u00f3n llamada <code>dividir</code> que lanza un error con <code>throw</code> si el divisor (<code>b</code>) es igual a cero.</li> <li>En el bloque <code>try</code>, llamamos a <code>dividir</code> con <code>b = 0</code>, lo que genera un error personalizado.</li> <li>El bloque <code>catch</code> captura el error y muestra su mensaje.</li> </ol> <p>El uso de <code>throw</code> permite lanzar errores personalizados, proporcionando descripciones claras para situaciones espec\u00edficas. Este enfoque es ideal para validar datos de entrada y evitar c\u00e1lculos matem\u00e1ticos err\u00f3neos.</p>"},{"location":"javascript/try-catch/#buenas-practicas-al-usar-try-catch","title":"Buenas pr\u00e1cticas al usar try catch","text":"<ol> <li>Coloca solo el c\u00f3digo propenso a errores en el bloque try: Evita envolver bloques grandes de c\u00f3digo innecesariamente, ya que dificulta el manejo espec\u00edfico de errores.</li> </ol> javascript<pre><code>try {\n     datos = JSON.parse(cadenaInvalida);\n} catch (error) {\n    console.error(\"Error al analizar JSON:\", error.message);\n}\n</code></pre> <ol> <li> <p>Proporciona mensajes significativos: Al manejar errores, aseg\u00farate de ofrecer informaci\u00f3n clara sobre lo que sali\u00f3 mal.</p> </li> <li> <p>Evita depender de <code>try catch</code> para l\u00f3gica normal: No uses <code>try...catch</code> como una soluci\u00f3n predeterminada para el flujo l\u00f3gico. Dise\u00f1a tu c\u00f3digo para prevenir errores siempre que sea posible.</p> </li> </ol>"},{"location":"javascript/try-catch/#errores-comunes-al-usar-trycatch","title":"Errores comunes al usar try\u2026catch","text":"<ol> <li>Capturar errores irrelevantes: Si el bloque <code>try</code> es demasiado amplio, puedes terminar manejando errores que no est\u00e1n relacionados con el prop\u00f3sito de tu c\u00f3digo.</li> <li>Ignorar el objeto <code>error</code>: No usar el objeto <code>error</code> en el bloque <code>catch</code> desperdicia informaci\u00f3n valiosa sobre lo que ocurri\u00f3.</li> <li>Falta de validaci\u00f3n previa: Muchas veces los errores pueden evitarse validando las entradas o usando estructuras condicionales antes de llegar al bloque <code>try</code>.</li> </ol>"},{"location":"javascript/try-catch/#conclusion","title":"Conclusi\u00f3n","text":"<p>La instrucci\u00f3n <code>try...catch</code> en JavaScript es una herramienta indispensable para manejar errores y garantizar la estabilidad de tus aplicaciones. Al capturar y gestionar excepciones, puedes evitar bloqueos inesperados y mejorar la experiencia del usuario. Sin embargo, es importante usar <code>try...catch</code> de manera estrat\u00e9gica, asegur\u00e1ndote de seguir las buenas pr\u00e1cticas para mantener un c\u00f3digo limpio y manejable.</p> <p>En el siguiente art\u00edculo exploraremos try\u2026catch\u2026finally, una extensi\u00f3n de esta estructura que permite realizar tareas finales independientemente de si ocurri\u00f3 un error o no.</p> <p></p>"},{"location":"javascript/valores-primitivos-vs-referencia/","title":"Valores Primitivos vs. Valores de Referencia","text":""},{"location":"javascript/valores-primitivos-vs-referencia/#valores-primitivos-vs-valores-de-referencia","title":"Valores Primitivos vs. Valores de Referencia","text":"<p>En JavaScript existen dos tipos principales de valores: valores primitivos y valores de referencia. La forma en que se almacenan y manejan en la memoria es distinta para cada tipo, lo que afecta c\u00f3mo funcionan la asignaci\u00f3n, la comparaci\u00f3n y la manipulaci\u00f3n de estos valores.</p> <p>En este art\u00edculo aprender\u00e1s las diferencias entre los valores primitivos y los valores de referencia, as\u00ed el c\u00f3mo se almacenan en la memoria, el uso de la pila (stack) y el mont\u00f3n (heap), ademas de buenas pr\u00e1cticas al trabajar con ellos.</p>"},{"location":"javascript/valores-primitivos-vs-referencia/#tipos-de-valores-en-javascript","title":"Tipos de Valores en JavaScript","text":"<p>JavaScript tiene dos tipos diferentes de valores:</p>"},{"location":"javascript/valores-primitivos-vs-referencia/#1-valores-primitivos","title":"1. Valores Primitivos:","text":"<p>Los valores primitivos son los tipos de datos m\u00e1s b\u00e1sicos y simples en JavaScript. Son inmutables, lo que significa que no pueden ser modificados una vez creados. En lugar de modificar el valor, JavaScript crea un nuevo valor cuando se realiza una operaci\u00f3n sobre un valor primitivo.</p> <ul> <li><code>number</code>: Representa valores num\u00e9ricos, tanto enteros como decimales.</li> <li><code>string</code>: Cadenas de texto.</li> <li><code>boolean</code>: Valores l\u00f3gicos <code>true</code> o <code>false</code>.</li> <li><code>undefined</code>: Indica que una variable ha sido declarada pero no inicializada.</li> <li><code>null</code>: Representa la ausencia intencional de un valor.</li> <li><code>symbol</code>: Identificadores \u00fanicos introducidos en ES6.</li> <li><code>bigint</code>: Para representar n\u00fameros enteros muy grandes, a partir de ES2020.</li> </ul>"},{"location":"javascript/valores-primitivos-vs-referencia/#2-valores-de-referencia","title":"2. Valores de Referencia:","text":"<p>Los valores de referencia son estructuras de datos complejas que no almacenan los valores directamente, sino una referencia a la ubicaci\u00f3n en memoria donde se encuentran. Esto significa que cuando se asigna un valor de referencia a una variable, se copia la referencia y no el valor en s\u00ed.</p> <ul> <li>Objetos: Colecci\u00f3n de pares clave-valor.</li> <li>Arrays: Listas ordenadas de elementos, que son un tipo especial de objeto.</li> <li>Funciones: Objetos invocables que pueden contener l\u00f3gica de programaci\u00f3n.</li> <li>Fechas (<code>Date</code>), Expresiones regulares (<code>RegExp</code>), entre otros.</li> </ul>"},{"location":"javascript/valores-primitivos-vs-referencia/#como-se-almacenan-en-memoria-referencia-vs-copia","title":"\u00bfC\u00f3mo se Almacenan en Memoria? (Referencia vs. Copia)","text":"<p>La forma en que se almacenan los valores en la memoria depende de si son valores primitivos o de referencia. Esta diferencia es clave para entender c\u00f3mo se comportan en operaciones de asignaci\u00f3n y comparaci\u00f3n.</p>"},{"location":"javascript/valores-primitivos-vs-referencia/#1-valores-primitivos-almacenamiento-por-copia","title":"1. Valores Primitivos: Almacenamiento por Copia","text":"<p>Los valores primitivos se almacenan directamente en la memoria de pila (stack). Cuando se asigna un valor primitivo a una variable se almacena una copia del valor en la memoria. Por lo tanto, modificar el valor de una variable no afecta a otras variables que contengan el mismo valor.</p> javascript<pre><code>let a = 10;\nlet b = a;  // b es una copia de a\nb = 20;\n\nconsole.log(a);\nconsole.log(b);\n</code></pre> <p>En el anterior c\u00f3digo <code>a</code> y <code>b</code> son independientes porque almacenan copias separadas del valor.</p>"},{"location":"javascript/valores-primitivos-vs-referencia/#2-valores-de-referencia-almacenamiento-por-referencia","title":"2. Valores de Referencia: Almacenamiento por Referencia","text":"<p>Los valores de referencia se almacenan en la memoria de mont\u00f3n (heap), y la variable contiene una referencia (puntero) a la ubicaci\u00f3n del objeto en la memoria. Cuando se asigna un valor de referencia a otra variable se copia la referencia, no el objeto en s\u00ed. Esto significa que cualquier cambio en el objeto afectar\u00e1 a todas las variables que apuntan a ese mismo objeto.</p> javascript<pre><code>const objeto1 = { nombre: \"Ana\" };\nconst objeto2 = objeto1;  // objeto2 apunta al mismo objeto en el heap\n\nobjeto2.nombre = \"Mar\u00eda\";\n\nconsole.log(objeto1.nombre);\n</code></pre> <p>En este caso, tanto <code>objeto1</code> como <code>objeto2</code> apuntan al mismo objeto en la memoria, por lo que los cambios realizados a trav\u00e9s de cualquiera de las variables son visibles desde ambas.</p>"},{"location":"javascript/valores-primitivos-vs-referencia/#memoria-de-pila-y-monton-stack-heap","title":"Memoria de pila y mont\u00f3n (Stack &amp; heap)","text":"<p>La memoria en JavaScript se divide en dos \u00e1reas principales: la pila (stack) y el mont\u00f3n (heap), que tienen diferentes prop\u00f3sitos y caracter\u00edsticas.</p>"},{"location":"javascript/valores-primitivos-vs-referencia/#1-memoria-de-pila-stack","title":"1. Memoria de Pila (Stack)","text":"<p>La pila es una regi\u00f3n de la memoria que se usa para almacenar valores primitivos y para gestionar el contexto de ejecuci\u00f3n de funciones. Cada vez que se declara una variable con un valor primitivo se asigna en la pila, lo que permite un acceso r\u00e1pido y eficiente.</p> <ul> <li>Almacenamiento por valor: Cada valor se almacena directamente.</li> <li>Acceso r\u00e1pido: El acceso a los datos en la pila es muy r\u00e1pido debido a la forma en que la memoria se organiza.</li> <li>Vida corta: Los datos almacenados en la pila son de vida corta y se eliminan cuando se sale del \u00e1mbito de ejecuci\u00f3n.</li> </ul>"},{"location":"javascript/valores-primitivos-vs-referencia/#2-memoria-de-monton-heap","title":"2. Memoria de Mont\u00f3n (Heap)","text":"<p>El mont\u00f3n es una regi\u00f3n de la memoria utilizada para almacenar valores de referencia, como objetos y arrays. Es un \u00e1rea menos estructurada que la pila, lo que permite almacenar grandes cantidades de datos din\u00e1micos.</p> <ul> <li>Almacenamiento por referencia: Los valores no se almacenan directamente; en su lugar, se almacena una referencia a su ubicaci\u00f3n en el mont\u00f3n.</li> <li>Mayor complejidad de acceso: El acceso a los datos en el mont\u00f3n es m\u00e1s lento que en la pila debido a su estructura menos organizada.</li> <li>Vida larga: Los datos en el mont\u00f3n pueden persistir durante m\u00e1s tiempo y solo se eliminan cuando ya no son referenciados (recolecci\u00f3n de basura).</li> </ul>"},{"location":"javascript/valores-primitivos-vs-referencia/#propiedades-dinamicas","title":"Propiedades din\u00e1micas","text":"<p>Un valor de referencia en JavaScript permite la manipulaci\u00f3n din\u00e1mica de sus propiedades, lo que implica la capacidad de agregar, cambiar o eliminar propiedades en cualquier momento. Por ejemplo, en un objeto podemos a\u00f1adir nuevas propiedades, modificar las existentes o eliminarlas seg\u00fan sea necesario:</p> javascript<pre><code>let person = {\n  name: 'John',\n  age: 25,\n};\n\n// Agregar una nueva propiedad\nperson.city = 'Madrid';\n\n// Modificar una propiedad existente\nperson.age = 31;\n\n// Eliminar una propiedad\ndelete person.age;\n</code></pre> <p>Por otro lado, los valores primitivos no admiten la adici\u00f3n de propiedades ya que no son objetos y por lo tanto no tienen m\u00e9todos o propiedades propias que puedan ser modificadas din\u00e1micamente. Intentar agregar una propiedad a un valor primitivo no tendr\u00e1 efecto alguno:</p> javascript<pre><code>let name = 'Juan';\n// Intentar agregar una propiedad a un valor primitivo\nname.city = 'Madrid';\n\nconsole.log(name.city);\n</code></pre> <p>Aunque no se producir\u00e1 ning\u00fan error, la propiedad no se agregar\u00e1 al valor primitivo. Esto se debe a que JavaScript convierte temporalmente el valor primitivo en un objeto durante la operaci\u00f3n, pero luego lo descarta, dejando el valor primitivo original sin cambios.</p>"},{"location":"javascript/valores-primitivos-vs-referencia/#copiar-valores-de-variables-primitivas","title":"Copiar valores de variables primitivas","text":"<p>Cuando copias un valor primitivo de una variable a otra en JavaScript, el motor crea una copia independiente de ese valor y lo asigna a la nueva variable. Esto significa que los cambios en una variable no afectar\u00e1n a la otra.</p> javascript<pre><code>let num1 = 10;\nlet num2 = num1; // Se copia el valor de num1 en num2\n\nnum1 = 20; // Cambiamos el valor de num1\n\nconsole.log(num1);\nconsole.log(num2);\n</code></pre> <p>En el anterior ejemplo inicializamos <code>num1</code> con el valor <code>10</code>. Luego, copiamos este valor en <code>num2</code>. Despu\u00e9s, modificamos el valor de <code>num1</code> a <code>20</code>, pero <code>num2</code> sigue manteniendo su valor original de <code>10</code>, ya que es una copia independiente del valor de <code>num1</code>.</p>"},{"location":"javascript/valores-primitivos-vs-referencia/#copiar-referencias-de-variables-de-objetos","title":"Copiar referencias de variables de objetos","text":"<p>Cuando asignas un valor de referencia de una variable a otra en JavaScript, el motor crea una referencia que apunta al mismo objeto en la memoria del mont\u00f3n para ambas variables. Esto implica que cualquier cambio realizado en una de las variables se reflejar\u00e1 en la otra.</p> javascript<pre><code>let obj1 = { name: 'John' };\nlet obj2 = obj1; // Se crea una referencia a obj1 en obj2\n\nobj1.name = 'Alice'; // Cambiamos el nombre en obj1\n\nconsole.log(obj1.name);\nconsole.log(obj2.name);\n</code></pre> <p>En este ejemplo, <code>obj1</code> y <code>obj2</code> hacen referencia al mismo objeto en la memoria del mont\u00f3n. Por lo tanto, cuando cambiamos el nombre en <code>obj1</code>, este cambio tambi\u00e9n se refleja en <code>obj2</code>, ya que ambas variables apuntan al mismo objeto.</p>"},{"location":"javascript/valores-primitivos-vs-referencia/#conclusion","title":"Conclusi\u00f3n","text":"<p>Comprender la diferencia entre valores primitivos y de referencia en JavaScript es importante para trabajar eficientemente con el lenguaje. Saber c\u00f3mo se almacenan en la memoria y las implicaciones de la pila y el mont\u00f3n te ayudar\u00e1 a escribir c\u00f3digo m\u00e1s seguro y evitar errores comunes relacionados con la mutabilidad y la manipulaci\u00f3n de datos.</p> <p></p>"},{"location":"javascript/var-let/","title":"Diferencias entre var, let y const","text":""},{"location":"javascript/var-let/#variables-diferencias-entre-var-let-y-const","title":"Variables: Diferencias entre var, let y const","text":"<p>En JavaScript existen tres formas principales de declarar variables: <code>var</code>, <code>let</code> y <code>const</code>. Cada una tiene caracter\u00edsticas espec\u00edficas que las hacen adecuadas para diferentes situaciones. Comprender las diferencias entre ellas es importante para escribir c\u00f3digo predecible y evitar errores comunes.</p> <p>En este art\u00edculo exploraremos las particularidades de cada tipo de declaraci\u00f3n, sus \u00e1mbitos, el comportamiento en la elevaci\u00f3n (hoisting), la zona muerta temporal y otros detalles clave.</p>"},{"location":"javascript/var-let/#el-ambitos-de-las-variables","title":"El \u00c1mbitos de las Variables","text":"<p>El concepto de \u00e1mbito de variable hace referencia a la regi\u00f3n del c\u00f3digo donde esta es v\u00e1lida y accesible. En JavaScript la palabra clave <code>var</code> tiene un \u00e1mbito global o de funci\u00f3n, lo que significa que las variables declaradas con esta keyword pueden ser accedidas o modificadas desde fuera de un bloque espec\u00edfico.</p> <p>Si declaramos una variable con <code>var</code> fuera de una funci\u00f3n, esta se convierte en una variable global y puede ser accedida desde cualquier parte del c\u00f3digo:</p> javascript<pre><code>var age = 30;\n\nfunction printAge() {\n  console.log(age);\n}\n\nprintAge();\n</code></pre> <p>Cuando una variable se declara dentro de una funci\u00f3n utilizando var, su alcance se limita al contexto de esa funci\u00f3n, lo que significa que no puede ser accedida desde fuera de la funci\u00f3n. Por ejemplo:</p> javascript<pre><code>function greet() {\n  var message = \"\u00a1Hola!\";\n  console.log(message);\n}\n\ngreet();\nconsole.log(message);\n</code></pre> <p>Ahora, ya que tenemos el concepto del \u00e1mbito veamos que ofrece cada declaraci\u00f3n que utilizamos para definir variables.</p>"},{"location":"javascript/var-let/#la-forma-tradicional-de-declarar-variables-var","title":"La Forma Tradicional de Declarar Variables: <code>var</code>","text":"<p><code>var</code> fue la \u00fanica manera de declarar variables en JavaScript hasta la introducci\u00f3n de ES6. Aunque sigue siendo v\u00e1lida, esta presenta varias peculiaridades que pueden llevar a errores dif\u00edciles de rastrear. Veamos las principales:</p> <ul> <li>\u00c1mbito global o de funci\u00f3n: Las variables declaradas con <code>var</code> tienen un \u00e1mbito que se limita a la funci\u00f3n en la que se declaran o son globales si se declaran fuera de cualquier funci\u00f3n.</li> <li>Permite la redeclaraci\u00f3n: Es posible declarar la misma variable varias veces en el mismo \u00e1mbito, lo que puede generar confusi\u00f3n.</li> <li>Hoisting: Las variables declaradas con <code>var</code> se elevan al principio del contexto de ejecuci\u00f3n, con un valor inicial de <code>undefined</code>.</li> </ul> <p>Ejemplo de \u00e1mbito y hoisting con <code>var</code>:</p> javascript<pre><code>console.log(mensaje);\n\nvar mensaje = \"Hola, mundo\";\n\nfunction saludo() {\n  var mensajeInterno = \"Hola desde la funci\u00f3n\";\n  console.log(mensajeInterno);\n}\nsaludo();\n</code></pre> <p>En el ejemplo anterior la variable <code>mensaje</code> se eleva y tiene un valor <code>undefined</code> antes de ser asignada, lo que muestra la naturaleza del hoisting en <code>var</code>.</p>"},{"location":"javascript/var-let/#problema-de-la-creacion-de-propiedades-globales","title":"Problema de la Creaci\u00f3n de Propiedades Globales","text":"<p>Las variables globales definidas con <code>var</code> se agregan al objeto global como propiedades adicionales. Esto puede aumentar las posibilidades de conflictos con otras bibliotecas o scripts que tambi\u00e9n utilizan el objeto global para sus propias variables.</p> <p> En el navegador web, el objeto global es window, mientras que en Node.js es global.</p> <p></p>"},{"location":"javascript/var-let/#la-alternativa-moderna-let","title":"La Alternativa Moderna: <code>let</code>","text":"<p><code>let</code> es una mejora significativa introducida en ES6 para declarar variables de manera m\u00e1s segura. Su \u00e1mbito est\u00e1 limitado al bloque en el que se declara, lo que evita problemas comunes asociados con el uso de <code>var</code>.</p> <p>Caracter\u00edsticas de <code>let</code>:</p> <ul> <li>\u00c1mbito de bloque: Las variables declaradas con <code>let</code> solo son accesibles dentro del bloque en el que se declaran.</li> <li>No permite la redeclaraci\u00f3n en el mismo \u00e1mbito: Esto ayuda a evitar errores accidentales.</li> <li>Hoisting con inicializaci\u00f3n diferida: Aunque <code>let</code> se eleva, no se puede acceder a la variable antes de su declaraci\u00f3n debido a la \u201czona muerta temporal\u201d.</li> </ul>"},{"location":"javascript/var-let/#la-zona-muerta-temporal","title":"La Zona Muerta Temporal","text":"<p>La zona muerta temporal es el per\u00edodo entre el inicio del bloque y la declaraci\u00f3n de la variable <code>let</code>, durante el cual no se puede acceder a la variable. Intentar hacerlo generar\u00e1 un <code>ReferenceError</code>.</p> javascript<pre><code>{\n    console.log(nombre);\n    let nombre = \"Carlos\";\n}\n</code></pre> <p>En el ejemplo anterior <code>nombre</code> est\u00e1 en la zona muerta temporal hasta que se alcanza la declaraci\u00f3n.</p>"},{"location":"javascript/var-let/#declaracion-para-constantes-const","title":"Declaraci\u00f3n para Constantes: <code>const</code>","text":"<p><code>const</code> se utiliza para declarar constantes, es decir, \u201cvariables porque almacena un dato\u201d cuyo valor no puede cambiar una vez asignado. Sin embargo, si el valor es un objeto o un array sus propiedades o elementos pueden ser modificados.</p> <p>Caracter\u00edsticas de <code>const</code>:</p> <ul> <li>Debe ser inicializada al momento de la declaraci\u00f3n.</li> <li>No permite la reasignaci\u00f3n: Una vez asignado, el valor de una variable <code>const</code> no puede cambiar.</li> <li>\u00c1mbito de bloque: Al igual que <code>let</code>, las variables <code>const</code> solo est\u00e1n disponibles dentro del bloque en el que se declaran.</li> </ul> <p>Ejemplo de modificaci\u00f3n de un objeto constante:</p> javascript<pre><code>const usuario = { nombre: \"Ana\", edad: 30 };\nusuario.edad = 31;  // Esto es v\u00e1lido, ya que se modifica una propiedad, no la referencia\n\nconsole.log(usuario.edad);\n</code></pre>"},{"location":"javascript/var-let/#buenas-practicas-para-usar-var-let-y-const","title":"Buenas Pr\u00e1cticas para Usar <code>var</code>, <code>let</code> y <code>const</code>","text":"<ol> <li>Usar <code>const</code> de forma predeterminada: Siempre que el valor de una variable no cambie usa <code>const</code> para asegurar la inmutabilidad.</li> <li>Optar por <code>let</code> si necesitas cambiar el valor: Si el valor de la variable debe cambiar, usa <code>let</code>.</li> <li>Evitar <code>var</code>: Los problemas de alcance y hoisting hacen que <code>var</code> no sea la mejor opci\u00f3n en la mayor\u00eda de los casos.</li> </ol>"},{"location":"javascript/var-let/#conclusion","title":"Conclusi\u00f3n","text":"<p>Comprender las diferencias entre <code>var</code>, <code>let</code> y <code>const</code> es \u00fatil para escribir c\u00f3digo limpio y seguro en JavaScript. Utilizar la opci\u00f3n adecuada en cada situaci\u00f3n ayuda a evitar errores comunes y mejora la calidad del c\u00f3digo.</p> <p>En el pr\u00f3ximo art\u00edculo nos adentraremos en los tipos de datos en JavaScript, explorando cada uno en detalle.</p> <p></p>"},{"location":"javascript/variables/","title":"Variables","text":""},{"location":"javascript/variables/#variables","title":"Variables","text":"<p>Las variables son componentes importantes en JavaScript, ya que permiten almacenar y gestionar datos de manera eficiente. Al aprender a trabajar con variables se facilita el desarrollo de aplicaciones din\u00e1micas y funcionales. En este art\u00edculo exploraremos el trabajo de variables con JavaScript, el c\u00f3mo declararlas, asignarles valores y usarlas adecuadamente en el contexto de JavaScript.</p>"},{"location":"javascript/variables/#que-son-las-variables","title":"\u00bfQu\u00e9 son las Variables?","text":"<p>Las variables son contenedores que almacenan informaci\u00f3n que puede ser utilizada y modificada durante la ejecuci\u00f3n de un programa. Act\u00faan como etiquetas que hacen referencia a un valor, permitiendo que el c\u00f3digo sea m\u00e1s din\u00e1mico y f\u00e1cil de entender.</p> <p>En JavaScript, existen tres palabras clave principales para declarar variables: <code>var</code>, <code>let</code> y <code>const</code>. Cada una con caracter\u00edsticas espec\u00edficas que se utilizan en diferentes escenarios.</p>"},{"location":"javascript/variables/#declaracion-de-variables","title":"Declaraci\u00f3n de Variables","text":"<p>Antes de poder utilizar una variable es necesario declararla. A partir de ES6 se introdujeron las palabras clave <code>let</code> y <code>const</code> para mejorar el manejo de variables en comparaci\u00f3n con <code>var</code>.</p>"},{"location":"javascript/variables/#palabras-clave-para-declarar-variables","title":"Palabras Clave para Declarar Variables","text":"<ol> <li>La sentencia <code>var</code>: Se utiliza para declarar e inicializar variables con acceso en todo el programa. Estas pueden cambiar su valor y se elevan al inicio del programa.</li> <li>La sentencia <code>let</code>: Declaran variables accesibles solo dentro de su \u00e1mbito, como en funciones. Estas no se elevan al inicio del programa.</li> <li>La sentencia <code>const</code>: Se utiliza para declarar constantes cuyo valor no puede modificarse. Al igual que las variables let las constantes no se elevan al inicio del programa.</li> </ol> <p>Ejemplos de Declaraci\u00f3n:</p> javascript<pre><code>let nombre = \"Carlos\";\nconst edad = 30;\nvar pais = \"Espa\u00f1a\";\n</code></pre> <p>En este ejemplo <code>nombre</code> se declara con <code>let</code> para que su valor pueda cambiar, <code>edad</code> con <code>const</code> para mantenerla inmutable, y <code>pais</code> con <code>var</code>, aunque se recomienda el uso de <code>let</code> o <code>const</code>.</p>"},{"location":"javascript/variables/#nombres-de-variables-o-identificadores","title":"Nombres de Variables o Identificadores","text":"<p>Los identificadores son los nombres que asignamos a las variables y estas deben seguir ciertas reglas para ser v\u00e1lidos en JavaScript:</p> <ul> <li>Deben comenzar con una letra, guion bajo (<code>_</code>) o signo de d\u00f3lar (<code>$</code>), no con un n\u00famero.</li> <li>Pueden contener letras, n\u00fameros, guiones bajos o s\u00edmbolos de d\u00f3lar.</li> <li>Son sensibles a may\u00fasculas y min\u00fasculas (<code>variable</code> y <code>Variable</code> son diferentes).</li> <li>No deben coincidir con palabras reservadas del lenguaje, como <code>function</code> o <code>return</code>.</li> </ul>"},{"location":"javascript/variables/#buenas-practicas-al-nombrar-variables","title":"Buenas Pr\u00e1cticas al Nombrar Variables","text":"<ol> <li>Usar camelCase: Esto indica el comenzar con min\u00fascula y cada nueva palabra con may\u00fascula (<code>miVariableImportante</code>).</li> <li>Elegir nombres descriptivos: Evitar nombres gen\u00e9ricos como <code>x</code> o <code>data</code> a menos que el contexto sea claro.</li> </ol> <p> JavaScript es un lenguaje escrito din\u00e1micamente. Esto significa que no es necesario especificar el tipo de variable en la declaraci\u00f3n como otros lenguajes de tipo est\u00e1tico como Java o C#</p> <p></p> <p>Al nombrar constantes y variables es fundamental elegir nombres descriptivos que reflejen claramente su prop\u00f3sito y funci\u00f3n en el c\u00f3digo. Esto ayuda a mejorar la legibilidad y comprensi\u00f3n del c\u00f3digo tanto para ti como para otros desarrolladores que puedan trabajar con \u00e9l en el futuro.</p>"},{"location":"javascript/variables/#inicializacion-de-variables","title":"Inicializaci\u00f3n de Variables","text":"<p>La inicializaci\u00f3n de una variable consiste en asignarle un valor en el momento de su declaraci\u00f3n. Si una variable se declara sin inicializar su valor es <code>undefined</code>.</p> <p>Una vez que has declarado una variable o una constante puedes inicializarla asign\u00e1ndole un valor. Esto se logra mediante el operador de asignaci\u00f3n (<code>=</code>), seguido del nombre y el valor que deseas asignarle.</p> <p>Ejemplo de inicializaci\u00f3n:</p> javascript<pre><code>let saludo;\nconsole.log(saludo);\n\nsaludo = \"Hola, mundo\";\nconsole.log(saludo);\n</code></pre> <p>En este caso la variable <code>saludo</code> se declara pero no se inicializa hasta la segunda l\u00ednea, donde se le asigna un valor.</p> <p>Incluso podemos declarar y asignar m\u00faltiples variables al mismo tiempo, para esto separamos cada declaraci\u00f3n con una coma (<code>,</code>).</p> javascript<pre><code>let saludo = \"Hola\",\n    usuario = \"Pedro\",\n    estatus = true;\n</code></pre>"},{"location":"javascript/variables/#cambiar-el-valor-de-una-variable","title":"Cambiar el Valor de una Variable","text":"<p>Las variables declaradas con <code>let</code> o <code>var</code> pueden cambiar su valor durante la ejecuci\u00f3n del programa. Sin embargo, las declaradas con <code>const</code> no pueden ser reasignadas.</p> <p>Ejemplo: Cambio de Valor:</p> javascript<pre><code>let edad = 25;\nedad = 26;  // Cambio de valor\nconsole.log(edad);\n</code></pre>"},{"location":"javascript/variables/#diferencias-entre-variables-no-definidas-y-no-declaradas","title":"Diferencias Entre Variables no Definidas y no Declaradas","text":"<p>Es importante distinguir entre variables no definidas y no declaradas:</p> <ul> <li>Variable no definida: Ha sido declarada pero no se le ha asignado ning\u00fan valor, por lo que su valor es <code>undefined</code>.</li> <li>Variable no declarada: No ha sido definida en el c\u00f3digo, lo que provoca un error al intentar acceder a ella.</li> </ul> <p>Ejemplo: variable no definida vs. no declarada:</p> javascript<pre><code>let mensaje;\n\nconsole.log(mensaje);  // Output: undefined\nconsole.log(texto);  // Error: texto is not defined\n</code></pre>"},{"location":"javascript/variables/#variables-constantes-y-mutabilidad","title":"Variables Constantes y Mutabilidad","text":"<p>Las constantes declaradas con <code>const</code>, no permiten la reasignaci\u00f3n del valor una vez que ha sido definido. Sin embargo, si el valor es un objeto o un array sus propiedades o elementos internos pueden ser modificados.</p> <p>Ejemplo de constante mutable:</p> javascript<pre><code>const usuario = {\n  nombre: \"Ana\",\n  edad: 28\n};\n\nusuario.edad = 29;  // Esto es v\u00e1lido, ya que se modifica una propiedad, no la referencia\nconsole.log(usuario.edad);\n</code></pre>"},{"location":"javascript/variables/#conclusion","title":"Conclusi\u00f3n","text":"<p>Las variables en JavaScript son un componente esencial para gestionar datos en las aplicaciones. Comprender las diferencias entre <code>let</code>, <code>const</code> y <code>var</code>, as\u00ed como las pr\u00e1cticas recomendadas para nombrarlas e inicializarlas, las base para escribir un c\u00f3digo claro y eficiente.</p> <p>En el siguiente art\u00edculo abordaremos las diferencias espec\u00edficas entre <code>var</code>, <code>let</code> y <code>const</code>, profundizando en sus caracter\u00edsticas y mejores pr\u00e1cticas.</p> <p></p>"},{"location":"tutoriales/","title":"Tutoriales","text":"Tutoriales <p>PT Full Stack Development with JavaScript, Python, React</p> <p>\u00cdNDICE DE CONTENIDOS</p> <ol> <li>Ruta de aprendizaje:<ul> <li>Desarrollador Full Stack</li> </ul> </li> <li>Control de versiones:<ul> <li>Comandos GIT</li> </ul> </li> <li>Instalaci\u00f3n de librerias:<ul> <li>MkDocs + virtualenv</li> <li>Despliegue a GitHub Pages</li> </ul> </li> <li>Desarrollo web:<ul> <li>Optimizar el SEO</li> </ul> </li> </ol> <p> </p>"},{"location":"tutoriales/control-versiones/comandos-git/","title":"GIT desde la l\u00ednea de comandos","text":""},{"location":"tutoriales/control-versiones/comandos-git/#comandos-basicos-para-trabajar-en-localhost","title":"Comandos b\u00e1sicos para trabajar en localhost:","text":"<ul> <li>git init Iniciar GIT</li> <li>git add . Agrega todos los archivos al GIT</li> <li>git commit -m \"primer commit\" Agrega un commit al GIT</li> </ul>"},{"location":"tutoriales/control-versiones/comandos-git/#comandos-para-sincrinizar-por-primera-vez-git-con-github-desde-terminal-de-vscode","title":"Comandos para sincrinizar por primera vez GIT con GitHub desde terminal de VSCode:","text":"<ul> <li>git init Iniciar GIT</li> <li>git config --global user.name \"nombre_usuario\" Usuario de GitHub</li> <li>git config --global user.email \"micorreo@ejemplo.com\" Email de GitHub</li> </ul>"},{"location":"tutoriales/control-versiones/comandos-git/#comandos-basicos-para-subir-nuestro-proyecto-localhost-al-repositorio-de-github","title":"Comandos basicos para subir nuestro proyecto localhost al repositorio de GitHub:","text":"<ul> <li>git init Iniciar GIT</li> <li>git add . Agrega todos los archivos al GIT</li> <li>git commit -m \"primer commit\" Agrega un commit al GIT</li> <li>git branch -M main Fuerza a renombrar la rama local actual por (main) actual main</li> <li>git remote add origin https://github.com/usuario/mi_repositorio.git Crea una conexi\u00f3n remota llamada origin con el repositorio de GitHub</li> <li>git remote -v Verifica la comunicaci\u00f3n con el repositorio remoto</li> <li>git status Muestra el estado de los procesos GIT</li> <li>git push -u origin main Sube los archivos a la rama main remoto de GitHub</li> </ul>"},{"location":"tutoriales/control-versiones/comandos-git/#comandos-utiles","title":"Comandos \u00fatiles:","text":"<ul> <li>git status Muestra el estado de los procesos GIT</li> <li>git add ejemplo.html Agrega los archivos indibidualmente al GIT</li> <li>git remote -v Verifica la comunicaci\u00f3n con el repositorio remoto</li> <li>git log Muestra el hist\u00f3rico de commits</li> <li>git log -n 2 Muestra los \u00faltimos 2 commits</li> <li>git log prueba.html Muestra los commits del archivo (prueba.html)</li> <li>git switch main Cambia de la rama actual a la rama (main)</li> <li>git branch branch-test Crea una nueva rama (branch-test) a partir de la rama actual</li> <li>git branch -m branch-test Renombra la rama local actual por (branch-test) actual branch-test</li> <li>git branch -M branch-test Fuerza a renombrar la rama local actual por (branch-test) actual branch-test</li> <li>git branch Muestra todas las ramas locales y distingue con un (*) la rama actual</li> <li>git branch --list Muestra todas las ramas locales y distingue con un (*) la rama actual</li> <li>git branch -r Muestra todas las ramas del repositorio remoto</li> <li>git branch -a Muestra todas las ramas, tanto locales como remotas y distingue con un (*) la rama actual</li> <li>git branch --show-current Muestra la rama actual</li> <li>git branch -d branch-test Elimina la rama (branch-test) del repositorio local si esta fusionado con (main)</li> <li>git branch -D branch-test Fuerza a eliminar la rama (branch-test) del repositorio local este o no fusionado con (main)</li> <li>git branch --no-merged Muestra las ramas que estan sin fusionar con (main)</li> <li>git remote add origin https://github.com/usuario/mi_repositorio.git Crea una conexi\u00f3n remota llamada origin con el repositorio de GitHub</li> <li>git clone https://github.com/usuario/mi_repositorio.git Copia el repositorio remoto completo al local y se crea autom\u00e1ticamente una conexi\u00f3n remota llamada origin</li> <li>git pull origin main Actualiza la rama actual del repositorio local con los nuevos cambios efectuados en la rama (main) del repositorio remoto</li> <li>git merge branch-test Fusiona la rama (branch-test) a la rama actual del repositorio local</li> <li>git push origin --delete branch-test Elimina la rama (branch-test) del repositorio remoto</li> <li>git fetch --prune Elimina todas las referencias de seguimiento obsoletas del repositorio remoto</li> <li>git prune Elimina todas las referencias de seguimiento obsoletas del repositorio local</li> <li>git prune --verbose Elimina y muestra todas las referencias de seguimiento obsoletas que a eliminado del repositorio local</li> <li>git commit --amend -m \"texto corregido\" Edita el commit mas reciente y lo sustituye por uno nuevo</li> </ul>"},{"location":"tutoriales/control-versiones/comandos-git/#comandos-para-restaurar-o-resetear-a-un-commit-anterior-especifico","title":"Comandos para restaurar o resetear a un commit anterior espec\u00edfico:","text":"<ol> <li> <p>El m\u00e9todo (git restore): </p> <ul> <li>git log --oneline Muestra informaci\u00f3n simplificada de commits donde sale el hash de cada uno</li> <li>git restore --source 20cf9cb prueba.html Restaura el archivo (prueba.html) al commit mediante hash (20cf9cb)</li> </ul> </li> <li> <p>El m\u00e9todo (git reset):</p> <ul> <li>git log --oneline Muestra informaci\u00f3n simplificada de commits donde sale el hash de cada uno</li> <li>git reset 20cf9cb Regresa al commit mediante hash (20cf9cb)</li> </ul> <p>NOTA</p> <p>A pesar de que los commits ya no aparecen en el log, no se eliminan de GIT</p> <p></p> </li> </ol> <p>NOTA</p> <ul> <li>Para detener el servidor de \"mkdocs\" pulsa (ctrl + c)</li> <li>Para limpiar la consola utiliza el comando (cls) o (clear)</li> <li>Para salir de algun comando GIT pulsa (q)</li> </ul> <p>MALAS PR\u00c1CTICAS</p> <p>Est\u00e1 totalmente desaconsejado alterar el historial de commits, esto podria generar conflictos con los commits del repositorio remoto cuando se vaya hacer push o pull por cualquiera de los miembros, intenta siempre trabajar hacia adelante. Por lo general, est\u00e1 bien hacer este tipo de cambios en su propio repositorio local.</p> <p>BUENAS PR\u00c1CTICAS</p> <p>El mensaje del commit se escribe en presente, debe ser corto y conciso, no utilizar puntos ni puntos suspensivos al final.</p> <ol> <li>Ejemplo commit: <code>remove a random notification</code> </li> <li>Ejemplo commit: <code>add a new search feature</code></li> <li>Ejemplo commit: <code>change the default system color</code></li> <li>Ejemplo commit: <code>fix a problem with the topbar</code></li> </ol> <p></p> <p>Fuente: Sitio web oficial </p>"},{"location":"tutoriales/desarrollo-web/optimizar-seo/","title":"Optimizar el SEO","text":"<p>Antes de subir cualquier proyecto a producci\u00f3n, es importante comprobar que el SEO (Search Engine Optimization) este correctamente construido. Mencionare una herramienta gratuita que nos ayudara a testear nuestro SEO.</p>"},{"location":"tutoriales/desarrollo-web/optimizar-seo/#herramientas-online","title":"Herramientas online:","text":"<ul> <li>Open Graph es una herramienta que nos permitira ver la vista previa de la url compartida</li> <li>Squoosh es una herramienta de Google para editar y optimizar im\u00e1genes </li> </ul>"},{"location":"tutoriales/desarrollo-web/optimizar-seo/#la-importancia-del-orden","title":"La importancia del orden:","text":"<p>Para optimizar el SEO, es necesario seguir un orden espec\u00edfico dentro del head. Harry Roberts fue el creador de este orden. <pre><code>&lt;head&gt;\n  &lt;meta charset | http-equiv \\ viewport/&gt;\n  &lt;title&gt;&lt;/title&gt;\n  &lt;script src=\"\" async&gt;&lt;/script&gt;\n  CSS that icludes @import\n  Synchronous JS\n  Synchronous CSS\n  preload\n  &lt;script src=\"\" defer&gt;&lt;/script&gt;\n  prefetch / prerender\n  Everything else ('SEO' meta tags, icons, Open Graph, etc.)\n&lt;/head&gt;\n</code></pre></p>"},{"location":"tutoriales/desarrollo-web/optimizar-seo/#construccion-basica-del-head-con-el-seo-optimizado","title":"Construcci\u00f3n b\u00e1sica del head con el SEO optimizado:","text":"<ul> <li> <p>Aqu\u00ed la configuraci\u00f3n general del sitio web <pre><code>&lt;meta charset=\"UTF-8\"/&gt;\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/&gt;\nmas...\n</code></pre></p> </li> <li> <p>Aqu\u00ed la informaci\u00f3n general del sitio web <pre><code>&lt;title&gt;Documentaci\u00f3n t\u00e9cnica&lt;/title&gt;\n&lt;link rel=\"icon\" type=\"image/png\" href=\"src/img/favicon.png\"/&gt;\n&lt;meta name=\"description\"  content=\"Documentaci\u00f3n de proyectos, tutoriales de programaci\u00f3n, gu\u00edas de instalaci\u00f3n, todo en un \u00fanico lugar.\"/&gt;\nmas...\n</code></pre></p> </li> <li> <p>Aqu\u00ed la fuente de css y js <pre><code>&lt;link rel=\"stylesheet\" href=\"src/css/custom.css\"/&gt;\n&lt;script src=\"src/js/custom.js\"&gt;&lt;/script&gt;\nmas...\n</code></pre></p> </li> <li> <p>Aqu\u00ed el protocolo general de Open Graph que genera vista previa del enlace cuando es compartido.     <pre><code>&lt;meta property=\"og:url\" content=\"https://zuluta.github.io\"/&gt; &lt;!-- url a compartir --&gt;\n&lt;meta property=\"og:type\" content=\"website\"/&gt; &lt;!-- tipo de url a compartir --&gt;\n&lt;meta property=\"og:title\" content=\"Documentaci\u00f3n t\u00e9cnica\"/&gt; &lt;!-- t\u00edtulo de url a compartir --&gt;\n&lt;meta property=\"og:description\" content=\"Documentaci\u00f3n de proyectos, tutoriales de programaci\u00f3n, gu\u00edas de instalaci\u00f3n, todo en un \u00fanico lugar.\"/&gt; &lt;!-- descripci\u00f3n de url a compartir --&gt;\n&lt;meta property=\"og:image\" content=\"https://zuluta.github.io/og.jpg\"/&gt; &lt;!-- imagen de url a compartir --&gt;\n&lt;meta property=\"og:locale\" content=\"es_ES\"/&gt;\nmas...\n</code></pre></p> </li> </ul> <p>Ejemplo b\u00e1sico con el SEO optimizado<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n\n  &lt;!-- informaci\u00f3n que lee el navegador --&gt;\n  &lt;head&gt;\n\n    &lt;!-- configuraci\u00f3n general del sitio web --&gt;\n    &lt;meta charset=\"UTF-8\"/&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/&gt;\n\n    &lt;!-- informaci\u00f3n general del sitio web --&gt;\n    &lt;title&gt;Documentaci\u00f3n t\u00e9cnica&lt;/title&gt;\n    &lt;link rel=\"icon\" type=\"image/png\" href=\"src/img/favicon.png\"/&gt;\n    &lt;meta name=\"description\"  content=\"Documentaci\u00f3n de proyectos, tutoriales de programaci\u00f3n, gu\u00edas de instalaci\u00f3n, todo en un \u00fanico lugar.\"/&gt;\n\n    &lt;!-- fuente de css y js --&gt;\n    &lt;link rel=\"stylesheet\" href=\"src/css/custom.css\"/&gt;\n    &lt;script src=\"src/js/custom.js\"&gt;&lt;/script&gt;\n\n    &lt;!-- protocolo open graph --&gt;\n    &lt;meta property=\"og:url\" content=\"https://zuluta.github.io\"/&gt; &lt;!-- url a compartir --&gt;\n    &lt;meta property=\"og:type\" content=\"website\"/&gt; &lt;!-- tipo de url a compartir --&gt;\n    &lt;meta property=\"og:title\" content=\"Documentaci\u00f3n t\u00e9cnica\"/&gt; &lt;!-- t\u00edtulo de url a compartir --&gt;\n    &lt;meta property=\"og:description\" content=\"Documentaci\u00f3n de proyectos, tutoriales de programaci\u00f3n, gu\u00edas de instalaci\u00f3n, todo en un \u00fanico lugar.\"/&gt; &lt;!-- descripci\u00f3n de url a compartir --&gt;\n    &lt;meta property=\"og:image\" content=\"https://zuluta.github.io/docs/assets/images/og.png\"/&gt; &lt;!-- imagen de url a compartir --&gt;\n    &lt;meta property=\"og:locale\" content=\"es_ES\"/&gt;\n\n  &lt;/head&gt;\n\n  &lt;!-- contenido que ve el usuario --&gt;\n  &lt;body&gt;\n\n    &lt;!-- Esto mejora el rendimiento de la p\u00e1gina, primero carga el contenido HTML y luego el c\u00f3digo JavaScript --&gt;\n    &lt;script src=\"src/js/dictionary-builder.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre> Lo m\u00e1s normal es colocar los scripts Javascript justo antes del cierre de la etiqueta &lt;body&gt;</p> <p> </p>"},{"location":"tutoriales/instalacion-librerias/gh-deploy/","title":"Despliegue de proyecto local a GitHub Pages","text":"<p>01. Accede a GitHub y crea un repositorio nuevo.</p> <p> </p> <p>02. Escribe el mismo nombre del proyecto local, deja en p\u00fablico y pulsa el bot\u00f3n crear repositorio.</p> <p> </p> <p>03. Muestra los comandos y la URL remota del repositorio creado.</p> <p> </p> <p>04. Comandos para sincrinizar por primera vez GIT con GitHub desde la terminal de VSCode.</p> <ul> <li>(git init) Inicia el GIT</li> <li>(git config --global user.name \"nombre-usuario\") Usuario de GitHub</li> <li>(git config --global user.email \"micorreo@ejemplo.com\") Email de GitHub </li> </ul> <p>05. Comandos de terminal mas utilizados en GIT.</p> <ul> <li>(git init) Inicia el GIT</li> <li>(git add .) Agrega todos los archivos al GIT</li> <li>(git add ejemplo.html) Agrega los archivos indibidualmente al GIT</li> <li>(git commit -m \"inserta el mensaje aqui\") Agrega un commit al GIT</li> <li>(git branch -M main) Fuerza a renombrar la rama local actual por (main) actual main</li> <li>(git remote add origin https://github.com/usuario/mi-repositorio.git) Agrega la url remota del repositorio GitHub</li> <li>(git remote -v) Verifica la comunicaci\u00f3n con el repositorio remoto</li> <li>(git status) Muestra el estado de los procesos GIT</li> <li>(git push -u origin main) Sube los archivos a la rama main del repositorio GitHub</li> </ul> <p>El orden de ejecuci\u00f3n</p> <p>El orden de ejecuci\u00f3n, variara en funci\u00f3n de lo que quieras hacer. Por l\u00f3gica, primero se inicia el GIT, se agregan los archivos, se envia un commit, la verificaci\u00f3n de estado y la comunicaci\u00f3n con el repositorio solo nos da informaci\u00f3n, no hace ningun cambio en el repositorio.</p> <p></p> <p>06. Entra en VSCode y abre una terminal nueva.</p> <ul> <li>Desde la carpeta de trabajo \"proyecto-docs\", activa el entorno virtual (.envscriptsactivate)</li> <li>Accede a la carpeta del proyecto \"docs\" y lanza el comando (mkdocs build) para compilar, \u00e9sto creara una nueva carpeta llamada site donde compilara todo el proyecto.</li> </ul> <p> </p> <p>07. Desde la carpeta del proyecto \"docs\", abre la terminal y prepara el repositorio GIT para subir al repositorio GitHub.</p> <ul> <li>Ejecuta el comando (git init)</li> <li>Ejecuta el comando (git add .)</li> <li>Ejecuta el comando (git commit -m \"despliegue\")</li> <li>Ejecuta el comando (git branch -M main)</li> <li>Ejecuta el comando (git remote add origin https://github.com/zuluta/docs.git)</li> <li>Ejecuta el comando (git remote -v)</li> <li>Ejecuta el comando (git status)</li> <li>Ejecuta el comando (git push -u origin main)</li> </ul> <p>NOTA</p> <p>La rama \"master\" y \"main\" son lo mismo. Hace unos a\u00f1os, la comunidad de software decidi\u00f3 cambiar el nombre de la rama principal de master a main. Verifica con el comando (git branch) las ramas existentes en tu repositorio local y si existe la rama master, pasa a la rama master con el comando (git switch master) y cambia el nombre de la rama con el comando (git branch -m main) o (git branch -M main) para forzarlo. De este modo, solo se dejara una rama principal con el nombre \"main\" por repositorio.</p> <p> </p> <p>08. Entra al repositorio y verifica si se subieron bien los archivos a GitHub en la rama main.</p> <p> </p> <p>09. GitHub permite crear una pagina web gratis desde el repositorio.</p> <ul> <li>Ejecuta el comando (mkdocs gh-deploy)</li> </ul> <p>Este comando es espec\u00edfico de mkdocs para GitHub. Este comando creara de forma autom\u00e1tica una nueva rama gh-pages en el mismo repositorio del proyecto para poder desplegar GitHub Pages.</p> <p>10. Entra al repositorio de GitHub y verifica si se creo la rama \"gh-pages\".</p> <p> </p> <p>11. Entra en Settings, luego en Pages, donde pone Branch, selecciona la rama \"gh-pages\" y la carpeta \"(root)\". Pulsa el bot\u00f3n de guardar y espera unos segundos a que se active la p\u00e1gina.</p> <p> </p> <p>12. Entra en Settings, luego en Pages, donde pone GitHub Pages, verifica que la p\u00e1gina este operativa.</p> <p> </p> <p>13. Si necesitas actualizar GitHub Pages por nuevos cambios, ejecuta lo siguiente.</p> <ul> <li>Desde la carpeta de trabajo \"proyecto-docs\", activa el entorno virtual (.envscriptsactivate)</li> <li>Accede a la carpeta del proyecto \"docs\" y lanza el comando (mkdocs build)</li> <li>Ejecuta el comando (git init)</li> <li>Ejecuta el comando (git add .)</li> <li>Ejecuta el comando (git commit -m \"actualizar contenido\")</li> <li>Ejecuta el comando (git branch)</li> <li>Ejecuta el comando (git switch main)</li> <li>Ejecuta el comando (git remote add origin https://github.com/zuluta/docs.git)</li> <li>Ejecuta el comando (git remote -v)</li> <li>Ejecuta el comando (git status)</li> <li>Ejecuta el comando (git push -u origin main) Se sube a la rama \"main\" del repositorio donde se guarda el proyecto</li> <li>Ejecuta el comando (mkdocs gh-deploy) Compila y despliega a la rama \"gh-pages\" del repositorio. \u00c9sta rama, va enlazado al sitio web de GitHub Pages</li> <li>Verifica los cambios en la p\u00e1gina  </li> </ul>"},{"location":"tutoriales/instalacion-librerias/mkdocs/","title":"Instalar MkDocs con Python y virtualenv","text":"<p>01. Verifica si Python y virtualenv est\u00e1n instalados de forma global y si no aparecen, instalalos.</p> <p> </p> <p>02. Entra en \u201cescritorio\u201d y crea una carpeta de trabajo que se llame (proyecto-docs) con el comando (mkdir proyecto-docs).</p> <p>03. Entra en \u201cproyecto-docs\u201d y crea una carpeta virtual que se llame (env).</p> <p>04. Act\u00edva la carpeta \u201cenv\u201d en modo virtual con el comando (.\\env\\scripts\\activate).</p> <p>05. Instala la librer\u00eda dentro de la carpeta \u201cenv\u201d con el comando (pip install mkdocs).</p> <p> </p> <p>06. Verifica si la librer\u00eda mkdocs se instal\u00f3 bien.</p> <p> </p> <p>07. Crea nuevo proyecto de mkdocs que se llame (mi-documentacion).</p> <p>08. Verifica si el proyecto se cre\u00f3 bien y desactiva el entorno virtual con el comando (deactivate). Cierra la terminal.</p> <p> </p> <p>09. Abre VSCode y carga la carpeta del escritorio \u201cproyecto-docs\u201d desde el menu superior (Archivo / Abrir carpeta\u2026).</p> <p> </p> <p>10. Dentro del proyecto \u201cmi-documentacion\u201d, abre el archivo que pone index.md.</p> <p>11. Abre una nueva terminal desde el menu superior (... / Terminal / Nuevo terminal) para ejecutar el servidor en local. Recordar que la librer\u00eda mkdocs se instal\u00f3 en un entorno virtual por lo que sera necesario primero activar el entorno virtual desde la carpeta de trabajo \u201cproyecto-docs\u201d con el comando (.\\env\\Scripts\\activate). Luego entra en la carpeta del proyecto \u201cmi-documentaci\u00f3n\u201d y desde ah\u00ed, ejecutar el siguiente comando (mkdocs serve), esto ejecutara el servidor local.</p> <p> </p> <p>12. Para verificar, copia la URL del servidor y abre en el navegador, le aparecer\u00e1 la p\u00e1gina de bienvenida por defecto.</p> <p> </p> <p>13. Con esto, ya tendrias instalado la librer\u00eda mkdocs en un entorno virtual y creado el proyecto para empezar a editar tu propia documentaci\u00f3n, porfolio, o lo que quieras de forma local.</p> <p>14. Ahora que ya tenemos mkdocs en marcha, toca instalar un tema desarrollado para mkdocs que le va dar un dise\u00f1o mucho mas moderno. Abre la terminal de VSCode, pulsa (ctrl + c) para detener el servidor, activa el entorno virtual, accede a la carpeta \u201cmi-documentaci\u00f3n\u201d y desde ah\u00ed ejecuta el comando (pip install mkdocs-material). Una vez terminada la instalaci\u00f3n, abre el archivo \u201cmkdocs.yml\u201d y modifica el nombre del tema. En este caso, se llama material. El tema que viene instalado por defecto se llama \u201creadthedocs\u201d.</p> <p> </p> <p>15. Para finalizar, recarga la p\u00e1gina y veras un aspecto mucho mas moderno de tu sitio web.</p> <p> </p>"},{"location":"tutoriales/ruta-aprendizaje/desarrollador-full-stack/","title":"Desarrollador Full Stack","text":"<p>El programador Full Stack es el profesional encargado de desarrollar p\u00e1ginas web, tanto en el FRONTEND como en el BACKEND. Para desempe\u00f1ar sus funciones, que incluyen desde el dise\u00f1o de interfaces hasta el desarrollo de arquitecturas y la optimizaci\u00f3n del sitio web, debe combinar una serie de conocimientos t\u00e9cnicos y creativos.</p>"},{"location":"tutoriales/ruta-aprendizaje/desarrollador-full-stack/#diagrama","title":"Diagrama","text":"<p>Creado con app.diagrams.net </p>"}]}