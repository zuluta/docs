{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inicio","text":""},{"location":"devcamp/","title":"DevCamp","text":"DevCamp <p>PT Full Stack Development with JavaScript, Python, React</p> <p>\u00cdNDICE DE CONTENIDOS</p> <ol> <li>Checkpoint 06</li> <li>Checkpoint 07</li> <li>Checkpoint 08</li> </ol> <p> </p>"},{"location":"devcamp/checkpoint-06/","title":"Checkpoint 06","text":""},{"location":"devcamp/checkpoint-06/#documentacion-python","title":"Documentaci\u00f3n Python","text":"<p>\u00cdNDICE CHECKPOINT 06</p> <ol> <li>Introducci\u00f3n al uso de clases</li> <li>\u00bfQu\u00e9 es un m\u00e9todo dunder?</li> <li>\u00bfQu\u00e9 es un decorador?</li> <li>\u00bfQu\u00e9 es el polimorfismo?</li> <li>\u00bfQu\u00e9 es una API?</li> <li>\u00bfEs MongoDB una base de datos SQL o NoSQL? </li> </ol>"},{"location":"devcamp/checkpoint-06/introduccion-clases-py/","title":"1. Introducci\u00f3n al uso de clases","text":"<p>Python es un lenguaje orientado a objetos, no es necesario hacer uso de ellas para poder crear un programa. De hecho, hemos estado trabajando hasta ahora sin hacer menci\u00f3n a ellas ni emplearlas.</p> <p>Hasta ahora, hemos construido aplicaciones peque\u00f1as de manera secuenciada y desorganizada. Esto no significa que lo hayamos hecho mal, lo que quiero decir es, que cuando empecemos a crear aplicaciones di\u00e1micas y sean mas complejas, necesitaremos mejorar la estructura del c\u00f3digo, la organizaci\u00f3n y crear c\u00f3digo reutilizable y facilitar su mantenimiento.</p> <p></p>"},{"location":"devcamp/checkpoint-06/introduccion-clases-py/#11-clase-estatica","title":"1.1. Clase est\u00e1tica:","text":"<p>PRECAUCI\u00d3N</p> <p>Hay que evitar el mal uso de las clases, en este ejemplo, vemos que las variables no son reutilizables, tampoco podemos pasarle argumentos.</p> <p></p> <p> </p> <p>C\u00f3digo Python \ud83d\udc47</p> <pre><code>class Cliente:\n\n    dni = '88521596P'\n    nombre = 'Luis'\n    apellido = 'Mendoza'\n\n    def __init__(self):\n        print(f'DNI: {self.dni}\\nNombre: {self.nombre}\\nApellido: {self.apellido}')\n\n\nCliente()\n\n# salida:\n    # DNI: 88521596P\n    # Nombre: Luis\n    # Apellido: Mendoza\n</code></pre> <ul> <li>\u274c Estructurado.</li> <li>\u274c Organizado.</li> <li>\u274c Escalable.</li> <li>\u274c Reutilizable. </li> </ul>"},{"location":"devcamp/checkpoint-06/introduccion-clases-py/#12-clase-dinamica","title":"1.2. Clase din\u00e1mica:","text":"<p>La manera recomendada de contruir aplicaci\u00f3nes con c\u00f3digo reutilizable y organizada, es con el uso de las clases. Al principio, es normal que te sientas perdido con todo esto de las clases, pero no te preocupes, todos hemos pasado por esta etapa.</p> <p>Para crear una clase, vamos a emplear la palabra reservada <code>class</code> seguido de un nombre escrito en PascalCase, primera letra de cada palabra se escribe en may\u00fascula, y sin guiones bajos. Sabemos que las clases pueden contener funciones, a las que llamamos m\u00e9todos. Una clase tambi\u00e9n puede contener variables, a las que se conoce con el nombre de atributos. Para crear atributos, primero definimos un m\u00e9todo especial llamado <code>__init__()</code>, que es invocado por Python autom\u00e1ticamente siempre que se crea una instancia de la clase (conocido tambi\u00e9n como constructor o inicializador).</p> <p>Los clientes que vayamos a crear, no tendr\u00e1n el mismo <code>dni</code>, <code>nombre</code> ni <code>apellido</code>. Por ello ser\u00eda conveniente permitir que, al definir una instancia, se pase como argumento el dni del cliente y \u00e9ste se almacene en el atributo <code>self.dni</code>, nombre del cliente en el atributo <code>self.nombre</code> y apellido del cliente en el atributo <code>self.apellido</code>.</p> <p></p> <p>IMPORTANTE</p> <p>Dentro de la clase, las variables pasan a llamarse atributos, el primer atributo obligatorio siempre sera <code>self</code>, las funciones pasan a llamarse m\u00e9todos, nos permite pasarle argumentos y eso hace que el c\u00f3digo sea reutilizable. Estas son las razones por el cual se crearon las clases en programaci\u00f3n.</p> <p></p> <p> </p> <p>C\u00f3digo Python \ud83d\udc47</p> <p><pre><code>class Cliente:\n    def __init__(self, dni, nombre, apellido):\n        self.dni = dni\n        self.nombre = nombre\n        self.apellido = apellido\n\n        print(f'DNI: {self.dni}\\nNombre: {self.nombre}\\nApellido: {self.apellido}')\n\nCliente('88521596P', 'Luis', 'Mendoza')\nCliente('96452178K', 'Maribel', '')\n\n# salida:\n    # DNI: 88521596P\n    # Nombre: Luis\n    # Apellido: Mendoza\n    # DNI: 96452178K\n    # Nombre: Maribel\n    # Apellido:\n</code></pre> </p>"},{"location":"devcamp/checkpoint-06/introduccion-clases-py/#13-crear-objetos-con-clase","title":"1.3. Crear objetos con clase:","text":"<p>TIP</p> <p>Antes del auge de la POO, la programaci\u00f3n estaba dominada por el paradigma procedimental. Este enfoque estructuraba los programas como una serie de instrucciones secuenciales y depend\u00eda en gran medida de funciones y datos globales. Si bien este modelo era efectivo para problemas simples, se volvi\u00f3 dif\u00edcil de manejar a medida que los sistemas se hicieron m\u00e1s complejos debido a la falta de separaci\u00f3n clara entre los datos y las operaciones.</p> <p></p> <p>Python es un lenguaje multiparadigma:</p> <ul> <li>Soporta la programaci\u00f3n imperativa y funcional.</li> <li>Soporta la programaci\u00f3n orientada a objetos (POO). </li> </ul> <p>En este ejemplo, vamos a crear 2 objetos que se van a llamar <code>cli_1</code> y <code>cli_2</code>. <code>cli_1</code> va tener DNI, Nombre, Apellido y el <code>cli_2</code> va tener solamente DNI, Nombre. La ventaja de poder crear estos objetos de una forma tan simplificada, es impresionante.</p> <p></p> <p>C\u00f3digo Python \ud83d\udc47</p> <p><pre><code>class Cliente:\n\n    def __init__(self, dni, nombre, apellido):\n        self.dni = dni\n        self.nombre = nombre\n        self.apellido = apellido\n\ncli_1 = Cliente('88521596P', 'Luis', 'Mendoza')\ncli_2 = Cliente('96452178K', 'Maribel', '')\n\nprint(f'DNI: {cli_1.dni}\\nNombre: {cli_1.nombre}\\nApelllido: {cli_1.apellido}')\nprint(f'DNI: {cli_2.dni}\\nNombre: {cli_2.nombre}')\n\n# salida:\n    # DNI: 88521596P\n    # Nombre: Luis\n    # Apellido: Mendoza\n    # DNI: 96452178K\n    # Nombre: Maribel\n    # Apellido:\n</code></pre> </p>"},{"location":"devcamp/checkpoint-06/introduccion-clases-py/#14-metodos-dentro-de-una-clase","title":"1.4. M\u00e9todos dentro de una clase:","text":"<p>En este ejemplo, vamos a crear un m\u00e9todo normal llamado <code>cuenta</code>, el primer atributo obligatorio se llama <code>self</code>, seguido pondremos nuestros atributos opcionales separadas por una <code>,</code>coma y cerramos la linea con <code>:</code> dos puntos.</p> <p>Dentro del m\u00e9todo, indentamos con 4 espacios para empezar a escribir nuestro c\u00f3digo de ejecuci\u00f3n. En este caso, vamos a emplear <code>return</code> para retornar un mensaje que ponga Cuenta: El cliente ????????? tiene cuenta. Con esto, ya tendriamos nuestra clase completado.</p> <p>Utilizaremos los mismos objetos <code>cli_1</code> y <code>cli_2</code> creados en el ejercicio anterior. La forma de acceder a ello es, llamamos primero al objeto <code>cli_1</code> y ponemos un <code>.</code> punto y llamamos al metodo <code>cuenta</code>. Al tratarse de un m\u00e9todo, como toda funci\u00f3n, devemos cerrarla con <code>()</code>parentesis. El c\u00f3digo quedaria de la siguiente manera <code>cli_1.cuenta()</code></p> <p>Finalizamos el ejemplo con la funci\u00f3n <code>print()</code> para imprimir en pantalla lo que hemos programado en esta clase, <code>print(cli_1.cuenta())</code> y <code>print(cli_2.cuenta())</code></p> <p></p> <p>C\u00f3digo Python \ud83d\udc47</p> <p><pre><code>class Cliente:\n\n    def __init__(self, dni, nombre, apellido):\n        self.dni = dni\n        self.nombre = nombre\n        self.apellido = apellido\n\n    def cuenta(self):\n        return f'Cuenta: El cliente {self.dni} tiene cuenta'\n\ncli_1 = Cliente('88521596P', 'Luis', 'Mendoza')\ncli_2 = Cliente('96452178K', 'Maribel', '')\n\nprint(cli_1.cuenta())\nprint(cli_2.cuenta())\n\n# salida:\n    # Cuenta: El cliente 88521596P tiene cuenta\n    # Cuenta: El cliente 96452178K tiene cuenta\n</code></pre> </p>"},{"location":"devcamp/checkpoint-06/introduccion-clases-py/#15-estructura-basica-de-una-clase","title":"1.5. Estructura b\u00e1sica de una clase:","text":"<p>Llegados aqui, aprenderemos los conceptos b\u00e1sicos que construyen una clase. Trata de leer el c\u00f3digo y entender lo que sucede en cada paso.</p> <p></p> <p>Descripci\u00f3n de conceptos:</p> <ol> <li><code>class</code> Declara una clase.</li> <li><code>Cliente</code> Asigna un nombre a la clase, siempre en PascalCase y sin guiones bajos.</li> <li><code>password = '1234'</code> Declara una variable de clase.</li> <li><code>def</code> Declara un m\u00e9todo.</li> <li><code>__init__</code> Lleva dos guiones al principio y al final del nombre, se le conoce como m\u00e9todo dunder, especial o m\u00e1gico.</li> <li><code>self</code> Es el primer atributo obligatorio siempre.</li> <li><code>dni</code>,<code>nombre</code>, <code>apellido</code> Se llaman atributos del m\u00e9todo y van separados por una <code>,</code> coma.</li> <li><code>self.dni</code> Declara una variable de instancia.</li> <li><code>dni</code> Guarda el valor de la variable de instancia.</li> <li><code>cuenta</code> Asigna un nombre al m\u00e9todo.</li> <li><code>self.password</code> Hace referencia a la variable de instancia para retornar su valor.</li> <li><code>cli_1</code> Crea un objeto.</li> <li><code>Cliente</code> Invoca a la clase desde cualquier parte de la aplicaci\u00f3n.</li> <li><code>'88521596P'</code>, <code>'Luis'</code>, <code>'Mendoza'</code> Se llaman argumentos.</li> <li><code>Print</code> Es una funci\u00f3n para imprimir en pantalla.</li> <li><code>cli_1.cuenta</code> hace referencia al objeto <code>cli_1</code> para acceder a la clase y ejecutar el m\u00e9todo <code>cuenta</code>.</li> <li>Visualizamos los datos en la pantalla.</li> </ol> <p></p> <p>C\u00f3digo Python \ud83d\udc47</p> <pre><code>class Cliente:\n    password = '1234'\n\n    def __init__(self, dni, nombre, apellido):\n        self.dni = dni\n        self.nombre = nombre\n        self.apellido = apellido\n\n    def cuenta(self):\n        return f'{self.nombre} {self.apellido}:\\nUsuario: {self.dni}\\nContrase\u00f1a: {self.password}'\n\ncli_1 = Cliente('88521596P', 'Luis', 'Mendoza')\ncli_2 = Cliente('96452178K', 'Maribel', 'Garcia')\n\nprint(cli_1.cuenta())\nprint(cli_2.cuenta())\n\n# salida:\n    # Luis Mendoza:\n    # Usuario: 88521596P\n    # Contrase\u00f1a: 1234\n    # Maribel Garcia:\n    # Usuario: 96452178K\n    # Contrase\u00f1a: 1234\n</code></pre> <ul> <li>\u2705 Facil de estructurar.</li> <li>\u2705 Facil de organizar.</li> <li>\u2705 Facil de leer.</li> <li>\u2705 Facil de escalar.</li> <li>\u2705 C\u00f3digo reutilizable.</li> </ul> <p>IMPORTANTE</p> <p>Las variables de clase son \u00fatiles cuando queremos utilizar un mismo valor en cualquiera de los metodos. Son accesibles desde cualquier m\u00e9todo. Dentro de las clases, no se recomienda el uso de las condicionales. Su uso est\u00e1 enfocado en gestionar datos y m\u00e9todos.</p> <p>\ud83d\udcac Es fundamental entender bien la estructura y la l\u00f3gica de las clases para poder seguir avanzando y evitar estancamientos en el futuro.  </p>"},{"location":"devcamp/checkpoint-06/metodo-dunder-py/","title":"2. \u00bfQu\u00e9 es un m\u00e9todo dunder?","text":"<p>En programaci\u00f3n orientada a objetos, los m\u00e9todos dunder o m\u00e9todos m\u00e1gicos son funciones especiales que permiten definir comportamientos espec\u00edficos para las clases. Estos m\u00e9todos se llaman \u201cm\u00e1gicos\u201d porque su nombre comienza y termina con dos guiones bajos (__).</p> <p>TIP</p> <p>Los m\u00e9todos m\u00e1gicos son una herramienta poderosa que permite definir comportamientos espec\u00edficos para las clases en Python. Utilizarlos de forma adecuada puede hacer que nuestro c\u00f3digo sea m\u00e1s f\u00e1cil de entender y mantener.</p> <p></p>"},{"location":"devcamp/checkpoint-06/metodo-dunder-py/#21-tipos-de-metodos-dunder","title":"2.1. Tipos de m\u00e9todos dunder:","text":"<ul> <li><code>__init__</code>: Se utiliza para inicializar objetos y es invocado autom\u00e1ticamente cuando se crea una instancia de la clase.</li> <li><code>__str__</code>: Se utiliza para representar el objeto en forma de cadena de texto.</li> <li><code>__len__</code>: Permite determinar la longitud de un objeto.</li> </ul> <p>Existen muchos otros m\u00e9todos m\u00e1gicos que pueden ser \u00fatiles, como <code>__add__</code> (para sumar objetos), <code>__eq__</code> (para comparar igualdad), <code>__lt__</code> (para comparar menor que), entre otros. Sin embargo, es importante tener en cuenta que no siempre es necesario utilizar estos m\u00e9todos y que su uso variar\u00e1 dependiendo de cada caso espec\u00edfico.</p> <p></p> <ul> <li> <p>Ejemplo <code>__init__</code>: <pre><code>class Persona:\n    def __init__(self, nombre):\n        self.nombre = nombre\n\np = Persona('Juan')\nprint(p.nombre)\n</code></pre></p> </li> <li> <p>Ejemplo <code>__init__</code> con <code>__str_</code>: <pre><code>class Persona:\n    def __init__(self, nombre):\n        self.nombre = nombre\n\n    def __str__(self):\n        return f'Mi nombre es {self.nombre}'\n\np = Persona('Juan')\nprint(p)\n</code></pre></p> </li> <li> <p>Ejemplo <code>__init__</code> con <code>__len__</code>: <pre><code>class Lista:\n    def __init__(self, elementos):\n        self.elementos = elementos\n\n    def __len__(self):\n        return len(self.elementos)\n\nl = Lista([1,2,3,4,5])\nprint(len(l)) # Imprime 5\n</code></pre></p> </li> </ul> <p>IMPORTANTE</p> <p>El primer ejemplo y el segundo ejemplo tienen el mismo resultado, lo que hace el m\u00e9todo dunder <code>__str__</code> es convertir el objeto en una cadena de texto.</p> <p></p>"},{"location":"devcamp/checkpoint-06/metodo-dunder-py/#22-que-metodo-dunder-se-ejecuta-automaticamente","title":"2.2. \u00bfQu\u00e9 m\u00e9todo dunder se ejecuta autom\u00e1ticamente?","text":"<p>El m\u00e9todo <code>__init__</code>, es un m\u00e9todo especial que se ejecuta autom\u00e1ticamente al invocar la clase e inicializara los atributos del objeto que le ayamos creado. Es decir, es imposible de olvidarse llamarlo ya que se llamar\u00e1 autom\u00e1ticamente.</p> <p>IMPORTANTE</p> <p>El m\u00e9todo <code>__init__</code> es el primer m\u00e9todo que se ejecuta dentro de una clase.</p> <p></p>"},{"location":"devcamp/checkpoint-06/metodo-dunder-py/#caracteristicas","title":"\ud83d\udcdd Caracter\u00edsticas:","text":"<ul> <li>El m\u00e9todo <code>__init__</code> no puede retornar <code>return</code> datos, no devuelve nada.</li> <li>El m\u00e9todo <code>__init__</code> puede recibir par\u00e1metros que se utilizan para inicializar atributos de forma autom\u00e1tica.</li> <li>El m\u00e9todo <code>__init__</code> es un constructor de instancias.</li> <li>El m\u00e9todo <code>__init__</code> es un m\u00e9todo opcional, de todos modos es muy com\u00fan declararlo.  </li> </ul>"},{"location":"devcamp/checkpoint-06/que-es-mongodb-py/","title":"6. \u00bfEs MongoDB una base de datos SQL o NoSQL?","text":"<p>MongoDB es una base de datos NoSQL orientada a documentos que apareci\u00f3 el a\u00f1o 2007. Se utiliza para almacenar vol\u00famenes masivos de datos.</p>"},{"location":"devcamp/checkpoint-06/que-es-mongodb-py/#61-como-se-almacenan-los-datos","title":"6.1. \u00bfComo se almacenan los datos?","text":"<p>A diferencia de una base de datos relacional SQL tradicional, MongoDB no se basa en tablas y columnas. Los datos se almacenan como colecciones y documentos.</p> <p>La arquitectura de MongoDB se basa en varios componentes principales. En primer lugar, la clave _id es un campo obligatorio para cada documento que se genera de forma autom\u00e1tica. Representa un valor \u00fanico y puede considerarse como la clave principal del documento para identificar al objeto dentro de la colecci\u00f3n.</p> <p></p> <p>IMPORTANTE</p> <ul> <li>Colecciones: Se refiere a un diccionario <code>{...}</code> o lista <code>[...]</code>.</li> <li>Documentos: Se refiere a la <code>\"clave\": \"valor\"</code> dentro de un diccionario. </li> </ul> <p></p> <p></p> <pre><code>{\n    \"_id\": ObjectId(\"5cf0029caff5056591b0ce7d\"),\n    \"nombre\": \"Juan\",\n    \"apellido\": \"Garcia\",\n},\n{\n    \"_id\": ObjectId(\"6sh5930rdee4058890b0ae5c\"),\n    \"nombre\": \"Nerea\",\n    \"apellido\": \"Larralde\",\n    \"telefono\": \"666-666-444\",\n    \"direccion\":  {\n        \"codigo_postal\": \"22222\",\n        \"provincia\": \"Gipuzkoa\",\n        \"pais\": \"Espa\u00f1a\"\n    }\n}\n</code></pre> <p>IMPORTANTE</p> <p>MongoDB almacena los datos en documentos flexibles al estilo JSON pero los reconoce como BSON, esto vendria a ser un JSON binario.</p> <p></p>"},{"location":"devcamp/checkpoint-06/que-es-mongodb-py/#61-comandos-para-interactuar-con-la-base-de-datos-desde-la-terminal","title":"\ud83d\udc68\u200d\ud83d\udcbb 6.1. Comandos para interactuar con la base de datos desde la terminal:","text":"<p>MQL es el lenguaje de consulta y manipulaci\u00f3n de informaci\u00f3n que MongoDB nos provee por defecto (MongoDB Query Language). Las consultas de MongoDB se basan en el lenguaje de programaci\u00f3n JavaScript con algunas diferencias leves.</p> <p></p> <ul> <li>Consultar todos los documentos que tenemos en la base de datos sin formatear la estructura:<ul> <li>C\u00f3digo: <code>db.nombre_de_tu_base_de_datos.find()</code>.</li> </ul> </li> <li>Consultar todos los documentos que tenemos en la base de datos con la estructura formateada:<ul> <li>C\u00f3digo: <code>db.nombre_de_tu_base_de_datos.find().pretty()</code>.</li> </ul> </li> <li>Consultar todos los documentos que coincidan con el valor del apellido:<ul> <li>C\u00f3digo: <code>db.nombre_de_tu_base_de_datos.find({apellido: \"Larralde\"}).pretty()</code>.</li> </ul> </li> <li>Consultar cuantos documentos coinciden con el valor del apellido:<ul> <li>C\u00f3digo: <code>db.nombre_de_tu_base_de_datos.find({apellido: \"Larralde\"}).length()</code>.</li> </ul> </li> <li>Consultar cuantos documentos coinciden con el valor del apellido utilizando Regex:<ul> <li>C\u00f3digo: <code>db.nombre_de_tu_base_de_datos.find({apellido: /.*Larralde.*/i})</code>.</li> </ul> </li> <li>Consultar en el documento si existe una clave o no:<ul> <li>C\u00f3digo: <code>db.nombre_de_tu_base_de_datos.find({apellido: $exists: true})</code>.</li> </ul> </li> <li>Eliminar todos los documentos que coincidan con el valor del apellido:<ul> <li>C\u00f3digo: <code>db.nombre_de_tu_base_de_datos.remove({apellido: \"Larralde\"})</code>.</li> </ul> </li> <li> <p>Eliminar un documento que coincida con el valor del apellido:</p> <ul> <li>C\u00f3digo: <code>db.nombre_de_tu_base_de_datos.remove({apellido: \"Larralde\"}, 1)</code>. </li> </ul> </li> <li> <p>Insertar un nuevo documento \ud83d\udc47 <pre><code>db.nombre_de_tu_base_de_datos.insert({\n    \"nombre\": \"Carlos\",\n    \"apellido\": \"Garrido\",\n    \"direccion\": {\n        \"codigo_postal\": \"45210\",\n        \"provincia\": \"Gipuzkoa\",\n        \"pais\": \"Espa\u00f1a\"\n    }\n});\n</code></pre> </p> </li> </ul> <p>TIP</p> <p>Descargar MongoDB desde https://www.mongodb.com/try/download/community.</p> <p>Para m\u00e1s informaci\u00f3n, consulte en su p\u00e1gina oficial.</p> <p> </p>"},{"location":"devcamp/checkpoint-06/que-es-polimorfismo-py/","title":"4. \u00bfQu\u00e9 es el polimorfismo?","text":"<p>El polimorfismo tiene como objetivo cambiar la funcionalidad entre los m\u00e9todos con el mismo nombre, en este ejemplo, tenemos tres clases, a los m\u00e9todos les hemos asignado el mismo nombre <code>desplazamiento</code>. A pesar de que lleven el mismo nombre, los podemos diferenciar creando una nueva funci\u00f3n y pasandole como atributo, por ejemplo <code>vehiculo</code>. El <code>vehiculo</code> tomara el valor de <code>mi_vehiculo</code> para hacer la m\u00e1gia del polimorfismo. A la variable <code>mi_vehiculo</code>, podemos pasarle cualquiera de las tres clases, <code>Moto()</code>, <code>Coche()</code>, <code>Camion()</code>.</p> <p></p> <p> </p> <p>C\u00f3digo Python \ud83d\udc47</p> <p><pre><code>class Moto():\n\n    def desplazamiento(self):\n        print('Me desplazo utilizando 2 ruedas')\n\nclass Coche():\n\n    def desplazamiento(self):\n        print('Me desplazo utilizando 4 ruedas')\n\nclass Camion():\n\n    def desplazamiento(self):\n        print('Me desplazo utilizando 6 ruedas')\n\ndef desplazamiento_vehiculo(vehiculo):\n    vehiculo.desplazamiento()\n\nmi_vehiculo = Coche()\ndesplazamiento_vehiculo(mi_vehiculo)\n\n# salida:\n    # Me desplazo utilizando 4 ruedas\n</code></pre> </p> <p>IMPORTANTE</p> <p>El polimorfismo puede acceder a cualquiera de las clases y ejecutar m\u00e9todos independientemente del nombre que tengan.</p> <p> </p>"},{"location":"devcamp/checkpoint-06/que-es-un-decorador-py/","title":"3. \u00bfQu\u00e9 es un decorador?","text":"<p>Los decoradores son funciones que toman otra funci\u00f3n como argumento y anidan una nueva funci\u00f3n para agregarle c\u00f3digo extra sin alterar la existente.</p> <p>En el siguiente ejemplo, puedes ver la estructura general de una funci\u00f3n decoradora.</p> <p>TIP</p> <p>Si alguna vez has visto <code>@</code>, est\u00e1s ante un decorador.</p> <p></p> <p> </p> <p>C\u00f3digo Python \ud83d\udc47</p> <p><pre><code>def decorador(f):\n\n    def funcion_nueva():\n        print('Funcionalidad extra')\n        f()\n    return funcion_nueva\n\n@decorador\ndef funcion_inicial():\n    print('Funcionalidad inicial')\n\nfuncion_inicial()\n</code></pre> </p>"},{"location":"devcamp/checkpoint-06/que-es-un-decorador-py/#analicemos-estos-elementos-en-mas-detalle","title":"\ud83d\udd75\ufe0f Analicemos estos elementos en m\u00e1s detalle:","text":"<ul> <li> <p>Esta es la <code>funci\u00f3n_inicial</code> que el <code>@decorador</code> va tomar como referencia. <pre><code>@decorador\ndef funcion_inicial():\n    print('Funcionalidad inicial')\n\nfuncion_inicial()\n</code></pre></p> </li> <li> <p>Esta es una funci\u00f3n intermediaria que va hacer la decoradoraci\u00f3n <code>def decorador</code>. El nombre de la funci\u00f3n hace referencia a <code>@decorador</code>. Toma <code>(f)</code> como argumento para invocar <code>f()</code> m\u00e1s adelante dentro de la <code>funci\u00f3n_nueva()</code> que va ir anidada.</p> </li> </ul> <pre><code>def decorador(f):\n    def funcion_nueva():\n        print('Funcionalidad extra')\n        f()\n    return funcion_nueva\n</code></pre> <ul> <li>Si ejecutamos el c\u00f3digo, podemos ver el siguiente resultado:</li> </ul> <p><pre><code>Funcionalidad extra\nFuncionalidad inicial\n</code></pre> </p>"},{"location":"devcamp/checkpoint-06/que-es-una-api-py/","title":"5. \u00bfQue es una API?","text":"<p>Una API es una (interfaz de programaci\u00f3n de aplicaciones) que sigue un conjunto de restricciones arquitecturales basadas en HTTP. Esto significa que se puede acceder a los recursos a trav\u00e9s de URLs, lo que hace que la API sea f\u00e1cil de entender y utilizar. Podemos crear una API que haga literalmente cualquier cosa, desde dar clima hasta un cat\u00e1logo completo de una tienda en l\u00ednea. Casi todas las aplicaciones utilizan APIs para conectarse con fuentes de datos corporativas, servicios de datos de terceros u otras aplicaciones.</p> <p>TIP</p> <p>El formato de intercambio de datos normalmente es JSON o XML, lo que permite que la API sea compatible con una amplia variedad de aplicaciones.</p> <p></p> <p> </p>"},{"location":"devcamp/checkpoint-06/que-es-una-api-py/#51-una-api-tiene-dos-componentes-principales","title":"5.1. Una API tiene dos componentes principales:","text":"<ul> <li> <p>Recursos:</p> <ul> <li>Datos o informaci\u00f3n.</li> </ul> </li> <li> <p>Verbos HTTP:</p> <ul> <li><code>GET</code> para consultar y leer.</li> <li><code>POST</code> para crear.</li> <li><code>PUT</code> para editar.</li> <li><code>DELETE</code> para eliminar.</li> </ul> </li> </ul> <p>IMPORTANTE</p> <p>Los recursos son los datos o informaci\u00f3n que se pueden acceder a trav\u00e9s de la API. Los verbos HTTP son las operaciones que se pueden realizar en esos recursos, como obtener <code>GET</code> un recurso, crear <code>POST</code> un recurso, actualizar <code>PUT</code> un recurso o eliminar <code>DELETE</code> un recurso.</p> <p></p>"},{"location":"devcamp/checkpoint-06/que-es-una-api-py/#52-de-donde-obtiene-la-api-toda-la-informacion","title":"5.2. \u00bfDe donde obtiene la API toda la informaci\u00f3n?","text":"<p>La informaci\u00f3n de la api no sale de la nada, necesita ser construido por alguien en formato diccionario. Se puede construir de manera manual o cargarle la informaci\u00f3n desde una base de datos. Cuando abrimos la url donde esta alojado el API, veremos un monton de datos en formato diccionario <code>{...}</code>. Puede contener anidamientos tanto de diccionarios como de listas en su interior.</p> <p>Formato de una API \ud83d\udc47 <pre><code>{\n  \"id\": 1,\n  \"nombre\": \"Juan\",\n  \"apellido\": \"Garcia\",\n  \"pais\": \"Espa\u00f1a\"\n},\n{\n  \"id\": 2,\n  \"nombre\": \"Nerea\",\n  \"apellido\": \"Larralde\",\n  \"pais\": \"Espa\u00f1a\"\n}\n</code></pre></p> <p>TIP</p> <p>Puedes practicar con esta API de Rick and Morty https://rickandmortyapi.com/api/character/ utilizando la aplicaci\u00f3n Postman https://www.postman.com/ para testear con APIs.</p> <p>Si accede a <code>https://rickandmortyapi.com/api/character/131</code> por numero de id al personaje, nos devolvera un json con toda la informaci\u00f3n.</p> <p></p>"},{"location":"devcamp/checkpoint-06/que-es-una-api-py/#53-que-es-postman","title":"5.3. \u00bfQu\u00e9 es Postman?","text":"<p>Se trata de una herramienta dirigida a desarrolladores web que permite realizar peticiones HTTP a cualquier API. Postman es muy \u00fatil a la hora de programar y hacer pruebas, puesto que nos ofrece la posibilidad de comprobar el correcto funcionamiento de nuestros desarrollos.</p> <p>Con esto no queremos decir que Postman sea una herramienta exclusiva para profesionales del entorno web, de hecho va a ser muy \u00fatil para todo aquel que tenga que interactuar con una API.</p>"},{"location":"devcamp/checkpoint-06/que-es-una-api-py/#caracteristicas-principales","title":"Caracter\u00edsticas principales:","text":"<ul> <li> <p>Env\u00edo de solicitudes:</p> <ul> <li>Postman permite enviar solicitudes HTTP y HTTPS utilizando m\u00e9todos como GET, POST, PUT y DELETE, entre otros. Los desarrolladores pueden especificar par\u00e1metros, encabezados y el cuerpo de la solicitud para simular diversas interacciones con una API.</li> </ul> </li> <li> <p>Pruebas automatizadas:</p> <ul> <li>Con Postman, los desarrolladores pueden crear y ejecutar pruebas automatizadas para verificar el comportamiento de una API. Esto ayuda a detectar errores de manera temprana y a garantizar que el software cumpla con los est\u00e1ndares de calidad. </li> </ul> </li> </ul> <p>TIP</p> <p>API de testeo https://rickandmortyapi.com</p> <p> </p>"},{"location":"devcamp/checkpoint-07/","title":"Checkpoint 07","text":""},{"location":"devcamp/checkpoint-07/#documentacion-javascript","title":"Documentaci\u00f3n JavaScript","text":"<p>\u00cdNDICE CHECKPOINT 07</p> <ol> <li>\u00bfQu\u00e9 diferencia a Javascript de cualquier otro lenguaje de programaci\u00f3n?</li> <li>\u00bfCu\u00e1les son algunos tipos de datos JS?</li> <li>\u00bfCu\u00e1les son las tres funciones de String en JS?</li> <li>\u00bfQu\u00e9 es un condicional?</li> <li>\u00bfQu\u00e9 es un operador ternario?</li> <li>\u00bfCu\u00e1l es la diferencia entre una declaraci\u00f3n de funci\u00f3n y una expresi\u00f3n de funci\u00f3n?</li> <li>\u00bfQu\u00e9 es la palabra clave \"this\" en JS? </li> </ol>"},{"location":"devcamp/checkpoint-07/condicionales-js/","title":"4. \u00bfQu\u00e9 es un condicional?","text":"<p>Hasta ahora, hemos visto c\u00f3mo resolver los problemas m\u00e1s sencillos pero no podemos resolver todo utilizando estructuras secuenciales. Cuando tenemos que tomar una decisi\u00f3n aparecen las estructuras condicionales. Por ejemplo, en nuestra vida diaria hay momentos donde tenemos que decidir entre un pantal\u00f3n u otro, un camino u otro. En estos casos es com\u00fan resolver un problema combinando estructuras secuenciales y condicionales.</p> <p>JavaScript cuenta con 4 tipos de condicionales:</p> <ul> <li>Condicional if</li> <li>Condicional else</li> <li>Condicional else if</li> <li>Condicional switch </li> </ul>"},{"location":"devcamp/checkpoint-07/condicionales-js/#41-condicional-simple-con-if","title":"4.1. Condicional simple con if","text":"<p>Podemos ver un ejemplo de una estructura condicional simple con el siguiente esquema.</p> <p>IMPORTANTE</p> <p>Puedes usar if solo una vez por bloque y no es obligatorio complementarlo con else.</p> <p> </p> <p>Podemos observar en el esquema que el rombo representa la condici\u00f3n y tenemos dos opciones que podemos tomar. Si la condici\u00f3n devuelve un resultado verdadero, ejecutar\u00e1 las opciones que se encuentren en su interior, si por el contrario es falso, no realizar\u00e1 dicha acci\u00f3n.</p> <p>Vamos a ver el primer ejemplo y el mas simple con el if, le pasamos por variable <code>edad = 20</code>, si tiene 18 o mas a\u00f1os, muestra un mensaje <code>Soy mayor de edad porque tengo 18 o mas a\u00f1os.</code> y si tiene menos de 18 a\u00f1os, no nos muestra ningun mensaje.</p> ejemplo.js<pre><code>let edad = 20;\nif (edad &gt;= 18) {\n    console.log(`Soy mayor de edad porque tengo ${edad} o mas a\u00f1os.`)\n}\n</code></pre> <p>La palabra clave <code>if</code> implica el inicio de una condici\u00f3n, seguidamente incluimos la condici\u00f3n entre <code>()</code> par\u00e9ntesis y finalizamos la l\u00ednea con el car\u00e1cter <code>{</code> apertura de llave.</p> <p>Una de las caracter\u00edsticas de JavaScript que adem\u00e1s ayuda a tener una estructura organizada es la indentaci\u00f3n o sangrado de texto con dos o cuatro espacios. Es decir, si queremos incluir una condici\u00f3n, el texto que deba ir en su interior debe ir con cuatro espacios con respecto al inicio de la palabra <code>if</code>.</p>"},{"location":"devcamp/checkpoint-07/condicionales-js/#42-condicional-alternativa-con-if-else","title":"4.2. Condicional alternativa con if else","text":"<p>Podemos ver un ejemplo de una estructura condicional compuesta con el siguiente esquema.</p> <p>IMPORTANTE</p> <p>Puedes usar else solo una vez por condici\u00f3n if.</p> <p> </p> <p>Cuando se presenta una elecci\u00f3n entre if o else, tenemos la opci\u00f3n de realizar una acci\u00f3n u otra, es decir, tenemos operaciones diferentes a ejecutar si la condici\u00f3n es verdadera o es falsa. Es decir, se tomara una de las 2 elecciones de la bifurcaci\u00f3n.</p> <p>Vamos a volver a realizar el ejercicio anterior pero, con la diferencia, de que si la edad es menor a 18 a\u00f1os, nos muestre un mensaje <code>Soy menor de edad porque tengo menos de 18 a\u00f1os.</code>.</p> ejemplo.js<pre><code>edad = 16;\nif (edad &gt;= 18) {\n    console.log(`Soy mayor de edad porque tengo ${edad} o mas a\u00f1os.`)\n}\nelse {\n    console.log(`Soy menor de edad porque tengo menos de ${edad} a\u00f1os.`);\n}\n</code></pre> <p>Como podemos ver, si la condici\u00f3n es falsa, y queremos que realice una operaci\u00f3n, la forma ser\u00eda incluyendo la palabra <code>else</code> en una l\u00ednea nueva seguida del car\u00e1cter <code>{</code> apertura de llave. Despu\u00e9s las operaciones necesarias que queramos ejecutar separadas con 4 espacios con respecto a la l\u00ednea de la palabra <code>else</code>. Despues de la operaci\u00f3n y en una nueva l\u00ednea, toca cerrar <code>}</code> la llave y con eso, finaliza el bloque <code>else</code>.</p>"},{"location":"devcamp/checkpoint-07/condicionales-js/#43-condicional-encadenada-con-if-else-if-else","title":"4.3. Condicional encadenada con if else if else","text":"<p>Podemos ver un ejemplo de una estructura condicional encadenada con el siguiente esquema.</p> <p>IMPORTANTE</p> <p>El flujo de ejecucci\u00f3n se prioriza siempre de arriba hacia abajo y puedes crear tantas else if que desees.</p> <p> </p> <p>Cuando se presentan mas de dos elecci\u00f3nes a elegir entre <code>if</code> <code>else if</code> y <code>else</code>, se tomara como v\u00e1lida, solamente una de las 3 elecciones de la bifurcaci\u00f3n. El flujo de ejecuci\u00f3n se priorizara siempre de arriba hacia abajo.</p> <p>Vamos a volver a realizar el ejercicio anterior con una condici\u00f3nal mas, que sera la condicional <code>else if</code>, pero con la diferencia, de que si la edad es mayor o igual a 67 a\u00f1os, nos muestre un mensaje <code>Tengo 70 a\u00f1os y estoy jubilado.</code>. El resto de las condicionales se mantienen igual.</p> ejemplo.js<pre><code>let edad = 36;\n\nif (edad &gt;= 67) {\n    console.log(`Tengo ${edad} a\u00f1os y estoy jubilado.`);\n}\nelse if (edad &gt;= 18) {\n    console.log(`Soy mayor de edad porque tengo ${edad} o mas a\u00f1os.`)\n}\nelse {\n    console.log(`Soy menor de edad porque tengo menos de ${edad} a\u00f1os.`);\n}\n</code></pre> <p>Como vemos en el ejempo anterior, el uso de la condicional else if, nos da la posibilidad de crear muchas condiciones sobre un mismo if ya que su uso no esta limitado. Recuerda que cuanto mas corto y menos condicionales tenga el bloque, mas legible sera el c\u00f3digo.</p>"},{"location":"devcamp/checkpoint-07/condicionales-js/#44-condicionales-anidadas","title":"4.4. Condicionales anidadas","text":"<p>Podemos ver un ejemplo de una estructura condicional anidado con el siguiente esquema.</p> <p>IMPORTANTE</p> <p>Podemos tener infinidad de condiciones anidadas pero en la medida de lo posible, procuraremos anidar lo menos posible.</p> <p> </p>"},{"location":"devcamp/checkpoint-07/condicionales-js/#45-condicional-switch","title":"4.5. Condicional switch","text":"<p>La estructura de control switch permite definir casos espec\u00edficos a realizar cuando la variable expuesta como condici\u00f3n sea igual a los valores que se especifican a continuaci\u00f3n mediante cada case:.</p> <p>Las sentencias switch no ser\u00e1n apropiadas para usar en todas las situaciones. Pero si sientes que las sentencias else if son largas y complicadas, entonces una sentencia switch podr\u00eda ser una opci\u00f3n alternativa. Aunque, mucha gente opina que en lugar de mejorar la legibilidad, normalmente la empeora.</p> <p>Veamos un ejemplo de c\u00f3mo se utiliza:</p> ejemplo.js<pre><code>let numero = 88734;\n\nswitch (numero) {\n    case 00003:\n        console.log('\u00a1Primer premio!');\n        break;\n    case 00012:\n        console.log('\u00a1Segundo premio!');\n        break;\n    case 88734:\n        console.log('\u00a1Tercer premio!');\n        break;\n    // con default, toma la salida de cualquier otra opci\u00f3n\n    default:\n        console.log(`El n\u00famero ${numero} no tiene premio`);\n        break;\n}\n</code></pre> <p>El valor de la variable (<code>numero</code>) es 88734, toma la salida (<code>case 88734</code>) con el mensaje \u00a1Tercer premio!</p> <ul> <li>switch: Se define el tipo de condici\u00f3n que debe cumplir, en este caso, compara el valor de la variable con la opci\u00f3n.</li> <li>case 00003: Es la primera opci\u00f3n, si cumple la condici\u00f3n, toma la salida y sale con el break, si no cumple, continua</li> <li>case 00012: Es la segunda opci\u00f3n, si cumple la condici\u00f3n, toma la salida y sale con el break, si no cumple, continua</li> <li>case 88734: Es la tercera opcion, si cumple la condici\u00f3n, toma la salida y sale con el break, si no cumple, continua</li> <li>default: Si no cumple con ninguna condicion anterior, toma la salida con el mensaje (<code>El n\u00famero (?) no tiene premio</code>) y sale con el break</li> </ul> <p> </p>"},{"location":"devcamp/checkpoint-07/declaracion-de-funcion-vs-expresion-de-funcion-js/","title":"6. \u00bfCu\u00e1l es la diferencia entre una declaraci\u00f3n de funci\u00f3n y una expresi\u00f3n de funci\u00f3n?","text":"<p>JavaScript al ser un lenguaje din\u00e1mico, tiene ciertos mecanismos para garantizar que la ejecuci\u00f3n de nuestro c\u00f3digo sea la m\u00e1s \u00f3ptima y correcta.</p> <p>Tenemos dos maneras principales de definir funciones:</p> <ul> <li>Podemos definir una funci\u00f3n declarando </li> <li>Podemos definir una funci\u00f3n como una expresi\u00f3n</li> </ul> <p>Veamos un ejemplo para compararlos:</p> ejemplo.js<pre><code>// Declaracion de funcion\nfunction saludar() {\n    console.log('Hola');\n}\n\n// Expresion de funcion\nlet saludar = function() {\n    console.log('Hola');\n};\n</code></pre>"},{"location":"devcamp/checkpoint-07/declaracion-de-funcion-vs-expresion-de-funcion-js/#analicemos-las-diferencias","title":"\ud83d\udd75\ufe0f Analicemos las diferencias","text":"<p>Declaraci\u00f3n de funci\u00f3n:</p> <ul> <li>S\u00f3lo es visible dentro del bloque de c\u00f3digo en el que reside, por ejemplo dentro de un <code>if</code></li> <li>JavaScript precarga todas las funciones declaradas al inicio y puede llamarse antes o despues de la funci\u00f3n</li> </ul> <p>Expresi\u00f3n de funci\u00f3n:</p> <ul> <li>Es visible dentro y fuera del bloque de c\u00f3digo en el que reside pudiendo declarar una variable fuera del bloque</li> <li>Se define dentro de una variable como una expresi\u00f3n normal, por eso lleva <code>;</code> punto y coma al final de la funci\u00f3n</li> <li>Solo puede llamarse despues de la funci\u00f3n, si se llama antes de la funci\u00f3n tira error de (variable no est\u00e1 definida)</li> </ul> <p>Las diferencias de sintaxis son claras.</p> <p>Veamos el mismo ejemplo anterior, agregando una llamada antes de la funci\u00f3n:</p> ejemplo.js<pre><code>// Declaracion de funcion\nsaludar() // Salida: Hola\n\nfunction saludar() {\n    console.log('Hola');\n}\n\n// Expresion de funcion\nsaludar(); // Error: saludar no est\u00e1 definida\n\nlet saludar = function() {\n    console.log('Hola');\n};\n</code></pre> <p>En el caso de expresi\u00f3n de funci\u00f3n nos da el error de (variable no est\u00e1 definida), cosa que en la declaraci\u00f3n de funci\u00f3n no ocurre gracias a la precarga de las declaraciones al inicio.</p> <p>IMPORTANTE</p> <p>En las expresiones de funciones darle nombre a la funci\u00f3n es opcional. En cambio para las declaraciones es obligatorio.</p> <p>No hay una forma mejor o peor de declarar funciones, lo bueno es conocer las herramientas que tenemos, sus implicaciones y saber cuando podemos usarlas para crear c\u00f3digo legible y limpio.</p> <p>Veamos un ejemplo mas completo:</p> ejemplo.js<pre><code>// Expresion de funcion\nlet edad = 32;\nlet entradaCasino;\n\nif (edad &gt;= 18) {\n    entradaCasino = function() {\n        console.log('Puedes entrar al casino');\n    };\n}\nelse {\n    entradaCasino = function() {\n        console.log('No puedes entrar al casino');\n    };\n}\n\nentradaCasino(); // Salida: Puedes entrar al casino\n</code></pre> <p>Con la expresion de funcion, podemos llamar a cualquier funci\u00f3n este donde este. Gracias a la variable entradaCasino, nos permite ver la funci\u00f3n an\u00f3nima dentro del bloque if desde el exterior.  </p>"},{"location":"devcamp/checkpoint-07/introduccion-js/","title":"1. \u00bfQu\u00e9 diferencia a Javascript de cualquier otro lenguaje de programaci\u00f3n?","text":"<p>JavaScript es un lenguaje de programaci\u00f3n b\u00e1sico para la creaci\u00f3n de sitios web din\u00e1micos e interactivos. Se usa en navegadores, servidores y aplicaciones para mejorar la experiencia del usuario. Aunque se llama JavaScript, no debe confundirse con Java.</p> <p>Su principal ventaja es que se ejecuta directamente en el navegador del usuario, sin necesidad de compilar el c\u00f3digo previamente.</p> <p>El flujo de ejecuci\u00f3n es la siguiente:</p> <ol> <li>El navegador carga el c\u00f3digo JavaScript en una web</li> <li>El motor de JavaScript lo interpreta y ejecuta</li> <li>Interact\u00faa con el DOM (Document Object Model), que modifica elementos HTML en tiempo real</li> <li>Puede comunicarse con servidores mediante AJAX o Fetch API para obtener y enviar datos sin recargar la p\u00e1gina</li> <li>Maneja eventos como clics de botones para mejorar la interactividad  </li> </ol> <p>Veamos el siguiente ejemplo:</p> <ol> <li>Pulsa el bot\u00f3n</li> <li>Escucha el evento click</li> <li>Ejecuta la funci\u00f3n</li> <li>Cambia el texto del bot\u00f3n</li> </ol> ejemplo.html<pre><code>&lt;!-- crea un boton que pone Start --&gt;\n&lt;button class=\"btn-start\"&gt;Start&lt;/button&gt;\n</code></pre> ejemplo.js<pre><code>// captura el elemento DOM\nconst btnStart = document.querySelector('.btn-start');\n\n// captura el evento\nbtnStart.addEventListener('click', changeText);\n\n// funci\u00f3n para cambiar el texto del boton\nfunction changeText() {\n    btnStart.innerHTML = 'Texto cambiado';\n}\n</code></pre> <p>An\u00e1lisis del c\u00f3digo:</p> <p>Revisa lo que hace el c\u00f3digo, desde ejemplo.js captura el objeto DOM del ejemplo.html y para ello, hace referencia a la clase \"btn-start\". Una vez capturado el objeto DOM, lo guarda en una variable llamada btnStart para luego poner en escucha y capturar el evento 'click', para llamar a la funci\u00f3n changeText.  </p> <p>Cuando se aprende JavaScript, es esencial entender la relaci\u00f3n entre HTML, CSS y JavaScript, y c\u00f3mo se unen para mostrar un sitio web. Aunque la mayor\u00eda de las aplicaciones de JavaScript son del lado del cliente (FRONTEND), este lenguaje tambi\u00e9n es \u00fatil en aplicaciones del lado del servidor (BACKEND), como la creaci\u00f3n de servidores web.</p> <p>Caracter\u00edsticas de JavaScript:</p> <ul> <li>Multiparadigma: Soporta programaci\u00f3n orientada a objetos, funcional e imperativa</li> <li>Din\u00e1mico y flexible: No requiere declaraci\u00f3n expl\u00edcita de tipos de datos</li> <li>Basado en eventos: Responde a interacciones del usuario</li> <li>Compatible con todos los navegadores: Funciona en cualquier navegador moderno</li> <li>As\u00edncrono y concurrente: Permite manejar tareas en paralelo con promesas y async/await</li> </ul> <p>Ventajas</p> <ul> <li>Es f\u00e1cil de aprender y usar.</li> <li>Se ejecuta en el navegador, sin necesidad de compilaci\u00f3n</li> <li>Amplia compatibilidad con diferentes plataformas</li> <li>Ecosistema extenso con miles de librer\u00edas y frameworks</li> <li>Soporte para desarrollo full-stack con Node.js</li> </ul> <p>Desventajas</p> <ul> <li>Manejo de errores menos estricto comparado con otros lenguajes</li> <li>Uso excesivo puede afectar el rendimiento de una p\u00e1gina web</li> </ul> <p></p>"},{"location":"devcamp/checkpoint-07/introduccion-js/#11-sintaxis-de-javascript","title":"1.1. Sintaxis de JavaScript","text":"<p>JavaScript tiene una serie de normas b\u00e1sicas de sintaxis que debemos seguir.</p> <p>Variables:</p> <p>puedes declarar variables usando las palabras clave <code>var</code>, <code>const</code> o <code>let</code>.</p> <ul> <li><code>let</code> Permite declarar variables limitando su alcance al bloque, fuera de ella no tiene efecto</li> <li><code>const</code> Son como las <code>let</code>, solo que su valor no cambiara a lo largo del programa</li> <li><code>var</code> Permite declarar variables con alcance dentro y fuera del bloque, se entienden como globales.</li> </ul> <p>IMPORTANTE</p> <p>No se recomienda el uso de <code>var</code> en Javascript, porque puede dar lugar a problemas y confusiones.</p> <p>Punto y coma para finalizar sentencias:</p> <p>En JavaScript, cada instrucci\u00f3n generalmente termina con un <code>;</code> punto y coma. Es una buena pr\u00e1ctica usar el punto y coma siempre. De lo contrario, puede dar errores.</p> <p>Instrucciones y ejecuci\u00f3n secuencial:</p> <p>En JavaScript, el c\u00f3digo est\u00e1 compuesto por instrucciones que se ejecutan de forma secuencial. Esto significa que las instrucciones se ejecutan una tras otra, de arriba hacia abajo, en el orden en que aparecen.</p> <p>Llaves para delimitar bloques de c\u00f3digo:</p> <p>Las llaves <code>{}</code> en JavaScript se utilizan para definir bloques de c\u00f3digo, especialmente en estructuras de control como funciones, bucles o condiciones.</p> <p>Sensibilidad a may\u00fasculas y min\u00fasculas:</p> <p>JavaScript es un lenguaje que diferencia entre may\u00fasculas y min\u00fasculas (case-sensitive). Esto significa que distingue entre nombre, Nombre y NOMBRE, consider\u00e1ndolos variables diferentes.</p>"},{"location":"devcamp/checkpoint-07/introduccion-js/#buenas-practicas-al-nombrar-variables","title":"<p>Buenas pr\u00e1cticas al nombrar variables:</p>","text":"<ul> <li>Aunque JavaScript no lo exige, es de buena pr\u00e1ctica utilizar camelCase para nombrar variables</li> <li>Una variable no puede comenzar con un n\u00famero.</li> <li>Un nombre de variable no puede contener espacios.</li> <li>No pueden incluir s\u00edmbolos especiales como (!, @, #, %) a excepci\u00f3n del guion bajo (_) y el s\u00edmbolo de d\u00f3lar ($).</li> </ul>"},{"location":"devcamp/checkpoint-07/introduccion-js/#algunas-palabras-reservadas","title":"<p>Algunas palabras reservadas:</p>","text":"<ul> <li>Control de flujo: if, else, switch, case, default</li> <li>Ciclos: for, while, do, break, continue</li> <li>Declaraci\u00f3n de variables y funciones: var, let, const, function, return</li> <li>Manipulaci\u00f3n de objetos y clases: class, extends, constructor, super</li> <li>Valores especiales: null, undefined, true, false</li> <li>Operaciones asincr\u00f3nicas: async, await</li> <li>Operadores de importaci\u00f3n/exportaci\u00f3n: import, export</li> <li>Operadores l\u00f3gicos y aritm\u00e9ticos: new, delete, typeof, instanceof</li> </ul> <p>PRECAUCI\u00d3N</p> <p>Estas palabras son utilizadas por el lenguaje para funciones espec\u00edficas y su uso como nombres provocar\u00e1 errores.</p> <p></p>"},{"location":"devcamp/checkpoint-07/introduccion-js/#12-comentarios-en-javascript","title":"1.2. Comentarios en JavaScript","text":"<p>Su prop\u00f3sito es proporcionar explicaciones o notas para los desarrolladores que leen el c\u00f3digo. En JavaScript, los comentarios pueden ser de dos tipos.</p> <ul> <li>Comentarios de una sola l\u00ednea</li> <li>Comentarios de varias l\u00edneas </li> </ul>"},{"location":"devcamp/checkpoint-07/introduccion-js/#comentarios-de-una-sola-linea","title":"Comentarios de una sola l\u00ednea:","text":"<p>Los comentarios de una sola l\u00ednea comienzan con dos barras inclinadas (<code>//</code>). Todo el texto que sigue a estas barras en la misma l\u00ednea es considerado un comentario y es ignorado por el int\u00e9rprete de JavaScript.</p> ejemplo.js<pre><code>// Este es un comentario de una sola l\u00ednea\nlet nombre = \"Roberto\"; // Tambi\u00e9n se puede usar al final de una l\u00ednea de c\u00f3digo\n</code></pre>"},{"location":"devcamp/checkpoint-07/introduccion-js/#comentarios-de-varias-lineas","title":"Comentarios de varias l\u00edneas:","text":"<p>Los comentarios de varias l\u00edneas se encierran entre <code>/*</code> y <code>*/</code>. Todo el texto dentro de estos delimitadores es considerado un comentario y es ignorado por el int\u00e9rprete.</p> <p>ejemplo.js<pre><code>/*\nEste es un comentario de varias l\u00edneas.\nPuede abarcar m\u00faltiples l\u00edneas.\nEs \u00fatil para explicaciones m\u00e1s largas o para desactivar bloques de c\u00f3digo.\n*/\nlet edad = 36;\n</code></pre> </p>"},{"location":"devcamp/checkpoint-07/introduccion-js/#13-como-usar-la-consola-en-javascript","title":"1.3. C\u00f3mo usar la consola en JavaScript","text":"<p>En JavaScript la consola se usa cont\u00ednuamente. El m\u00e9todo mas utilizado es <code>console.log</code>. Su prop\u00f3sito principal es imprimir informaci\u00f3n en la consola.</p> <p>Veamos el siguiente ejemplo:</p> ejemplo.js<pre><code>let mensaje = '\u00a1Hola mundo!';\n\n// varios ejemplos de salida:\nconsole.log(mensaje); // \u00a1Hola mundo!\nconsole.log(`Este es mi primer ${mensaje}`); // Este es mi primer \u00a1Hola mundo!\n</code></pre> <p>Esto es \u00fatil para verificar que las variables contienen los valores esperados y que el flujo de ejecuci\u00f3n es el correcto. </p>"},{"location":"devcamp/checkpoint-07/introduccion-js/#14-como-usar-la-ventana-emergente-en-javascript","title":"1.4. C\u00f3mo usar la ventana emergente en JavaScript","text":"<p>En JavaScript la ventana emergente se usa cont\u00ednuamente. El m\u00e9todo mas utilizado es <code>alert</code>. Su prop\u00f3sito principal es imprimir informaci\u00f3n en la ventana emergente.</p> <p>Veamos el siguiente ejemplo:</p> ejemplo.js<pre><code>let mensaje = '\u00a1Hola mundo!';\n\n// varios ejemplos de salida:\nalert(mensaje) // \u00a1Hola mundo!\nalert(`Este es mi primer ${mensaje}`); // Este es mi primer \u00a1Hola mundo!\n</code></pre> <p>Esto es \u00fatil para verificar que las variables contienen los valores esperados y que el flujo de ejecuci\u00f3n es el correcto. </p>"},{"location":"devcamp/checkpoint-07/introduccion-js/#15-indentacion-de-codigo","title":"1.5. Indentaci\u00f3n de c\u00f3digo","text":"<p>A medida que escribimos l\u00edneas de c\u00f3digo en nuestro programa, este se ir\u00e1 complicando y nos tomar\u00e1 m\u00e1s tiempo leer lo que hemos hecho y comprobar si hay errores o buscar como solucionarlos. Sin embargo, para mejorar la rapidez con la que leemos y entendemos el c\u00f3digo, una buena pr\u00e1ctica es usar la indentaci\u00f3n.</p> <p>A la hora de indentar c\u00f3digo hay dos opciones:</p> <ul> <li>Usar espacios</li> <li>Usar tabuladores</li> </ul> <p>Utilizar una u otra estrategia de tabulaci\u00f3n depende del programador, pero lo importante es siempre utilizar la misma. En mis ejemplos, suelo utilizar indentaci\u00f3n a 4 espacios porque me resulta m\u00e1s pr\u00e1ctico leer.  </p>"},{"location":"devcamp/checkpoint-07/operador-ternario-js/","title":"5. \u00bfQu\u00e9 es un operador ternario?","text":"<p>El operador ternario es una forma abreviada de la estructura if...else y es \u00fatil cuando queremos tomar decisiones basadas en una condici\u00f3n.</p> <p>Se compone de tres partes:</p> <ul> <li>Una expresi\u00f3n condicional</li> <li>Una expresi\u00f3n que se eval\u00faa si la condici\u00f3n es verdadera</li> <li>Una expresi\u00f3n que se eval\u00faa si la condici\u00f3n es falsa</li> </ul> <p>La sintaxis b\u00e1sica del operador ternario es la siguiente:</p> ejemplo.js<pre><code>condicion ? expresion_verdadera : expresion_falsa\n</code></pre> <ul> <li>condicion: Una expresi\u00f3n que se eval\u00faa como verdadera o falsa</li> <li>expresion_verdadera: La expresi\u00f3n que se ejecutar\u00e1 si condicion es verdadera</li> <li>expresion_falsa: La expresi\u00f3n que se ejecutar\u00e1 si condicion es falsa</li> </ul> ejemplo.js<pre><code>const edad = 36;\n\nconst mensaje = edad &gt;= 18 ? 'Eres mayor de edad' : 'Eres menor de edad';\n\nconsole.log(mensaje); // Salida: Eres mayor de edad\n</code></pre>"},{"location":"devcamp/checkpoint-07/operador-ternario-js/#51-anidamiento-de-operadores-ternarios","title":"5.1. Anidamiento de operadores ternarios","text":"<p>Es posible anidar operadores ternarios para expresiones condicionales m\u00e1s complejas. Los operadores ternarios encadenados (o anidados) hacen que el c\u00f3digo sea imposible de leer en algunos casos. Lo ideal seria usar switch/case o if/else en su lugar.</p> <p>Veamos un ejemplo:</p> ejemplo.js<pre><code>const calificacion = 8;\n\nconst resultado = calificacion &lt;   5 ? 'Suspenso' :\n                  calificacion &lt;   7 ? 'Aprobado' :\n                  calificacion &lt;   9 ? 'Notable' :\n                  calificacion &lt;  10 ? 'sobresaliente' :\n                  calificacion == 10 ? 'Matr\u00edcula de honor' :\n                                       'Introduzca un n\u00famero del 0 al 10';\n\nconsole.log(resultado); // Salida: Notable\n</code></pre> <p>IMPORTANTE</p> <p>Es importante mantener la legibilidad del c\u00f3digo al hacerlo.</p> <p> </p>"},{"location":"devcamp/checkpoint-07/que-es-this-js/","title":"7. \u00bfQu\u00e9 es la palabra clave \"this\" en JS?","text":"<p>Una de las caracter\u00edsticas de JavaScript que m\u00e1s confusi\u00f3n genera es la palabra clave this. M\u00e1s concretamente a qu\u00e9 o qui\u00e9n hace referencia y en qu\u00e9 circunstancias.</p> <p>this es una palabra clave que se utiliza mucho dentro de las clases para hacer referencia al objeto instanciado. Cuando se crea una funci\u00f3n dentro de una clase, esta funci\u00f3n  pasa a llamarse m\u00e9todo. El primer m\u00e9todo siempre sera el constructor, se encarga de declarar atributos, el this hace referencia a cualquier atributo que se le pase dentro de esa misma clase. si se utilizara fuera de \u00e9sta clase, ar\u00eda referencia a otra cosa.</p> <p>Veamos un ejemplo de clase:</p> <p>ejemplo.js<pre><code>class Cliente {\n\n    provincia = 'Guipuzcoa'; // atributo global / variable de clase\n\n    constructor(nombre, apellido, telefono) {\n        this.nombre = nombre;\n        this.apellido = apellido;\n        this.telefono = telefono;\n    }\n\n    datos() {\n        return 'Nombre: ' + this.nombre + '\\n' +\n               'Apellido: ' + this.apellido + '\\n' +\n               'Tel\u00e9fono: ' + this.telefono + '\\n' +\n               'Provincia: ' + this.provincia;\n    }\n}\n\nconst cli_1 = new Cliente('Nerea', 'Zelaieta', '666-666-666');\nconst cli_2 = new Cliente('Roberto', 'Mendiburu', '333-666-666');\n\nconsole.log(cli_1.datos());\nconsole.log(cli_2.datos());\n\n/*\nSalida: Nombre: Nerea\n        Apellido: Zelaieta\n        Tel\u00e9fono: 666-666-666\n        Provincia: Guipuzcoa\n        Nombre: Roberto\n        Apellido: Mendiburu\n        Tel\u00e9fono: 333-666-666\n        Provincia: Guipuzcoa\n*/\n</code></pre> </p> <p>Veamos un ejemplo de objeto:</p> ejemplo.js<pre><code>const usuario = {\n    nombre: 'Roberto',\n    apellido: 'Mendiburu',\n    telefono: '333-666-666',\n\n    mostrar() {\n        console.log(this);\n    }\n};\n\nusuario.mostrar();\n\n/*\nSalida: Nombre: Roberto\n        Apellido: Mendiburu\n        Tel\u00e9fono: 333-666-666\n        mostrar: [Function: mostrar]\n*/\n</code></pre> <p>Cuando se crea una funci\u00f3n dentro de un objeto, esta funci\u00f3n  pasa a llamarse m\u00e9todo. El this hace referencia al objeto que lo envuelve. La ejecuci\u00f3n de este c\u00f3digo nos imprime el objeto completo que el this hace referencia.  </p> <p>Veamos un ejemplo simple:</p> ejemplo.js<pre><code>function usuario() {\n    console.log(this);\n}\n\nconsole.log(usuario()); // Object [global]\n\n/*\nSalida: Object [global]\n*/\n</code></pre> <p>Hace referencia al objeto global.</p> <p> </p>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/","title":"2. \u00bfCu\u00e1les son algunos tipos de datos JS?","text":"<p>Los tipos de datos en JavaScript son atributos que determinan el tipo de valor que puede contener una variable. Estos tipos de datos son utilizados para representar diferentes tipos de informaci\u00f3n.</p> <p>JavaScript es un lenguaje de programaci\u00f3n de tipado din\u00e1mico, lo que significa que no es necesario declarar expl\u00edcitamente el tipo de una variable al momento de su creaci\u00f3n. Pero eso no significa que JavaScript no tenga tipos. Simplemente el tipo se determina autom\u00e1ticamente cuando se asigna un valor. </p>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/#21-tipos-de-datos-primitivos","title":"2.1. Tipos de datos primitivos","text":"<p>Los tipos de datos primitivos son aquellos que representan valores individuales y no tienen m\u00e9todos o propiedades. Son inmutables, lo que significa que no se pueden cambiar una vez que se han creado.</p> <ul> <li>Cadena de texto (string)</li> <li>N\u00fameros (number)</li> <li>Booleano (boolean)</li> <li>Valor null</li> <li>Valor undefined </li> </ul>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/#string","title":"string:","text":"<p>El tipo de datos <code>string</code> representa una secuencia de caracteres, como texto o palabras. Las cadenas se deben encerrar entre comillas simples <code>' '</code> o dobles <code>\" \"</code>.</p> <pre><code>let nombre = 'Roberto';\nlet mensaje = \"\u00a1Hola mundo!\";\n</code></pre>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/#number","title":"number:","text":"<p>El tipo de datos <code>number</code> en JavaScript representa tanto n\u00fameros enteros como de punto flotante.</p> <pre><code>let edad = 36;\nlet precio = 99.95;\n</code></pre>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/#boolean","title":"boolean:","text":"<p>El tipo de datos <code>boolean</code> representa un valor de verdad, que puede ser <code>true</code> (verdadero) o <code>false</code> (falso). Es \u00fatil en expresiones condicionales y l\u00f3gicas.</p> <pre><code>let esHombre = true;\nlet esMujer = false;\n</code></pre>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/#null","title":"null:","text":"<p>En JavaScript, <code>null</code> es un valor especial que representa la ausencia intencional de cualquier objeto o valor.</p> <pre><code>let Unidades = null;\n</code></pre>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/#undefined","title":"undefined:","text":"<p>El valor <code>undefined</code> indica que una variable ha sido declarada pero a\u00fan no se le ha asignado ning\u00fan valor.</p> <p><pre><code>let unidades;\nconsole.log(unidades); // Salida: undefined\n</code></pre> </p>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/#22-tipos-de-datos-compuestos","title":"2.2. Tipos de datos compuestos","text":"<p>Los tipos de datos compuestos en JavaScript son aquellos que pueden contener m\u00faltiples valores y tienen m\u00e9todos y propiedades. Son mutables, lo que significa que pueden cambiar despu\u00e9s de su creaci\u00f3n.</p> <ul> <li>Arrays (array)</li> <li>Objetos (object) </li> </ul>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/#array","title":"array:","text":"<p>Los arrays en JavaScript son objetos especiales que permiten almacenar m\u00faltiples valores en una sola variable, indexados num\u00e9ricamente.</p> <pre><code>let animales = ['perro', 'oveja', 'caballo'];\n</code></pre>"},{"location":"devcamp/checkpoint-07/tipos-de-datos-js/#object","title":"object:","text":"<p>Los objetos en JavaScript son colecciones de pares clave-valor, donde la clave es una cadena (o s\u00edmbolo) y el valor puede ser cualquier tipo de dato, incluidos otros objetos.</p> <p><pre><code>let persona = {\n    nombre: 'Roberto',\n    edad: 36,\n    casado: true\n};\n</code></pre> </p>"},{"location":"devcamp/checkpoint-07/tres-funciones-de-string-js/","title":"3. \u00bfCu\u00e1les son las tres funciones de String en JS?","text":"<p>JavaScript ofrece numerosas funciones predefinidas que facilitan el trabajo con cadenas de texto (string). Entre las posibilidades que ofrecen estas funciones tenemos el <code>replace()</code>, <code>toLowerCase()</code>, <code>toUpperCase()</code>, etc.</p>"},{"location":"devcamp/checkpoint-07/tres-funciones-de-string-js/#replace","title":"replace():","text":"<p>El m\u00e9todo .replace acepta dos argumentos: la cadena que se reemplazar\u00e1 y con qu\u00e9 se reemplazar\u00e1 la cadena. Las cadenas en JavaScript son inmutables, el m\u00e9todo <code>replace()</code> no cambia el valor de la cadena especificada, nos devuelve un nuevo valor.</p> ejemplo.js<pre><code>let nombre = 'Roberto@gmail.com';\n\nlet resultado = nombre.replace('@gmail.com', '');\n\nconsole.log(resultado); // Salida: Roberto\nconsole.log(nombre); // Salida: Roberto@gmail.com\n</code></pre>"},{"location":"devcamp/checkpoint-07/tres-funciones-de-string-js/#tolowercase","title":"toLowerCase():","text":"<p>Las cadenas en JavaScript son inmutables, el m\u00e9todo <code>toLowerCase()</code> no cambia el valor de la cadena especificada, nos devuelve un nuevo valor.</p> ejemplo.js<pre><code>let nombre = 'Roberto';\n\nlet resultado = nombre.toLowerCase();\n\nconsole.log(resultado); // Salida: roberto\nconsole.log(nombre); // Salida: Roberto\n</code></pre>"},{"location":"devcamp/checkpoint-07/tres-funciones-de-string-js/#touppercase","title":"toUpperCase():","text":"<p>Las cadenas en JavaScript son inmutables, el m\u00e9todo <code>toUpperCase()</code> no cambia el valor de la cadena especificada, nos devuelve un nuevo valor.</p> <p>ejemplo.js<pre><code>let nombre = 'Roberto';\n\nlet resultado = nombre.toUpperCase();\n\nconsole.log(resultado); // Salida: ROBERTO\nconsole.log(nombre); // Salida: Roberto\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/","title":"Checkpoint 08","text":""},{"location":"devcamp/checkpoint-08/#documentacion-javascript","title":"Documentaci\u00f3n JavaScript","text":"<p>\u00cdNDICE CHECKPOINT 08</p> <ol> <li>\u00bfQu\u00e9 tipo de bucles hay en JS?</li> <li>\u00bfCu\u00e1les son las diferencias entre const, let y var?</li> <li>\u00bfQu\u00e9 es una funci\u00f3n de flecha?</li> <li>\u00bfQu\u00e9 es la deconstrucci\u00f3n de variables?</li> <li>\u00bfQu\u00e9 hace el operador de extensi\u00f3n en JS?</li> <li>\u00bfQu\u00e9 es la programaci\u00f3n orientada a objetos?</li> <li>\u00bfQu\u00e9 es una promesa en JS?</li> <li>\u00bfQu\u00e9 hacen async y await por nosotros? </li> </ol>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/","title":"3. \u00bfQu\u00e9 es una funci\u00f3n de flecha?","text":"<p>Las funciones flecha permiten escribir funciones de manera m\u00e1s concisa y legible, especialmente cuando se trata de funciones cortas o funciones de una sola l\u00ednea.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#sintaxis-de-una-funcion-flecha","title":"Sintaxis de una funci\u00f3n flecha:","text":"<ul> <li> <p>La sintaxis b\u00e1sica de una funci\u00f3n flecha es la siguiente: () =&gt; {}</p> <ul> <li>() Se utiliza para pasarle atributos a una funci\u00f3n</li> <li>=&gt; Se define como funci\u00f3n flecha, es una funci\u00f3n an\u00f3nima sin nombre</li> <li>{} Se utiliza para envolver el cuerpo de la funci\u00f3n  </li> </ul> </li> <li> <p>Las funci\u00f3nes flecha, pueden ser de varios tipos:</p> <ul> <li>Multil\u00ednea</li> <li>Monol\u00ednea</li> </ul> </li> </ul> <p> Una funci\u00f3n flecha es simplemente una expresi\u00f3n de funci\u00f3n compacta frente a una expresi\u00f3n de funci\u00f3n tradicional. A diferencia de una declaraci\u00f3n de funci\u00f3n, las de expresi\u00f3n de funci\u00f3n siempre deben acabar en punto y coma.</p> <p></p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#31-tipos-de-funciones","title":"3.1. Tipos de funci\u00f3nes:","text":"<p>Antes de nada, veamos una comparativa entre diferentes tipos de funciones, esto es de vital importancia para entender como funciona cada uno, en que se relacionan y en que situaciones es conveniente utilizar uno u otro.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-1","title":"Ejemplo 1","text":"<p>En este ejemplo, vamos a comparar 4 tipos de funci\u00f3n equivalentes y ver en que se diferencian. Para ello, hemos utilizado una declaraci\u00f3n de funci\u00f3n, una expresi\u00f3n de funci\u00f3n, una expresi\u00f3n de funci\u00f3n flecha y una expresi\u00f3n de funci\u00f3n flecha conciso. Ninguno incluye atributos.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#declaracion-de-funcion-multilinea-llamada","title":"Declaraci\u00f3n de funci\u00f3n (multil\u00ednea) + llamada:","text":"<ul> <li>Si no contiene atributos, los par\u00e9ntesis estar\u00e1n vac\u00edos, pero deben estar presentes.</li> <li>Al ser una funci\u00f3n multil\u00ednea, las llaves deben estar presentes.</li> <li>Al ser una declaraci\u00f3n de funci\u00f3n, no lleva punto y coma al final.</li> </ul> <pre><code>function cliente() {\n    console.log('\u00a1Bienvenido!');\n}\n\ncliente(); // Salida: \u00a1Bienvenido!\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#expresion-de-funcion-multilinea-llamada","title":"Expresi\u00f3n de funci\u00f3n (multil\u00ednea) + llamada:","text":"<ul> <li>Si no contiene atributos, los par\u00e9ntesis estar\u00e1n vac\u00edos, pero deben estar presentes.</li> <li>Al ser una funci\u00f3n multil\u00ednea, las llaves deben estar presentes.</li> <li>Al ser una expresi\u00f3n de funci\u00f3n, lleva punto y coma al final.</li> </ul> <pre><code>const cliente = function() {\n    console.log('\u00a1Bienvenido!');\n};\n\ncliente(); // Salida: \u00a1Bienvenido!\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#expresion-de-funcion-flecha-multilinea-llamada","title":"Expresi\u00f3n de funci\u00f3n flecha (multil\u00ednea) + llamada:","text":"<ul> <li>Si no contiene atributos, los par\u00e9ntesis estar\u00e1n vac\u00edos, pero deben estar presentes.</li> <li>Al ser una funci\u00f3n multil\u00ednea, las llaves deben estar presentes.</li> <li>Al ser una expresi\u00f3n de funci\u00f3n, lleva punto y coma al final.</li> </ul> <pre><code>const cliente = () =&gt; {\n    console.log('\u00a1Bienvenido!');\n};\n\ncliente(); // Salida: \u00a1Bienvenido!\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#expresion-de-funcion-flecha-conciso-monolinea-llamada","title":"Expresi\u00f3n de funci\u00f3n flecha conciso (monol\u00ednea) + llamada:","text":"<ul> <li>Si no contiene atributos, los par\u00e9ntesis estar\u00e1n vac\u00edos, pero deben estar presentes.</li> <li>Al ser una funci\u00f3n monol\u00ednea, las llaves pueden omitirse.</li> <li>Al ser una expresi\u00f3n de funci\u00f3n, lleva punto y coma al final.</li> </ul> <pre><code>const cliente = () =&gt; console.log('\u00a1Bienvenido!');\n\ncliente(); // Salida: \u00a1Bienvenido!\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-2","title":"Ejemplo 2","text":"<p>Veamos el segundo ejemplo, esta vez, le pasamos 1 atributo en la funci\u00f3n.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-multilinea-1-atributo","title":"Funci\u00f3n flecha (multil\u00ednea) + 1 atributo:","text":"<ul> <li>Las funciones flecha con un solo atributo, los par\u00e9ntesis pueden omitirse.</li> <li>Al ser una funci\u00f3n multil\u00ednea, las llaves deben estar presentes.</li> <li>Al ser una expresi\u00f3n de funci\u00f3n, lleva punto y coma al final.</li> </ul> <pre><code>const cliente = (nombre) =&gt; { // antes\n    console.log(`${nombre}`);\n};\n\nconst cliente = nombre =&gt; { // despues\n    console.log(`${nombre}`);\n};\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-conciso-monolinea-1-atributo","title":"Funci\u00f3n flecha conciso (monol\u00ednea) + 1 atributo:","text":"<ul> <li>Las funciones flecha con un solo atributo, los par\u00e9ntesis pueden omitirse.</li> <li>Al ser una funci\u00f3n monol\u00ednea, las llaves pueden omitirse.</li> <li>Al ser una expresi\u00f3n de funci\u00f3n, lleva punto y coma al final.</li> </ul> <pre><code>const cliente = (nombre) =&gt; { console.log(`${nombre}`) }; // antes\n\nconst cliente = nombre =&gt; console.log(`${nombre}`); // despues\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-3","title":"Ejemplo 3","text":"<p>Veamos el tercer ejemplo, esta vez, le pasamos 1 argumento en la llamada.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-multilinea-1-argumento-en-la-llamada","title":"Funci\u00f3n flecha (multil\u00ednea) + 1 argumento en la llamada:","text":"<pre><code>const cliente = nombre =&gt; {\n    console.log(`${nombre}`);\n};\n\ncliente('Roberto'); // Salida: Roberto\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-conciso-monolinea-1-argumento-en-la-llamada","title":"Funci\u00f3n flecha conciso (monol\u00ednea) + 1 argumento en la llamada:","text":"<pre><code>const cliente = nombre =&gt; console.log(`${nombre}`);\n\ncliente('Roberto'); // Salida: Roberto\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-4","title":"Ejemplo 4","text":"<p>Veamos el cuarto ejemplo, a diferencia del segundo ejemplo, aqui le pasamos 2 atributos en la funci\u00f3n y 2 argumentos en la llamada a la funci\u00f3n.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-2-atributos-2-argumentos","title":"Funci\u00f3n flecha + 2 atributos + 2 argumentos:","text":"<ul> <li>Las funciones flecha con mas de un atributo, los par\u00e9ntesis deben estar presentes.</li> <li>Al ser una funci\u00f3n multil\u00ednea, las llaves deben estar presentes.</li> <li>Al ser una expresi\u00f3n de funci\u00f3n, lleva punto y coma al final.</li> </ul> <pre><code>const cliente = (nombre, apellido) =&gt; {\n    console.log(`${nombre} ${apellido}`);\n};\n\ncliente('Roberto', 'Mendiburu'); // Salida: Roberto Mendiburu\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-conciso-2-atributos-2-argumentos","title":"Funci\u00f3n flecha conciso + 2 atributos + 2 argumentos:","text":"<ul> <li>Las funciones flecha con mas de un atributo, los par\u00e9ntesis deben estar presentes.</li> <li>Al ser una funci\u00f3n monol\u00ednea, las llaves pueden omitirse.</li> <li>Al ser una expresi\u00f3n de funci\u00f3n, lleva punto y coma al final.</li> </ul> <pre><code>const cliente = (nombre, apellido) =&gt; console.log(`${nombre} ${apellido}`);\n\ncliente('Roberto', 'Mendiburu'); // Salida: Roberto Mendiburu\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#32-tipos-de-funciones-flecha","title":"3.2. Tipos de funci\u00f3nes flecha:","text":"<p>Las funciones flecha (arrow functions) son indudablemente una de las caracter\u00edsticas m\u00e1s populares de ES6 (EcmaScript 6). Ellas introducen una nueva forma de escribir funciones concisas. Es importante notar que las funciones flecha son an\u00f3nimas, lo que significa que no tienen nombre y no se pueden utilizar como metodos ni constructores dentro de una clase.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#caracteristicas","title":"Caracter\u00edsticas:","text":"<ul> <li>Siempre son expresiones.</li> <li>Siempre deberemos asignar la expresi\u00f3n a una variable.</li> <li>Pueden ser de varios tipos:<ul> <li>Expresi\u00f3n de funci\u00f3n flecha (multil\u00ednea)</li> <li>Expresi\u00f3n de funci\u00f3n flecha conciso (monol\u00ednea) </li> </ul> </li> </ul>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#expresion-de-funcion-flecha-multilinea","title":"Expresi\u00f3n de funci\u00f3n flecha (multil\u00ednea):","text":"<p>Esta funci\u00f3n, esta construido en bloque. Al no estar toda la funci\u00f3n en una misma l\u00ednea, se trataria de una expresi\u00f3n de funci\u00f3n flecha (multil\u00ednea) y no obtendria las caracter\u00edsticas de un (monol\u00ednea).</p> <ul> <li>Al ser una expresi\u00f3n de funci\u00f3n, debe asignarse a una variable.</li> <li>La expresi\u00f3n de funci\u00f3n flecha elimina la palabra clave function.</li> <li>Una funci\u00f3n flecha con mas de un atributo, los par\u00e9ntesis deben estar presentes.</li> <li>Al ser una funci\u00f3n multil\u00ednea, las llaves deben estar presentes.</li> <li>Al ser una funci\u00f3n multil\u00ednea, el return debe estar presente.</li> <li>Al ser una expresi\u00f3n de funci\u00f3n, lleva punto y coma al final.</li> </ul>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-2-atributos-2-argumentos_1","title":"Funci\u00f3n flecha + 2 atributos + 2 argumentos:","text":"<pre><code>const sumar = (a, b) =&gt; {\n    return a + b;\n};\n\nconst resultado = sumar(2, 6);\nconsole.log(resultado); // Salida: 8\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-3-atributos-3-argumentos","title":"Funci\u00f3n flecha + 3 atributos + 3 argumentos:","text":"<p><pre><code>const cliente = (nombre, apellido, telefono) =&gt; {\n    return `${nombre} ${apellido} ${telefono}`;\n};\n\nconst resultado = cliente('Roberto', 'Mendiburu', '666-666-666');\nconsole.log(resultado); // Salida: Roberto Mendiburu 666-666-666\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#expresion-de-funcion-flecha-conciso-monolinea","title":"Expresi\u00f3n de funci\u00f3n flecha conciso (monol\u00ednea):","text":"<p>En este ejemplo, podemos observar c\u00f3mo la expresi\u00f3n de funci\u00f3n flecha conciso elimina la necesidad de escribir la palabra clave function, las llaves {} y la declaraci\u00f3n return, resultando en una expresi\u00f3n m\u00e1s compacta.</p> <ul> <li>Al ser una expresi\u00f3n de funci\u00f3n, debe asignarse a una variable.</li> <li>La expresi\u00f3n de funci\u00f3n flecha elimina la palabra clave function.</li> <li>Una funci\u00f3n flecha con mas de un atributo, los par\u00e9ntesis deben estar presentes.</li> <li>Al ser una funci\u00f3n monol\u00ednea, las llaves pueden omitirse.</li> <li>Al ser una funci\u00f3n monol\u00ednea, el return puede omitirse.</li> <li>Al ser una expresi\u00f3n de funci\u00f3n, lleva punto y coma al final.</li> </ul>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-conciso-2-atributos-2-argumentos_1","title":"Funci\u00f3n flecha conciso + 2 atributos + 2 argumentos:","text":"<pre><code>const sumar = (a, b) =&gt; a + b;\n\nconst resultado = sumar(2, 6);\nconsole.log(resultado); // Salida: 8\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#funcion-flecha-conciso-3-atributos-3-argumentos","title":"Funci\u00f3n flecha conciso + 3 atributos + 3 argumentos:","text":"<pre><code>const cliente = (nombre, apellido, telefono) =&gt; `${nombre} ${apellido} ${telefono}`;\n\nconst resultado = cliente('Roberto', 'Mendiburu', '666-666-666');\nconsole.log(resultado); // Salida: Roberto Mendiburu 666-666-666\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#33-analisis-de-funciones","title":"3.3. An\u00e1lisis de funciones:","text":"<p>Veamos una comparativa entre 3 tipos de funciones \ud83d\udc47</p> <ul> <li>Opci\u00f3n 1: Funci\u00f3n tradicional</li> <li>Opci\u00f3n 2: Funci\u00f3n flecha</li> <li>Opci\u00f3n 3: Funci\u00f3n flecha conciso</li> </ul> ejemplo.js<pre><code>// Opci\u00f3n 1:\n// Declaraci\u00f3n de funci\u00f3n + 3 atributos - multil\u00ednea\nfunction cliente(nombre, apellido, telefono) {\n    return `${nombre} ${apellido} ${telefono}`;\n}\n\nconst resultado_1 = cliente('Roberto', 'Mendiburu', '666-666-666');\nconsole.log(resultado_1); // Salida: Roberto Mendiburu 666-666-666\n\n\n\n// Opci\u00f3n 2:\n// Expresi\u00f3n de funci\u00f3n flecha + 3 atributos - multil\u00ednea\nconst cliente = (nombre, apellido, telefono) =&gt; {\n    return `${nombre} ${apellido} ${telefono}`;\n};\n\nconst resultado_2 = cliente('Roberto', 'Mendiburu', '666-666-666');\nconsole.log(resultado_2); // Salida: Roberto Mendiburu 666-666-666\n\n\n\n// Opci\u00f3n 3:\n// Expresi\u00f3n de funci\u00f3n flecha conciso + 3 atributos - monol\u00ednea\nconst cliente = (nombre, apellido, telefono) =&gt; `${nombre} ${apellido} ${telefono}`;\n\nconst resultado_3 = cliente('Roberto', 'Mendiburu', '666-666-666');\nconsole.log(resultado_3); // Salida: Roberto Mendiburu 666-666-666\n</code></pre>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#diferencias-entre-funciones","title":"Diferencias entre funciones:","text":"<p> Las funciones flecha pueden componerse de m\u00e1s de una l\u00ednea, lo cual ya nos obligar\u00e1 a emplear las llaves y el return.</p> <p></p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#34-funciones-con-this","title":"3.4. Funciones con \"this\":","text":"<p>La palabra clave \"this\" tendra efecto dentro de una funci\u00f3n o clase que la envuelve. Utilizamos \"this\" para acceder a las distintas propiedades de una funci\u00f3n o clase.</p> <p>Veamos el uso de \"this\" con diferentes tipos de funciones:</p> <ul> <li>Ejemplo 1: Funci\u00f3n de expresi\u00f3n (multil\u00ednea)</li> <li>Ejemplo 2: Funci\u00f3n flecha (multil\u00ednea)</li> <li>Ejemplo 3: Funci\u00f3n flecha conciso (monol\u00ednea)</li> </ul>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-1_1","title":"Ejemplo 1","text":"<p>En este ejemplo, se crea una declaraci\u00f3n de funci\u00f3n llamada Factura y se le pasa 1 atributo. Dentro de esta funci\u00f3n, se crea una funci\u00f3n de expresi\u00f3n referenciando a la variable total pasado por \"this\".</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#declaracion-de-funcion-funcion-de-expresion-this-1-atributo-1-argumento","title":"Declaraci\u00f3n de funci\u00f3n + funci\u00f3n de expresi\u00f3n + this + 1 atributo + 1 argumento:","text":"<p><pre><code>function Factura(subTotal) {\n  this.iva = 0.21;\n  this.subTotal = subTotal;\n\n  this.total = function() {\n    return ((this.iva * this.subTotal) + this.subTotal);\n  };\n}\n\nconst totalFactura = new Factura(200);\nconsole.log(totalFactura.total()); // Salida: 242\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-2_1","title":"Ejemplo 2","text":"<p>Veamos el segundo ejemplo, se crea una declaraci\u00f3n de funci\u00f3n llamada Factura y se le pasa 1 atributo. Dentro de esta funci\u00f3n, (aqui viene la diferencia respecto al ejempo 1) se crea una funci\u00f3n flecha referenciando a la variable total pasado por \"this\".</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#declaracion-de-funcion-funcion-flecha-this-1-atributo-1-argumento","title":"Declaraci\u00f3n de funci\u00f3n + funci\u00f3n flecha + this + 1 atributo + 1 argumento:","text":"<p><pre><code>function Factura(subTotal) {\n    this.iva = 0.21;\n    this.subTotal = subTotal;\n\n    this.total = () =&gt; {\n        return ((this.iva * this.subTotal) + this.subTotal);\n    };\n}\n\nconst totalFactura = new Factura(200);\nconsole.log(totalFactura.total()); // Salida: 242\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-3_1","title":"Ejemplo 3","text":"<p>Veamos el tercer ejemplo, se crea una declaraci\u00f3n de funci\u00f3n llamada Factura y se le pasa 1 atributo. Dentro de esta funci\u00f3n, se crea una funci\u00f3n flecha conciso referenciando a la variable total pasado por \"this\".</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#declaracion-de-funcion-funcion-flecha-conciso-this-1-atributo-1-argumento","title":"Declaraci\u00f3n de funci\u00f3n + funci\u00f3n flecha conciso + this + 1 atributo + 1 argumento:","text":"<p><pre><code>function Factura(subTotal) {\n    this.iva = 0.21;\n    this.subTotal = subTotal;\n\n    this.total = () =&gt; ((this.iva * this.subTotal) + this.subTotal);\n}\n\nconst totalFactura = new Factura(200);\nconsole.log(totalFactura.total()); // Salida: 242\n</code></pre> El uso de funci\u00f3n flecha es limitada, no se puede utilizar como metodo ni constructor dentro de una clase.</p> <p></p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#35-objetos-y-metodos-con-this","title":"3.5. Objetos y m\u00e9todos con \"this\":","text":"<p>Cuando se crea una funci\u00f3n dentro de un objeto, esta funci\u00f3n pasa a llamarse m\u00e9todo. El m\u00e9todo, no incorpora la palabra clave function ni tampoco hace falta referenciarla a una variable como ocurre en la expresi\u00f3n de funci\u00f3n. Un m\u00e9todo debe tener nombre, no puede ser an\u00f3nimo.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-1_2","title":"Ejemplo 1","text":"<p>En este ejemplo, incorpora un m\u00e9todo al objeto.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#objeto-metodo-this","title":"Objeto + m\u00e9todo + \"this\":","text":"<p><pre><code>const usuario = {\n    nombre: 'Roberto',\n    apellido: 'Mendiburu',\n    telefono: '333-666-666',\n\n    mostrar() {\n        console.log(this);\n    }\n};\n\nusuario.mostrar();\n\n/* Salida:\n\n{\nNombre: Roberto\nApellido: Mendiburu\nTel\u00e9fono: 333-666-666\nmostrar: [Function: mostrar]\n}\n\n*/\n</code></pre> </p> <p>Ve\u00e1mos que ocurre si cambiamos el m\u00e9todo por una funci\u00f3n flecha: <pre><code>const usuario = {\n    nombre: 'Roberto',\n    apellido: 'Mendiburu',\n    telefono: '333-666-666',\n\n    () =&gt; {\n        console.log(this);\n    };\n};\n\nusuario; // no podemos llamar al m\u00e9todo flecha porque no tiene nombre.\n\n/* Salida:\n\nSyntaxError\n\n*/\n</code></pre> Lo que ocurre aqu\u00ed es que, al tratarse de una funci\u00f3n an\u00f3nima, no podemos llamarla de ninguna manera, por eso nos devuelve un error de sintaxis.</p> <ul> <li>Las funci\u00f3nes flecha, no pueden ser usados como m\u00e9todos, dentro de un objeto o clase.</li> </ul> <p></p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#36-objetos-y-funciones-con-this","title":"3.6. Objetos y funciones con \"this\":","text":"<p>Mostremos la diferencia en cuanto al uso de \"this\" en las funciones tradicionales y las funciones flecha.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-1_3","title":"Ejemplo 1","text":"<p>En este ejemplo, incorpora una funci\u00f3n como propiedad del objeto.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#objeto-funcion-de-expresion-this","title":"Objeto + funci\u00f3n de expresi\u00f3n + \"this\":","text":"<p><pre><code>const cliente = { \n    nombre: 'Roberto',\n    apellido: 'Mendiburu',\n\n    nombreCompleto: function() {\n        console.log(\"this es: \", this); \n        console.log(`Cliente: ${this.nombre} ${this.apellido}`);\n    }\n};\n\n\ncliente.nombreCompleto();\n\n/* Salida:\n\nthis es: {\n    nombre: 'Roberto',\n    apellido: 'Mendiburu',\n    nombreCompleto: [Function: nombreCompleto]\n}   \nCliente: Roberto Mendiburu\n\n*/\n</code></pre> </p> <p>Ve\u00e1mos que ocurre si sacamos a la funci\u00f3n fuera del objeto: <pre><code>const cliente = { \n    nombre: 'Roberto',\n    apellido: 'Mendiburu'\n};\n\nconst nombreCompleto = function() {\n    console.log(\"this es: \", this); \n    console.log(`Cliente: ${this.nombre} ${this.apellido}`);\n};\n\n\nnombreCompleto(cliente);\n\n/* Salida:\n\nthis es:  Object [global] {etc.}\nCliente: undefined undefined\n\n*/\n</code></pre> Nos devuelve un resultado distinto.</p> <ul> <li>El \"this\" hace referencia al objeto global (window) ya que no tiene al objeto anterior envolviendolo.</li> </ul> <p></p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-2_2","title":"Ejemplo 2","text":"<p>En este ejemplo, incorpora una funci\u00f3n flecha como propiedad del objeto.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#objeto-funcion-de-expresion-flecha-this","title":"Objeto + funci\u00f3n de expresi\u00f3n flecha + \"this\":","text":"<p><pre><code>const cliente = { \n    nombre: 'Roberto',\n    apellido: 'Mendiburu',\n\n    nombreCompleto: () =&gt; {\n        console.log(\"this es: \", this); \n        console.log(`Cliente: ${this.nombre} ${this.apellido}`);\n    }\n};\n\n\ncliente.nombreCompleto();\n\n/* Salida:\n\nthis es:  {}\nCliente: undefined undefined\n\n*/\n</code></pre> El comportamiento del \"this\" en expresi\u00f3n de funci\u00f3n flecha es distinto al de expresi\u00f3n de funci\u00f3n cuando quiere referenciar al objeto.</p> <ul> <li>El \"this\" queda atrapado dentro de la funci\u00f3n flecha sin valor.</li> </ul> <p></p> <p>Ve\u00e1mos de nuevo que ocurre si sacamos a la funci\u00f3n fuera del objeto: <pre><code>const cliente = { \n    nombre: 'Roberto',\n    apellido: 'Mendiburu'\n};\n\nconst nombreCompleto = () =&gt; {\n    console.log(\"this es: \", this); \n    console.log(`Cliente: ${this.nombre} ${this.apellido}`);\n};\n\n\nnombreCompleto(cliente);\n\n/* Salida:\n\nthis es:  {}\nCliente: undefined undefined\n\n*/\n</code></pre> \u00c9sta vez nos devuelve el mismo resultado.</p> <ul> <li>El \"this\" vuelve a quedarse atrapado dentro de la funci\u00f3n flecha sin valor.</li> </ul> <p></p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#ejemplo-3_2","title":"Ejemplo 3","text":"<p>LLegado aqu\u00ed, te preguntaras si es posible acceder a las propiedades del objeto desde fuera de ella utilizando \"this\". La respuesta es que si, hay un m\u00e9todo para las funciones que se llama (funci\u00f3n de enlace) \"bind()\" que permite enlazar el \"this\" con el objeto mediante argumento.</p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#1-objeto-funcion-de-expresion-this-bind","title":"1 Objeto + funci\u00f3n de expresi\u00f3n  + \"this\" + bind():","text":"<p><pre><code>const cliente = {\n    nombre: 'Roberto',\n    apellido: 'Mendiburu'\n};\n\nconst nombreCompleto = function() {\n    alert(`Cliente: ${this.nombre} ${this.apellido}`);\n};\n\nconst enlaceCliente = nombreCompleto.bind(cliente);\n\nenlaceCliente(); // Cliente: Roberto Mendiburu\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#2-objetos-funcion-de-expresion-this-bind","title":"2 Objetos + funci\u00f3n de expresi\u00f3n  + \"this\" + bind():","text":"<p><pre><code>const cliente_1 = {\n    nombre: 'Roberto',\n    apellido: 'Mendiburu'\n};\n\nconst cliente_2 = {\n    nombre: 'Julen',\n    apellido: 'Mendoza'\n};\n\nconst nombreCompleto = function() {\n    alert(`Cliente: ${this.nombre} ${this.apellido}`);\n};\n\nconst enlaceCliente_1 = nombreCompleto.bind(cliente_1);\nconst enlaceCliente_2 = nombreCompleto.bind(cliente_2);\n\nenlaceCliente_1(); // Cliente: Roberto Mendiburu\nenlaceCliente_2(); // Cliente: Julen Mendoza\n</code></pre> </p> <p>Ve\u00e1mos que ocurre con la funci\u00f3n flecha:  <pre><code>const cliente = {\n    nombre: 'Roberto',\n    apellido: 'Mendiburu'\n};\n\nconst nombreCompleto = () =&gt; {\n    alert(`Cliente: ${this.nombre} ${this.apellido}`);\n};\n\nconst enlaceCliente = nombreCompleto.bind(cliente);\n\nenlaceCliente(); // Cliente: undefined undefined\n</code></pre> Cabe recordar, que el \"this\" tampoco funciona con el m\u00e9todo \"bind()\" en funci\u00f3n flecha.</p> <ul> <li>El \"this\" queda atrapado dentro de la funci\u00f3n flecha sin valor.</li> </ul> <p>La \u00fanica manera de enlazar el \"this\" con el objeto desde fuera de ella es con el uso de funci\u00f3n de expresi\u00f3n + \"bind()\". As\u00ed es como trabaja el m\u00e9todo (funci\u00f3n de enlace).</p> <p></p>"},{"location":"devcamp/checkpoint-08/funcion-flecha-js/#editor-de-codigo-utilizado","title":"Editor de c\u00f3digo utilizado:","text":"<ul> <li>Programiz - JavaScript Online Compiler  </li> </ul>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/","title":"6. \u00bfQu\u00e9 es la programaci\u00f3n orientada a objetos?","text":"<p>La programaci\u00f3n orientada a objetos (POO) es un paradigma de la programaci\u00f3n en el que se crean objetos para la manipulaci\u00f3n de datos y donde, por lo general, cada objeto ofrece una funcionalidad especial.</p> <ul> <li>La idea b\u00e1sica de la POO es el uso de objetos para modelar cosas del mundo real.</li> <li>POO nos ayuda a la reutilizaci\u00f3n del c\u00f3digo.</li> </ul> <p>Imagina que tienes un colegio o escuela con 1000 estudiantes y 100 profesores, ser\u00eda il\u00f3gico estar construyendo objetos para cada uno de ellos. Las clases son, como una especie de m\u00e1quina constructora de objetos al momento segun demanda.</p> <p>Hay de varios tipos:</p> <ul> <li>Funci\u00f3n constructora (antiguo)</li> <li>Clase (actual)</li> </ul> <p></p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#61-funciones-constructoras","title":"6.1. Funciones constructoras:","text":"<ul> <li>Un nombre de funci\u00f3n constructora generalmente comienza con una letra may\u00fascula. Esta convenci\u00f3n se utiliza para hacer que la funci\u00f3n constructora sean m\u00e1s f\u00e1cil de reconocer en el c\u00f3digo.</li> <li>La palabra clave new se usa para crear una nueva instancia del objeto (crear un nuevo objeto)</li> </ul>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#declaracion-de-funcion-1-atributo-instancia","title":"Declaraci\u00f3n de funci\u00f3n + 1 atributo + instancia:","text":"<pre><code>function Persona(nombre) {\n    this.nombre = nombre;\n    this.saludar = function() {\n        return (`${this.nombre} dice, \u00a1hola!`);\n    };\n}\n\nconst persona_1 = new Persona('Markel');\nconst persona_2 = new Persona('Nerea');\n\nconsole.log(persona_1.saludar());\nconsole.log(persona_2.saludar());\n\n/* Salida:\n\nMarkel dice, \u00a1hola!\nNerea dice, \u00a1hola!\n\n*/\n</code></pre>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#el-constructor-object","title":"El constructor Object():","text":"<pre><code>const persona_1 = new Object();\npersona_1.nombre = \"Markel\";\npersona_1.saludar = function() {\n    return (`${this.nombre} dice, \u00a1hola!`);\n};\n\nconsole.log(persona_1.saludar());\n\n/* Salida:\n\nMarkel dice, \u00a1hola!\n\n*/\n</code></pre>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#62-clases","title":"6.2. Clases:","text":"<p>Con la llegada de ES6 (ECMAScript 2015), se introducen las clases en JavaScript que proveen una sintaxis mucho m\u00e1s clara y simple para crear objetos y lidiar con la herencia. Es una mejora sint\u00e1ctica de las funciones constructoras que se basaban en prototipos, \u00e9sto no cambi\u00f3 ni agreg\u00f3 funcionalidad, pero trajo una mejor organizaci\u00f3n del c\u00f3digo.</p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#existen-2-formas-para-definir-una-clase-y-2-tipos-de-expresion-de-clase","title":"Existen 2 formas para definir una clase y 2 tipos de expresi\u00f3n de clase:","text":"<ul> <li>Declaraci\u00f3n de clase</li> <li>Expresi\u00f3n de clase<ul> <li>An\u00f3nima: No tiene un nombre.</li> <li>Nombrada: Tiene un nombre interno que solo es accesible dentro de la clase.</li> </ul> </li> </ul>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#declaracion-de-clase","title":"Declaraci\u00f3n de clase:","text":"<pre><code>class Persona {\n    constructor(nombre) {\n        this.nombre = nombre;\n    }\n}\n</code></pre>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#expresion-de-clase","title":"Expresi\u00f3n de clase:","text":"<p><pre><code>const Persona = class {\n    constructor(nombre) {\n        this.nombre = nombre;\n    }\n};\n</code></pre> Ambos enfoques crean una clase llamada Persona, pero con las expresiones de clases se tiene m\u00e1s flexibilidad para definirlas de forma din\u00e1mica.</p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#expresion-de-clase_1","title":"Expresi\u00f3n de clase:","text":"<p>En el siguiente ejemplo, la clase se define sin un nombre espec\u00edfico (an\u00f3nima) y se asigna a la constante Persona. A partir de ah\u00ed, se puede utilizar de la misma manera que una clase declarada.</p> <pre><code>const Persona = class {\n  constructor(nombre, edad) {\n    this.nombre = nombre;\n    this.edad = edad;\n  }\n\n  saludar() {\n    console.log(`Hola, soy ${this.nombre} y tengo ${this.edad} a\u00f1os.`);\n  }\n};\n\nconst persona_1 = new Persona('Roberto', 34);\n\npersona_1.saludar(); // Hola, soy Roberto y tengo 34 a\u00f1os.\n</code></pre>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#expresion-de-clase-nombrada","title":"Expresi\u00f3n de clase nombrada:","text":"<p>En este ejemplo, la clase PersonaInterna es accesible solo dentro del bloque de la expresi\u00f3n pero no fuera de \u00e9l. Esta caracter\u00edstica permite encapsular el nombre de la clase y evitar conflictos de nombres.</p> <pre><code>const Persona = class PersonaInterna {\n  constructor(nombre) {\n    this.nombre = nombre;\n  }\n\n  saludar() {\n    console.log(`Hola, soy ${this.nombre}.`);\n  }\n};\n\nconst persona_1 = new Persona('Nerea');\npersona_1.saludar(); // Hola, soy Nerea.\n\n// El nombre interno \"PersonaInterna\" no es accesible fuera de la clase\nconsole.log(typeof PersonaInterna); // undefined\n</code></pre>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#cuando-usar-expresion-de-clase","title":"Cu\u00e1ndo usar expresi\u00f3n de clase:","text":"<ul> <li>Clases din\u00e1micas: Cuando necesitas definir clases de forma condicional o dentro de funciones.</li> <li>Mantener el c\u00f3digo limpio: Usa clases an\u00f3nimas si no necesitas referenciar el nombre fuera del bloque.</li> </ul>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#sintaxis-de-una-clase","title":"Sintaxis de una clase:","text":"<p><pre><code>class NombreClase {                       // declaraci\u00f3n de clase + nombre de clase\n    constructor(atributo_1, atributo_2) { // constructor + atributos\n        this.propiedad_1 = atributo_1;    // propiedad de una clase\n        this.propiedad_2 = atributo_2;    // propiedad de una clase\n    }\n\n    metodo_1() { // se nombra un m\u00e9todo\n        return (`Devuelve ${this.propiedad_1} y ${this.propiedad_2}`); // cuerpo de m\u00e9todo\n    }\n}\n\nconst objeto_1 = new NombreClase('argumento_1', 'argumento_2'); // se crea un objeto pasando argumentos\nconsole.log(objeto_1.metodo_1()); // Salida: Devuelve argumento_1 y argumento_2\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-constructor","title":"Clase + constructor:","text":"<p><pre><code>class Persona {\n\n    constructor(nombre) {\n        this.nombre = nombre;\n    }\n}\n\nconst persona_1 = new Persona('Nerea');\nconsole.log(persona_1.nombre); // Salida: Nerea\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-constructor-1-metodo","title":"Clase + constructor + 1 m\u00e9todo:","text":"<p><pre><code>class Persona {\n\n    constructor(nombre) {\n        this.nombre = nombre;\n    }\n\n    nombrePersona() {\n        return (`${this.nombre}`);  \n    }\n}\n\nconst persona_1 = new Persona('Nerea');\nconsole.log(persona_1.nombrePersona()); // Salida: Nerea\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-con-llaves-en-atributos-y-argumentos","title":"Clase con llaves en atributos y argumentos:","text":"<p><pre><code>class Persona {\n\n    constructor({nombre, apellido}) {\n        this.nombre = nombre;\n        this.apellido = apellido;\n    }\n\n    nombreCompleto() {\n        console.log(`${this.nombre} ${this.apellido}`);\n    }\n}\n\nconst persona_1 = new Persona({nombre: 'Markel', apellido:'Mart\u00ednez'});\nconst persona_2 = new Persona({apellido: 'Medina', nombre: 'Gorka'});\n\npersona_1.nombreCompleto();\npersona_2.nombreCompleto();\n\n/* Salida:\n\nMarkel Mart\u00ednez\nGorka Medina\n\n*/\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-sin-llaves-en-atributos-y-argumentos","title":"Clase sin llaves en atributos y argumentos:","text":"<pre><code>class Persona {\n\n    constructor(nombre, apellido) {\n        this.nombre = nombre;\n        this.apellido = apellido;\n    }\n\n    nombreCompleto() {\n        console.log(`${this.nombre} ${this.apellido}`);\n    }\n}\n\nconst persona_1 = new Persona('Markel', 'Mart\u00ednez');\nconst persona_2 = new Persona('Gorka', 'Medina');\n\npersona_1.nombreCompleto();\npersona_2.nombreCompleto();\n\n/* Salida:\n\nMarkel Mart\u00ednez\nGorka Medina\n\n*/\n</code></pre>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#621-metodo-de-instancia","title":"6.2.1. M\u00e9todo de instancia:","text":""},{"location":"devcamp/checkpoint-08/que-es-poo-js/#ejemplo-1","title":"Ejemplo 1","text":"<p>En este ejemplo, el uso de llaves en atributos como en argumentos es necesario para poder renombrar el valor predeterminado del atributo tipo si diese el caso.</p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-constructor-1-valor-de-atributo-predeterminado","title":"Clase + constructor + 1 valor de atributo predeterminado:","text":"<ul> <li>Se declara una clase llamado Persona</li> <li>Se crea un constructor, se le pasa 1 atributo llamado tipo con valor predeterminado, el resto sin valores</li> <li>Se crea un m\u00e9todo llamado descripcion</li> <li>Se crean 2 objetos llamados persona_1, persona_2 y se le pasan argumentos a cada uno.</li> </ul> <p><pre><code>class Persona {\n\n    constructor({tipo = 'alumno', nombre, apellido, edad}) {\n        this.tipo = tipo;\n        this.nombre = nombre;\n        this.apellido = apellido;\n        this.edad = edad;\n    }\n\n    descripcion() {\n        return (`${this.nombre} ${this.apellido} tiene ${this.edad} a\u00f1os y es ${this.tipo}.`);\n    }\n}\n\nconst persona_1 = new Persona({nombre: 'Markel', apellido:'Mart\u00ednez', edad: 36});\nconst persona_2 = new Persona({nombre: 'Gorka', apellido: 'Medina', edad: 45, tipo: 'profesor'});\n\nconsole.log(persona_1.descripcion());\nconsole.log(persona_2.descripcion());\n\n/* Salida:\n\nMarkel Mart\u00ednez tiene 36 a\u00f1os y es alumno.\nGorka Medina tiene 45 a\u00f1os y es profesor.\n\n*/\n</code></pre> </p> <p>Veamos \u00e9ste otro ejemplo con la misma l\u00f3gica: <pre><code>class Coche {\n    constructor({anio, marca, motorizadoPor = 'gasolina'}) {\n        this.anio = anio;\n        this.marca = marca;\n        this.motorizadoPor = motorizadoPor;\n    }\n\n    caracteristicas() {\n        return (`El ${this.marca} ${this.anio} funciona con ${this.motorizadoPor}`)\n    }\n}\n\nconst model3 = new Coche({anio: 2025, marca: 'Tesla', motorizadoPor: 'electricidad'});\n\nconsole.log(model3.caracteristicas());\n\n/* Salida:\n\nEl Tesla 2025 funciona con electricidad\n\n*/\n</code></pre> </p> <p>Veamos una clase sin m\u00e9todo con la misma l\u00f3gica. No se recomienda, esto implica tener que construir la respuesta completa en cada llamada a la clase, se recomienda crear un m\u00e9todo dentro de la clase y llamarlo.</p> <pre><code>class Coche {\n\n    constructor({marca='Tesla', anio, motorizadoPor = 'gasolina'}) {\n        this.marca = marca;\n        this.anio = anio;\n        this.motorizadoPor = motorizadoPor;\n    }\n}\n\nconst model3 = new Coche({anio: 2025, motorizadoPor: 'electricidad'});\n\nconsole.log(`El ${model3.marca} ${model3.anio} funciona con ${model3.motorizadoPor}`);\n\n/* Salida:\n\nEl Tesla 2025 funciona con electricidad\n\n*/\n</code></pre> <p></p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#622-metodo-estatico","title":"6.2.2. M\u00e9todo est\u00e1tico:","text":"<p>Con un m\u00e9todo est\u00e1tico, no requiere crear un objeto mediante instancia para que funcione.</p> <ul> <li> <p>Acceso global: pueden utilizarse en cualquier lugar del c\u00f3digo sin necesidad de crear una instancia de la clase. Esto hace que sean accesibles de manera global y f\u00e1cil de usar.</p> </li> <li> <p>Optimizaci\u00f3n de recursos: al no requerir la creaci\u00f3n de instancias, los m\u00e9todos est\u00e1ticos pueden ser m\u00e1s eficientes en t\u00e9rminos de recursos.</p> </li> <li> <p>Mantenimiento simplicado: cuando un m\u00e9todo no necesita acceder a propiedades de instancia, es recomendable definirlo como est\u00e1tico, lo que simplifica el mantenimiento y reduce la complejidad del c\u00f3digo.</p> </li> </ul>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-metodo-estatico","title":"Clase + m\u00e9todo est\u00e1tico:","text":"<pre><code>class Persona {\n\n    static saludo(nombre) {\n        return (`${nombre} est\u00e1 saludando`);\n    }\n}\n\nconsole.log(Persona.saludo(\"Gorka\"));\n\n/* Salida:\n\nGorka est\u00e1 saludando\n\n*/\n</code></pre>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-metodo-de-instancia-metodo-estatico","title":"Clase + m\u00e9todo de instancia + m\u00e9todo est\u00e1tico:","text":"<p>Supongamos que estamos construyendo un sistema de gesti\u00f3n de usuarios y necesitamos generar un ID \u00fanico para cada usuario.</p> <p>En este caso, el m\u00e9todo est\u00e1tico generarID se utiliza para crear ID \u00fanicos sin necesidad de crear una instancia de la clase Usuario.</p> <pre><code>class Usuario {\n    constructor(nombre) {\n        this.nombre = nombre;\n        this.id = Usuario.generarID();\n\n    } static generarID() {\n        return Math.floor(Math.random() * 1000);\n    }\n}\n\nconst usuario_1 = new Usuario('Nerea');\nconsole.log(usuario_1.id);\n\n/* Salida:\n\nSe genera un n\u00famero (id) \u00fanico de forma aleatoria.\n\n*/\n</code></pre> <p></p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#623-propiedad-estatica","title":"6.2.3. Propiedad est\u00e1tica:","text":"<p>Adem\u00e1s de los m\u00e9todos est\u00e1ticos, las clases en JavaScript tambi\u00e9n pueden tener propiedades est\u00e1ticas, que son variables que pertenecen a la clase en su totalidad y no a las instancias individuales. A partir de ES2022 JavaScript permite definir propiedades est\u00e1ticas de manera m\u00e1s sencilla dentro de la clase. Esto se hace utilizando la palabra clave static antes de la definici\u00f3n de la propiedad.</p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-propiedad-estatica","title":"Clase + propiedad est\u00e1tica:","text":"<p><pre><code>class MiClase {\n    static miPropiedadEstatica = \"Soy una propiedad est\u00e1tica\";\n}\n\nconsole.log(MiClase.miPropiedadEstatica); // Salida: Soy una propiedad est\u00e1tica\n</code></pre> </p> <p>En este caso usuariosMax es una propiedad est\u00e1tica que pertenece a la clase Configuracion. Al ser est\u00e1tica, no puede ser accedida a trav\u00e9s de m\u00e9todos de instancias de la clase. <pre><code>class Configuracion {\n    static usuariosMax = 100;\n}\n\nconsole.log(Configuracion.usuariosMax); // Salida: 100\n</code></pre> </p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#acceso-a-propiedades-estaticas-desde-metodos-estaticos","title":"Acceso a propiedades est\u00e1ticas desde m\u00e9todos est\u00e1ticos:","text":"<p>Los m\u00e9todos est\u00e1ticos pueden acceder a otras propiedades y m\u00e9todos est\u00e1ticos usando this, que en este contexto se refiere a la clase.</p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-propiedad-estatica-metodo-estatico-alcance","title":"Clase + propiedad est\u00e1tica + m\u00e9todo est\u00e1tico + alcance:","text":"<p><pre><code>class Calcular {\n    static iva = 1.21;\n\n    static calcularIva(precioNeto) {\n        return (precioNeto * this.iva) + '\u20ac iva incluido';\n    }\n}\n\nconsole.log(Calcular.calcularIva(100)); // Salida: 121\u20ac\n</code></pre> </p> <p>Veamos un ejemplo donde combinamos m\u00e9todos y propiedades est\u00e1ticas para modelar un sistema de configuraci\u00f3n.</p> <p>version y conexionesMaximas son propiedades est\u00e1ticas de la clase Sistema y el m\u00e9todo obtenerInfo() proporciona informaci\u00f3n relevante sobre el sistema</p> <pre><code>class Sistema {\n    static version = '1.0.0';\n    static conexionesMaximas = 10;\n\n    static obtenerInfo() {\n        return `Versi\u00f3n: ${this.version}, Conexiones m\u00e1ximas: ${this.conexionesMaximas}`;\n    }\n}\n\nconsole.log(Sistema.obtenerInfo()); // Salida: Versi\u00f3n: 1.0.0, Conexiones m\u00e1ximas: 10\n</code></pre>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#buenas-practicas","title":"Buenas pr\u00e1cticas:","text":"<ul> <li>Usa m\u00e9todos est\u00e1ticos para l\u00f3gica no espec\u00edfica de instancias: Ideal para funciones utilitarias, c\u00e1lculos compartidos o valores constantes.</li> <li>Evita abusar de los m\u00e9todos est\u00e1ticos: Usa instancias y m\u00e9todos de instancia cuando necesites trabajar con datos espec\u00edficos de objetos.</li> <li>Organiza las propiedades est\u00e1ticas: Col\u00f3calas al inicio de la clase para mayor claridad.</li> <li>Documenta el prop\u00f3sito de los m\u00e9todos est\u00e1ticos: Deja claro en los comentarios cu\u00e1ndo y por qu\u00e9 un m\u00e9todo debe ser est\u00e1tico.</li> </ul>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#conclusion","title":"Conclusi\u00f3n:","text":"<p>Las propiedades y m\u00e9todos est\u00e1ticos son herramientas poderosas para agregar funcionalidades compartidas a las clases en JavaScript. Son \u00fatiles para crear funciones utilitarias, mantener valores constantes y manejar estados compartidos. Sin embargo, deben usarse con moderaci\u00f3n y no como sustituto de la l\u00f3gica basada en instancias.</p> <p></p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#63-nombres-de-propiedad-computadas","title":"6.3. Nombres de propiedad computadas:","text":"<p>Los nombres de propiedad computadas permiten utilizar una expresi\u00f3n dentro de corchetes ([ ]) para definir el nombre de una propiedad. Esto significa que el nombre de la propiedad se calcula en tiempo de ejecuci\u00f3n en lugar de ser un valor literal. En el contexto de las clases, estas pueden usarse para definir tanto m\u00e9todos como propiedades.</p> <p>Al definir m\u00e9todos en una clase, los nombres de propiedad son \u00fatiles cuando el nombre del m\u00e9todo no se conoce hasta tiempo de ejecuci\u00f3n.</p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#ejemplo-1_1","title":"Ejemplo 1","text":"<p>En este ejemplo, el nombre del m\u00e9todo se calcula a partir del valor de la variable metodoDinamico, lo que permite definir m\u00e9todos de manera m\u00e1s din\u00e1mica.</p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-1-metodo-con-nombre-computado","title":"Clase + 1 m\u00e9todo con nombre computado:","text":"<p><pre><code>const metodoDinamico = 'mostrarNombre';\n\nclass Usuario {\n  constructor(nombre) {\n    this.nombre = nombre;\n  }\n\n  [metodoDinamico]() {\n    console.log(`Nombre del usuario: ${this.nombre}`);\n  }\n}\n\nconst usuario1 = new Usuario('Kristine');\n\nusuario1.mostrarNombre(); // Salida: Nombre del usuario: Kristine\n</code></pre> </p> <p>Los nombres de propiedad computadas son especialmente \u00fatiles en los siguientes escenarios:</p> <ol> <li>Asignaci\u00f3n Din\u00e1mica de Propiedades o M\u00e9todos: Cuando el nombre de una propiedad o m\u00e9todo depende de una entrada del usuario o de otra l\u00f3gica que se ejecuta en tiempo de ejecuci\u00f3n.</li> <li>Configuraci\u00f3n Basada en Datos Externos: Si necesitas definir propiedades basadas en un conjunto de datos din\u00e1mico, los nombres de propiedad computados facilitan este proceso.</li> <li>Evitar Redundancia en C\u00f3digo Repetitivo: Puedes crear m\u00faltiples m\u00e9todos o propiedades usando un patr\u00f3n com\u00fan sin tener que escribir cada uno manualmente.</li> </ol> <p></p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#ejemplo-2","title":"Ejemplo 2","text":"<p>En este ejemplo, los m\u00e9todos se definen usando los valores almacenados en el array acciones, lo que evita la repetici\u00f3n de c\u00f3digo y facilita la creaci\u00f3n de m\u00e9todos con nombres similares.</p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#clase-metodos-con-prefijos-comunes","title":"clase + m\u00e9todos con prefijos comunes:","text":"<p><pre><code>const acciones = ['Iniciar', 'Detener', 'Reiniciar']; // array\n\nclass Maquina {\n  constructor(nombre) {\n    this.nombre = nombre;\n  }\n\n  [acciones[0]]() {\n    console.log(`${this.nombre} est\u00e1 iniciando.`);\n  }\n\n  [acciones[1]]() {\n    console.log(`${this.nombre} se ha detenido.`);\n  }\n\n  [acciones[2]]() {\n    console.log(`${this.nombre} est\u00e1 reiniciando.`);\n  }\n}\n\nconst servidor = new Maquina('Servidor A');\n\nservidor.Iniciar();   // Salida: Servidor A est\u00e1 iniciando.\nservidor.Detener();   // Salida: Servidor A se ha detenido.\nservidor.Reiniciar(); // Salida: Servidor A est\u00e1 reiniciando.\n</code></pre>  Aunque las propiedad computados son una caracter\u00edstica poderosa, hay algunas consideraciones importantes a tener en cuenta:</p> <ol> <li>Legibilidad del C\u00f3digo: El uso excesivo puede afectar la legibilidad del c\u00f3digo. Es importante usarlos cuando realmente agreguen valor.</li> <li>Errores de Tipo: Aseg\u00farate de que la expresi\u00f3n utilizada para calcular el nombre de la propiedad sea v\u00e1lida y retorne un string. De lo contrario se lanzar\u00e1 un error.</li> </ol>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#conclusion_1","title":"Conclusi\u00f3n:","text":"<p>Los nombres de propiedad computadas en clases son una caracter\u00edstica \u00fatil de JavaScript que permite definir m\u00e9todos y propiedades de forma din\u00e1mica. Cuando se usan adecuadamente pueden simplificar la configuraci\u00f3n de objetos y clases, evitar redundancias y hacer que el c\u00f3digo sea m\u00e1s flexible. Sin embargo, es importante no abusar de esta t\u00e9cnica para mantener la claridad del c\u00f3digo.</p> <p></p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#64-herencia","title":"6.4. Herencia:","text":"<p>La herencia en JavaScript permite que una clase hija adquiera las propiedades y m\u00e9todos de una clase base, lo cual facilita la creaci\u00f3n de jerarqu\u00edas de clases. La clase hija puede ampliar o modificar la funcionalidad heredada para adaptarla a necesidades espec\u00edficas.</p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#sintaxis-de-la-herencia","title":"Sintaxis de la herencia:","text":"<p>Para crear una clase que extienda otra clase, se utiliza la palabra clave extends:</p> <p>En este ejemplo, la clase Perro extiende la clase Animal, lo que le permite acceder al m\u00e9todo hacerSonido() de la clase base. <pre><code>class Animal {\n  constructor(nombre) {\n    this.nombre = nombre;\n  }\n\n  hacerSonido() {\n    console.log(`${this.nombre} est\u00e1 haciendo un sonido.`);\n  }\n}\n\nclass Perro extends Animal {\n  ladrar() {\n    console.log(`${this.nombre} est\u00e1 ladrando.`);\n  }\n}\n\nconst miPerro = new Perro('Rex');\n\nmiPerro.hacerSonido(); // Salida: Rex est\u00e1 haciendo un sonido.\nmiPerro.ladrar();      // Salida: Rex est\u00e1 ladrando.\n</code></pre></p>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#beneficios-de-la-herencia","title":"Beneficios de la Herencia:","text":"<ol> <li>Reutilizaci\u00f3n del C\u00f3digo: Se evita la duplicaci\u00f3n al reutilizar el comportamiento com\u00fan definido en la clase base.</li> <li>Extensi\u00f3n de Funcionalidades: La clase hija puede a\u00f1adir caracter\u00edsticas o cambiar el comportamiento de los m\u00e9todos heredados.</li> <li>Organizaci\u00f3n y Mantenimiento: Ayuda a estructurar el c\u00f3digo en niveles jer\u00e1rquicos, haciendo m\u00e1s f\u00e1cil comprender y mantener la l\u00f3gica.</li> </ol>"},{"location":"devcamp/checkpoint-08/que-es-poo-js/#editor-de-codigo-utilizado","title":"Editor de c\u00f3digo utilizado:","text":"<ul> <li>Programiz - JavaScript Online Compiler </li> </ul>"},{"location":"javascript/","title":"JavaScript","text":""},{"location":"javascript/#aprende-javascript","title":"Aprende JavaScript","text":"<p>Aqu\u00ed te guiaremos a trav\u00e9s de los conceptos y funcionalidades esenciales de JavaScript, un vers\u00e1til lenguaje de programaci\u00f3n ampliamente utilizado para crear p\u00e1ginas web interactivas y aplicaciones web din\u00e1micas.</p> <p></p> <p>Tanto si acabas de empezar como si buscas profundizar en tus conocimientos, estos tutoriales ser\u00e1n tu recurso de referencia para dominar este lenguaje de script.</p>"},{"location":"javascript/#01-primeros-pasos-con-javascript","title":"01. Primeros pasos con JavaScript","text":"<p>En las primeras etapas de la profundizaci\u00f3n en JavaScript, es crucial comprender los conceptos fundamentales que forman los bloques de construcci\u00f3n de este vers\u00e1til lenguaje de programaci\u00f3n.</p> 1.1. \u00bfQu\u00e9 es JavaScript?        Descubre JavaScript. Lenguaje de programaci\u00f3n clave para la interactividad web y el desarrollo...      1.2. Primeros pasos        JavaScript es un lenguaje de programaci\u00f3n interpretado, orientado a objetos y de alto..."},{"location":"javascript/#02-conceptos-basicos","title":"02. Conceptos b\u00e1sicos","text":"<p>Los conceptos b\u00e1sicos de JavaScript son los bloques de construcci\u00f3n fundamentales que todo desarrollador debe comprender al iniciar su viaje con este vers\u00e1til lenguaje de programaci\u00f3n. Comprender los conceptos b\u00e1sicos como variables, tipos de datos y funciones es crucial para escribir c\u00f3digo eficiente y f\u00e1cil de mantener.</p> 2.1. Sintaxis de JavaScript: Fundamentos y Elementos Clave        En este tutorial, aprender\u00e1 sobre la sintaxis de JavaScript, incluidos espacios en blanco...      2.2. Variables        En este tutorial, aprender\u00e1 sobre las variables de JavaScript y c\u00f3mo usarlas para almacenar...      2.3. Variables: Diferencias entre var, let y const        En JavaScript existen tres formas principales de declarar variables: var, let y const. Cada una...      2.4. Tipos de datos        En JavaScript los tipos de datos son fundamentales para gestionar y manipular la...      2.5. Los N\u00fameros        En JavaScript el tipo de dato number se utiliza para representar tanto n\u00fameros enteros como...      2.6. Booleanos        En JavaScript, los booleanos son un tipo de dato fundamental que representa uno de dos...      2.7. Strings: Cadena de Caracteres        En el mundo de la programaci\u00f3n las cadenas de caracteres o strings son una de las estructuras...      2.8. Valores Primitivos vs. Valores de Referencia        En JavaScript existen dos tipos principales de valores: valores primitivos y valores de...      2.9. Introducci\u00f3n a los Objetos        En JavaScript, los objetos son una de las estructuras de datos m\u00e1s importantes y...      2.10. Arrays        Los arrays son estructuras de datos fundamentales que permiten almacenar m\u00faltiples..."},{"location":"javascript/#03-operadores","title":"03. Operadores","text":"<p>En JavaScript, los operadores son fundamentales para manipular datos y realizar c\u00e1lculos. Entender los diferentes tipos de operadores disponibles es clave para escribir c\u00f3digo eficiente. Desde operadores aritm\u00e9ticos hasta operadores l\u00f3gicos, el conjunto diverso de herramientas en JavaScript ofrece soluciones para una variedad de tareas.</p> 3.1. Operadores Aritm\u00e9ticos        Los operadores aritm\u00e9ticos en JavaScript permiten realizar c\u00e1lculos matem\u00e1ticos b\u00e1sicos u...              - \u00a0 * \u00a0 / \u00a0 +      3.2. Operador de Resto        En JavaScript, el operador de resto, utilizado mediante el s\u00edmbolo (%) se usa com\u00fanmente para...              %      3.3. Operador de Exponenciaci\u00f3n        Introducido en ES6, el operador de exponenciaci\u00f3n (**) en JavaScript permite elevar un n\u00famero a...              **      3.4. Operadores de Asignaci\u00f3n        Los operadores de asignaci\u00f3n en JavaScript son esenciales para almacenar y actualizar valores en...              -= \u00a0 **= \u00a0 *= \u00a0 /= \u00a0 %= \u00a0 += \u00a0 =      3.5. Operadores Unarios        En JavaScript, los operadores unarios son herramientas que permiten realizar transformaciones y...              - \u00a0 -- \u00a0 + \u00a0 ++      3.6. Operadores de Comparaci\u00f3n        Los operadores de comparaci\u00f3n en JavaScript permiten comparar valores para evaluar condiciones...              != \u00a0 &gt; \u00a0 &gt;= \u00a0 &lt; &lt;= \u00a0 ==      3.7. Operadores l\u00f3gicos        Los operadores l\u00f3gicos en JavaScript permiten combinar y evaluar condiciones, facilitando la toma...              ! \u00a0 &amp;&amp; \u00a0 ||      3.8. Operadores de Asignaci\u00f3n L\u00f3gica        Los operadores de asignaci\u00f3n l\u00f3gica combinan una operaci\u00f3n l\u00f3gica (AND, OR o fusi\u00f3n de nulos)...              ??= \u00a0 &amp;&amp;= \u00a0 ||=      3.9. Operador de Fusi\u00f3n de Nulos        Introducido en ES2020, el operador de fusi\u00f3n de nulos (??) es una soluci\u00f3n elegante para asignar...              ??"},{"location":"javascript/#04-metodos-de-strings","title":"04. M\u00e9todos de Strings","text":"<p>Los m\u00e9todos de strings en proporcionan herramientas para trabajar con texto de manera eficiente y flexible. Desde la b\u00fasqueda de subcadenas hasta la modificaci\u00f3n y comparaci\u00f3n de texto, estos permiten manipular los strings con facilidad. Conocer c\u00f3mo utilizarlos es esencial para resolver problemas comunes y optimizar el manejo de datos textuales en aplicaciones modernas.</p> 4.1. M\u00e9todos de B\u00fasqueda en Strings        Los m\u00e9todos de b\u00fasqueda en JavaScript son importantes porque nos ayudan a localizar textos dentro...              includes() \u00a0 indexOf() \u00a0 lastIndexOf() \u00a0 search()      4.2. M\u00e9todos de Reemplazo en Strings        Reemplazar texto en JavaScript es una operaci\u00f3n com\u00fan y poderosa que permite modificar strings...              replace() \u00a0 replaceAll()      4.3. M\u00e9todos de Acceso a Caracteres        Los m\u00e9todos de acceso a caracteres en JavaScript nos permiten trabajar con las posiciones...              at \u00a0 charAt \u00a0 charCodeAt \u00a0 codePointAt      4.4. M\u00e9todos de Extracci\u00f3n y Corte        La manipulaci\u00f3n de cadenas de texto o strings es una tarea muy recurrida en JavaScript, y los...              slice() \u00a0 split() \u00a0 substring()      4.5. M\u00e9todos de Concatenaci\u00f3n y Relleno en Strings        En JavaScript, los m\u00e9todos de concatenaci\u00f3n y relleno no solo son herramientas \u00fatiles, sino que...              concat() \u00a0 padEnd() \u00a0 padStart() \u00a0 repeat()      4.6. M\u00e9todos de Transformaci\u00f3n de Caso        Trabajar con cadenas de texto en JavaScript a menudo implica ajustar el formato de may\u00fasculas y...              toLocaleLowerCase() \u00a0 toLocaleUpp \u00a0 toLowerCase() \u00a0 toUpperCase()      4.7. M\u00e9todos de Limpieza en Strings        Al trabajar con strings en JavaScript, es com\u00fan encontrarse con espacios en blanco al inicio o al...              trim() \u00a0 trimEnd() \u00a0 trimStart()      4.8. M\u00e9todos de Divisi\u00f3n y Uni\u00f3n en Strings        En la manipulaci\u00f3n de datos en JavaScript, los m\u00e9todos de divisi\u00f3n y uni\u00f3n split y join juegan...              join() \u00a0 split()"},{"location":"javascript/#05-sentencias-de-flujo-de-control","title":"05. Sentencias de flujo de control","text":"<p>Las sentencias de flujo de control son esenciales en la programaci\u00f3n, ya que determinan el orden en que un programa ejecuta su c\u00f3digo. Al comprender c\u00f3mo funcionan las sentencias de flujo de control, los desarrolladores pueden crear una l\u00f3gica que gu\u00ede al programa por diferentes caminos en funci\u00f3n de las condiciones.</p> 5.1. Declaraci\u00f3n if\u2026else        La declaraci\u00f3n if...else en JavaScript es una de las estructuras de control que se utilizan para...      5.2. Operador ternario        El operador ternario en JavaScript es una herramienta que sirve para simplificar...      5.3. Estructura switch case        La declaraci\u00f3n switch case es una herramienta eficiente en JavaScript que permite tomar...      5.4. Bucle While        El bucle while en JavaScript es una herramienta esencial cuando necesitas ejecutar un bloque...      5.5. Bucle do\u2026while        El bucle do\u2026while es una estructura repetitiva en JavaScript que nos garantiza que un bloque...      5.6. Bucle for        El bucle for es una herramienta en JavaScript que nos permite manejar tareas repetitivas...      5.7. Instrucci\u00f3n break        La instrucci\u00f3n break se utiliza para terminar de manera abrupta un bucle, una instrucci\u00f3n...      5.8. Instrucci\u00f3n continue        La instrucci\u00f3n continue se utiliza para omitir la iteraci\u00f3n actual de un bucle y pasar a la..."},{"location":"javascript/#06-funciones","title":"06. Funciones","text":"<p>En el vasto mundo de JavaScript, las funciones desempe\u00f1an un papel crucial al permitir a los desarrolladores encapsular bloques de c\u00f3digo para su reutilizaci\u00f3n y organizaci\u00f3n. Son entidades vers\u00e1tiles que pueden invocarse en cualquier punto del c\u00f3digo, facilitando la ejecuci\u00f3n de tareas espec\u00edficas.</p> 6.1. Funciones        En JavaScript, las funciones son una de las piezas clave del lenguaje. Estas nos permiten...      6.2. Funciones \u201cCiudadanos de Primera clase\u201d        En JavaScript, las funciones son ciudadanos de primera clase. Este concepto significa que las...      6.3. Funciones An\u00f3nimas        Las funciones an\u00f3nimas son un concepto fundamental en JavaScript, que permite a los...      6.4. Funciones Recursivas        Las funciones recursivas son una herramienta fundamental en programaci\u00f3n, En JavaScript...      6.5. Closures y \u00c1mbito L\u00e9xico        En JavaScript, uno de los conceptos m\u00e1s potentes y utilizado es el de los closure. Estos...      6.6. Par\u00e1metros por Defecto        En JavaScript, los par\u00e1metros por defecto permiten asignar valores iniciales a los...      6.7. Arrow Functions        Las arrow functions fueron introducidas en la especificaci\u00f3n ES6 y ofrecen una forma m\u00e1s...      6.8. M\u00e9todos avanzados para el contexto de funciones        En JavaScript, el contexto de una funci\u00f3n (representado por la palabra clave this) es un...      6.9. Rest Parameter        El Rest Parameter (par\u00e1metro rest) en JavaScript, introducido en ES6, es una herramienta \u00fatil del...      6.10. Funciones de Callback        Las funciones de callback son una parte fundamental de JavaScript, especialmente..."},{"location":"javascript/#07-arrays","title":"07. Arrays","text":"<p>Los arrays son una de las estructuras de datos m\u00e1s importantes y utilizadas en JavaScript. Permiten a los desarrolladores almacenar m\u00faltiples valores en una sola variable, facilitando la manipulaci\u00f3n y acceso a conjuntos de datos. Los arrays no solo son \u00fatiles para agrupar informaci\u00f3n, sino que tambi\u00e9n ofrecen una amplia variedad de m\u00e9todos y propiedades que permiten modificar, ordenar, buscar y recorrer los elementos de forma eficiente.</p> 7.1. Introducci\u00f3n a los Arrays        Los arrays son una de las estructuras de datos m\u00e1s vers\u00e1tiles y esenciales en JavaScript...      7.2. M\u00e9todos B\u00e1sicos de los Arrays        Los arrays en JavaScript no solo nos permiten almacenar m\u00faltiples valores de diferentes tipos en...              pop() \u00a0 push() \u00a0 shift() \u00a0 unshift()      7.3. M\u00e9todos de Corte y Pegado Arrays        Manipular arrays es una tarea com\u00fan en JavaScript. M\u00e1s all\u00e1 de agregar o eliminar elementos, a...              concat() \u00a0 slice() \u00a0 splice()      7.4. M\u00e9todos de B\u00fasqueda y Acceso Arrays        Cuando trabajamos con arrays en JavaScript, una de las tareas m\u00e1s comunes es localizar elementos...              find() \u00a0 findIndex() \u00a0 includes() \u00a0 indexOf()      7.5. Ordenar Arrays        Ordenar arrays es una tarea fundamental en cualquier lenguaje de programaci\u00f3n, y JavaScript no es...              reverse() \u00a0 sort()      7.6. Desestructuraci\u00f3n de Arrays y Spread Operator        Introducidos en ES6, la desestructuraci\u00f3n de arrays y el operador de propagaci\u00f3n spread..."},{"location":"javascript/#08-metodos-de-alto-orden-en-arrays","title":"08. M\u00e9todos de Alto Orden en Arrays","text":"<p>Los m\u00e9todos de alto orden o Higher Order Array Methods en JavaScript permiten manipular arrays de forma m\u00e1s declarativa y eficiente. Estos m\u00e9todos trabajan aplicando funciones a los elementos del array, ofreciendo una manera m\u00e1s concisa y clara de procesar y transformar datos sin recurrir a bucles tradicionales. Este concepto es clave en la programaci\u00f3n funcional y su uso es muy com\u00fan en JavaScript.</p> 8.1. Introducci\u00f3n a los M\u00e9todos de Alto Orden en Arrays        Los m\u00e9todos de alto orden en JavaScript son herramientas que permiten trabajar con arrays...      8.2. Iterando sobre Arrays de Forma Eficiente con ForEach        Dentro de los m\u00e9todos de alto orden en arrays, el m\u00e9todo forEach es uno de los m\u00e1s comunes y...              forEach()      8.3. Transformando Arrays con el m\u00e9todo Map        El m\u00e9todo map() en JavaScript es uno de los m\u00e1s \u00fatiles y flexibles entre los m\u00e9todos de alto...              map()      8.4. Filtrando Arrays con el M\u00e9todo Filter        En JavaScript, filter() es uno de los m\u00e9todos de alto orden m\u00e1s potentes cuando se trata de...              filter()      8.5. Reducci\u00f3n de Arrays con el M\u00e9todo Reduce        El m\u00e9todo reduce() es uno de los m\u00e9todos m\u00e1s potentes y vers\u00e1tiles en JavaScript. A diferencia...              reduce()      8.6. Verificaciones Condicionales en Arrays con some y every        En JavaScript, los m\u00e9todos some() y every() son dos m\u00e9todos de alto orden muy \u00fatiles para...              every() \u00a0 some()      8.7. B\u00fasqueda Eficiente en Arrays con find y findIndex        En una secci\u00f3n anterior, discutimos los M\u00e9todos de B\u00fasqueda y Acceso en Arrays en JavaScript...              find() \u00a0 findIndex()"},{"location":"javascript/#09-objetos-y-prototipos","title":"09. Objetos y prototipos","text":"<p>Comprender el concepto de objetos y prototipos es fundamental para dominar JavaScript. Los objetos sirven como bloques de construcci\u00f3n que encapsulan tanto datos como funcionalidad dentro de una \u00fanica entidad. Por su parte, los prototipos desempe\u00f1an un papel crucial en la herencia y en los paradigmas de programaci\u00f3n orientada a objetos en JavaScript.</p> 9.1. M\u00e9todos de Objetos: Operaciones Comunes        Los objetos son una de las estructuras de datos fundamentales en JavaScript, no solo permiten...              Object.assign() \u00a0 Object.entries() \u00a0 Object.freeze() \u00a0 Object.keys() \u00a0 Object.seal() \u00a0 Object.values()      9.2. Funciones Constructoras: Creaci\u00f3n de Objetos Personalizados        Las funciones constructoras en JavaScript son una t\u00e9cnica esencial para la creaci\u00f3n de...      9.3. Prototipo: Fundamentos        El concepto de prototipo en JavaScript es uno de los pilares fundamentales del lenguaje. Gracias...      9.4. Patr\u00f3n Constructor/Prototipo        El desarrollo de aplicaciones escalables y eficientes en JavaScript requiere un uso...      9.5. Patr\u00f3n Herencia Protot\u00edpica: Herencia Basada en Objetos        En JavaScript, la herencia se logra a trav\u00e9s de un sistema basado en prototipos, conocido como...      9.6. El this: C\u00f3mo Funciona en Diferentes Contextos        El valor de this en JavaScript es una de las caracter\u00edsticas m\u00e1s potentes y a veces, confus...      9.7. GlobalThis: Accede al Objeto Global en Diferentes Entornos        El concepto del objeto global en JavaScript es importante, ya que act\u00faa como el contenedor...      9.8. Propiedades de los Objetos        En JavaScript los objetos son colecciones de propiedades y cada propiedad tiene un conjunt...      9.9. Propiedades Enumerables y Propiedades Propias: Diferencias Clave        En JavaScript los objetos pueden tener diferentes tipos de propiedades y es important...      9.10. Ciclo for\u2026in: C\u00f3mo Iterar sobre las Propiedades de un Objeto        El ciclo for...in es una de las herramientas m\u00e1s comunes en JavaScript para iterar sobre las...      9.11. Funciones F\u00e1brica: Creando Objetos de Forma Flexible        En JavaScript una funci\u00f3n f\u00e1brica (o factory function) es una funci\u00f3n que retorna un objeto...      9.12. Desestructuraci\u00f3n de Objetos: Asigna Propiedades a Variables        La desestructuraci\u00f3n de objetos es una de las caracter\u00edsticas m\u00e1s \u00fatiles introducidas en ES6...      9.13. Operador de Encadenamiento Opcional (?.)        El operador de encadenamiento opcional (?.) es una caracter\u00edstica introducida en ES2020 que...      9.14. Crear Objetos con un Prototipo Espec\u00edfico con Object.create()        El m\u00e9todo Object.create() es una poderosa herramienta en JavaScript que permite crear un..."},{"location":"javascript/#10-clases","title":"10. Clases","text":"<p>En el \u00e1mbito de la programaci\u00f3n en JavaScript, las clases desempe\u00f1an un papel vital en la estructuraci\u00f3n y organizaci\u00f3n del c\u00f3digo. Las clases act\u00faan como planos para crear objetos con propiedades y m\u00e9todos predefinidos, lo que permite una reutilizaci\u00f3n y un mantenimiento eficaces del c\u00f3digo.</p> 10.1. Introducci\u00f3n a las Clases        Las clases en JavaScript, introducidas con ES6 (ECMAScript 2015), ofrecen una forma m\u00e1s clar...      10.2. Constructor de Clase: Configuraci\u00f3n de Objetos        El constructor de clase en JavaScript es un m\u00e9todo especial que se ejecuta...      10.3. M\u00e9todos de Instancia en Clases        Los m\u00e9todos de instancia en JavaScript son funciones definidas dentro de una clase que...      10.4. Propiedades y M\u00e9todos Est\u00e1ticos en Clases        En JavaScript, las propiedades y m\u00e9todos est\u00e1ticos pertenecen a la clase misma, no a sus...      10.5. Expresiones de Clase        Las Class Expressions (Expresiones de Clase) en JavaScript son una forma alternativa de definir...      10.6. Nombres de Propiedad Computadas en Clases        Los nombres de propiedad computadas o Computed Property Names permiten definir...      10.7. Extensi\u00f3n de Clases (Herencia)        La herencia es un concepto fundamental en la programaci\u00f3n orientada a objetos que permite...      10.8. Uso de super en Clases        La palabra clave super en JavaScript se utiliza en clases derivadas para acceder al constructor o...      10.9. Encapsulaci\u00f3n con Propiedades Privadas en Clases        La encapsulaci\u00f3n es un concepto clave en la programaci\u00f3n orientada a objetos que permite...      10.10. Getters y Setters en Clases        Los getters y setters en JavaScript son funciones especiales que se utilizan para controlar el...      10.11. Mixins        Los Mixins en JavaScript son una t\u00e9cnica en la programaci\u00f3n orientada a objetos que permite..."},{"location":"javascript/#11-promesas-y-asyncawait","title":"11. Promesas y Async/Await","text":"<p>En el \u00e1mbito de JavaScript, dominar las promesas y Async/Await puede mejorar significativamente tus habilidades de codificaci\u00f3n. Estas t\u00e9cnicas avanzadas proporcionan una forma m\u00e1s eficaz de manejar las operaciones as\u00edncronas, permitiendo una ejecuci\u00f3n m\u00e1s fluida de las funciones.</p> 11.1. Introducci\u00f3n a la Programaci\u00f3n As\u00edncrona        La programaci\u00f3n as\u00edncrona es una t\u00e9cnica que permite que los programas realicen m\u00faltiples...      11.2. Promesas        Las promesas en JavaScript son una herramienta esencial para manejar operaciones as\u00edncronas...      11.3. Encadenamiento de Promesas        El encadenamiento de promesas es una t\u00e9cnica que permite ejecutar operaciones as\u00edncronas...      11.4. Promise.all: Promesas en Paralelo        El m\u00e9todo Promise.all en JavaScript es una herramienta poderosa para manejar m\u00faltiples...              Promise.all      11.5. Promise.race: Resolviendo la Promesa M\u00e1s R\u00e1pida        El m\u00e9todo Promise.race en JavaScript permite manejar varias promesas ejecutadas en paralelo y...              Promise.race      11.6. Promise.allSettled: Manejo Completo de Promesas        El m\u00e9todo Promise.allSettled en JavaScript es una herramienta dise\u00f1ada para manejar m\u00faltiples...              Promise.allSettled      11.7. Promise.any: Esperando la Primera Promesa Resuelta con \u00c9xito        Promise.any es un m\u00e9todo en JavaScript que devuelve la primera promesa que se resuelve con \u00e9xito...              Promise.any      11.8. Manejo de Errores en Promesas        Trabajar con promesas en JavaScript permite manejar operaciones as\u00edncronas de manera fluida, pero...              catch() \u00a0 finally()      11.9. Async/Await        La introducci\u00f3n de async/await en JavaScript transform\u00f3 la manera de manejar el c\u00f3digo...      11.10. Manejo de Errores con Async/Await        El uso de async y await ha hecho que trabajar con c\u00f3digo as\u00edncrono sea m\u00e1s claro y legible..."},{"location":"javascript/#12-iteradores-y-generadores","title":"12. Iteradores y Generadores","text":"<p>Los Iteradores y Generadores desempe\u00f1an un papel importante en JavaScript, estos proporcionan un enfoque optimizado para recorrer y manejar estructuras de datos. Estas estructuras facilitan la iteraci\u00f3n de manera m\u00e1s controlada y eficiente, mejorando tanto la legibilidad como el mantenimiento del c\u00f3digo y simplificando tareas complejas de procesamiento secuencial.</p> 12.1. Introducci\u00f3n a los Iteradores        Los iteradores en JavaScript proporcionan una manera eficiente y controlada de recorrer...      12.2. Iterables y el Bucle for\u2026of        Los iterables en JavaScript son estructuras que permiten recorrer sus elementos de manera...      12.3. Generadores        Los generadores en JavaScript son un tipo especial de funci\u00f3n que permite pausar y reanudar su...              function* \u00a0 next() \u00a0 yield      12.4. Iteradores As\u00edncronos        Con el auge de aplicaciones que manejan datos en tiempo real y operaciones as\u00edncronas como...      12.5. Generadores As\u00edncronos        Los generadores as\u00edncronos en JavaScript permiten producir y consumir valores de..."},{"location":"javascript/#13-modulos","title":"13. M\u00f3dulos","text":"<p>Los m\u00f3dulos desempe\u00f1an un papel importante en la organizaci\u00f3n y estructuraci\u00f3n del c\u00f3digo JavaScript, permitiendo a los desarrolladores dividir sus programas en piezas m\u00e1s peque\u00f1as y reutilizables. Al encapsular funciones, variables y objetos relacionados dentro de m\u00f3dulos, el c\u00f3digo es m\u00e1s f\u00e1cil de mantener y gestionar.</p> 13.1. Introducci\u00f3n a los M\u00f3dulos        Los m\u00f3dulos en JavaScript son fundamentales para organizar y estructurar c\u00f3digo de manera...      13.2. Exportaci\u00f3n        La exportaci\u00f3n en JavaScript permite compartir variables, funciones y clases entre m\u00f3dulos...      13.3. Importaci\u00f3n        La importaci\u00f3n en JavaScript permite que un m\u00f3dulo use funciones, variables o clases de...      13.4. Reexportaci\u00f3n de M\u00f3dulos        La reexportaci\u00f3n en JavaScript permite agrupar y redistribuir m\u00f3dulos desde un solo punto de...      13.5. M\u00f3dulos Din\u00e1micos        Los m\u00f3dulos din\u00e1micos en JavaScript permiten cargar c\u00f3digo de manera as\u00edncrona durante la..."},{"location":"javascript/#14-colecciones","title":"14. Colecciones","text":"<p>En el \u00e1mbito de la programaci\u00f3n en JavaScript comprender las colecciones es un aspecto fundamental. Estas son una estructura de datos que permite almacenar y organizar m\u00faltiples elementos. Al profundizar en las colecciones, los desarrolladores pueden manipular y gestionar los datos de manera eficiente, mejorando la funcionalidad y el rendimiento general de sus aplicaciones web.</p> 14.1. Map        El objeto Map en JavaScript, introducido en ES6, es una estructura de datos dise\u00f1ada para...      14.2. Set        El objeto Set es una estructura de datos que permite almacenar valores \u00fanicos de cualquier..."},{"location":"javascript/#15-gestion-de-errores","title":"15. Gesti\u00f3n de errores","text":"<p>La gesti\u00f3n de errores en JavaScript es un aspecto crucial de la programaci\u00f3n para garantizar el buen funcionamiento de tu c\u00f3digo. Cuando se producen errores durante la ejecuci\u00f3n de un programa, los mecanismos de gesti\u00f3n adecuados pueden evitar que la aplicaci\u00f3n se bloquee y proporcionar a los usuarios informaci\u00f3n significativa.</p> 15.1. try catch        El manejo de errores en JavaScript es importante al momento de construir aplicaciones confiable...      15.2. try catch finally        El bloque try catch finally en JavaScript ampl\u00eda la funcionalidad de la estructura...      15.3. Lanzar Excepciones con throw        El manejo de errores en JavaScript no solo implica capturar problemas con try\u2026catch, sino...      15.4. Optional Catch Binding        La introducci\u00f3n del optional catch binding (Manejo Opcional del Error en Catch) en..."},{"location":"javascript/#16-runtime-tiempo-de-ejecucion","title":"16. Runtime (tiempo de ejecuci\u00f3n)","text":"<p>El JavaScript Runtime es el entorno en el cual se ejecuta el c\u00f3digo JavaScript. Es el \u201cescenario\u201d donde ocurren todas las acciones de nuestro c\u00f3digo. Durante la ejecuci\u00f3n, el tiempo de ejecuci\u00f3n se encarga de interpretar y ejecutar el c\u00f3digo JavaScript l\u00ednea por l\u00ednea, gestionando tareas como la asignaci\u00f3n de memoria, la ejecuci\u00f3n de funciones, la manipulaci\u00f3n de objetos, y la interacci\u00f3n con el entorno donde se est\u00e9 ejecutando.</p> 16.1. Contexto de Ejecuci\u00f3n        El contexto de ejecuci\u00f3n es uno de los conceptos clave para entender c\u00f3mo JavaScript procesa y...      16.2. Call Stack: Entendiendo la Pila de Llamadas        La pila de llamadas o call stack es un mecanismo en el cual se utiliza el motor de JavaScript para...      16.3. Event Loop        El event loop (bucle de eventos) es un componente fundamental del tiempo de...      16.4. Hoisting: Entendiendo la Elevaci\u00f3n en el C\u00f3digo        El hoisting (o elevaci\u00f3n) es un comportamiento en JavaScript que ocurre durante la fase de...      16.5. Variable Scope: Alcances de las Variables        El alcance (scope) de una variable en JavaScript define d\u00f3nde es visible y accesible dentro del..."},{"location":"javascript/#17-tipos-de-envoltura-primitivos","title":"17. Tipos de Envoltura Primitivos","text":"<p>Los (Primitive Wrapper Types) en JavaScript son objetos especiales que envuelven los tipos de datos primitivos (como n\u00fameros, cadenas, booleanos y s\u00edmbolos) para permitirles comportarse como objetos. Estos tipos de envoltura proporcionan m\u00e9todos y propiedades adicionales que no est\u00e1n presentes en los tipos primitivos, permitiendo que trabajemos con ellos como si fueran objetos.</p> <p></p> <p>Aprende JavaScript </p> <p>Programiz - JavaScript Online Compiler </p> <p></p>"},{"location":"javascript/booleanos/","title":"Booleanos","text":""},{"location":"javascript/booleanos/#booleanos","title":"Booleanos","text":"<p>En JavaScript, los booleanos son un tipo de dato fundamental que representa uno de dos valores: <code>true</code> o <code>false</code> (verdadero/falso). Este tipo se utiliza principalmente en estructuras de control, condiciones l\u00f3gicas y bucles que determinan el flujo de ejecuci\u00f3n de un programa.</p> <p>En este art\u00edculo aprenderemos qu\u00e9 son los booleanos, c\u00f3mo se utilizan y exploraremos algunos casos comunes para trabajarlos con condiciones y operadores l\u00f3gicos.</p>"},{"location":"javascript/booleanos/#que-es-un-booleano","title":"\u00bfQu\u00e9 es un Booleano?","text":"<p>Un booleano es un tipo de dato primitivo en JavaScript que representa un valor de verdad. Los \u00fanicos valores posibles son <code>true</code> (verdadero) o <code>false</code> (falso). En la programaci\u00f3n se utilizan para evaluar expresiones y controlar el flujo del programa mediante decisiones basadas en condiciones.</p> javascript<pre><code>const esMayor = 10 &gt; 5;\nconst esIgual = 10 === \"10\";\n\nconsole.log(esMayor);\nconsole.log(esIgual);\n</code></pre> <p>En el ejemplo anterior <code>esMayor</code> es <code>true</code> porque 10 es mayor que 5, mientras que <code>esIgual</code> es <code>false</code> debido a la no diferencia en el tipo de dato.</p> <p> Los valores literales del booleano distinguen entre may\u00fasculas y min\u00fasculas. Esto significa que Truey False son identificadores v\u00e1lidos pero no son valores boolean.</p> <p></p> <p>Este tipo de datos denominado as\u00ed en honor a George Boole, un matem\u00e1tico ingl\u00e9s conocido por su trabajo en l\u00f3gica algebraica, se convirti\u00f3 en una herramienta fundamental en las estructuras l\u00f3gicas de los programas.</p>"},{"location":"javascript/booleanos/#valores-falsos-y-verdaderos","title":"Valores Falsos y Verdaderos","text":"<p>En JavaScript algunos valores se consideran \u201cverdaderos\u201d (truthy) y otros \u201cfalsos\u201d (falsy) cuando se eval\u00faan en un contexto booleano. Es importante conocer cu\u00e1les son estos valores para evitar errores al trabajar con condiciones.</p>"},{"location":"javascript/booleanos/#valores-falsy-en-javascript","title":"Valores Falsy en JavaScript","text":"<p>Los siguientes valores son considerados falsos en un contexto booleano:</p> <ul> <li><code>false</code></li> <li><code>0</code></li> <li><code>\"\"</code> (cadena vac\u00eda)</li> <li><code>null</code></li> <li><code>undefined</code></li> <li><code>NaN</code> (Not a Number)</li> </ul> <p>Cualquier otro valor se considera \u201cverdadero\u201d (truthy), lo que significa que se eval\u00faa como <code>true</code>.</p> <p>Ejemplos de Valores Falsy y Truthy</p> javascript<pre><code>if (0) {\n    console.log(\"Esto no se ejecutar\u00e1.\");\n}\n\nif (\"Hola\") {\n    console.log(\"Esto s\u00ed se ejecutar\u00e1.\");\n}\n</code></pre> <p>En el ejemplo anterior <code>0</code> es un valor falsy y no activa el bloque <code>if</code>, mientras que la cadena <code>\"Hola\"</code> es truthy y activa el bloque.</p>"},{"location":"javascript/booleanos/#conversion-de-valores-booleanos","title":"Conversi\u00f3n de Valores Booleanos","text":"<p>JavaScript permite convertir los valores de otros tipos a valores booleanos. Para convertir un valor no booleano en un valor booleano, utilizamos la funci\u00f3n incorporada <code>Boolean()</code></p> javascript<pre><code>const error = 'An error occurred';\nconst hasError = Boolean(error);\n\nconsole.log(hasError);\n</code></pre> <p>En el ejemplo anterior declaramos una variable <code>error</code> que contiene el string \u2018<code>An error occurred</code>\u2018. Luego utilizando la funci\u00f3n <code>Boolean()</code>, convertimos el valor de la variable <code>error</code> a un booleano y lo almacenamos en la variable <code>hasError</code>. Al imprimir <code>hasError</code> en la consola, obtendremos <code>true</code> debido a que la variable <code>error</code> contiene un string no vac\u00edo, lo que hace que la funci\u00f3n <code>Boolean()</code> lo eval\u00fae como verdadero.</p> <p>La siguiente tabla muestra c\u00f3mo la funci\u00f3n <code>Boolean()</code> convierte los valores de otros tipos en valores booleanos:</p> Tipo de datos Valores convertidos a verdaderos Valor convertido a falso <code>string</code> Cualquier cadena no vac\u00eda \u201c\u201d (string vac\u00edo) <code>number</code> Cualquier n\u00famero distinto de cero 0, NaN <code>object</code> cualquier objeto nulo <code>undefined</code> (Irrelevante) indefinido <p>Ejemplos de Conversi\u00f3n a Booleano:</p> javascript<pre><code>console.log(Boolean(1));\nconsole.log(Boolean(0));\nconsole.log(Boolean(\"\"));\nconsole.log(Boolean(\"Hola\"));\n\n// Uso del doble operador de negaci\u00f3n\nconsole.log(!!123);\nconsole.log(!!\"\");\n</code></pre>"},{"location":"javascript/booleanos/#coercion-implicita-a-booleano","title":"Coerci\u00f3n Impl\u00edcita a Booleano","text":"<p>En JavaScript se genera de manera impl\u00edcita la coerci\u00f3n de tipos a booleano. Por ejemplo, la declaraci\u00f3n <code>if</code> ejecuta un bloque si una condici\u00f3n es <code>true</code>. Si usa un valor no booleano usar\u00e1 la funci\u00f3n <code>Boolean()</code> para convertir impl\u00edcitamente ese valor a un valor booleano. Es decir, JavaScript convierte el valor a booleano autom\u00e1ticamente. Por ejemplo:</p> javascript<pre><code>const error = \"An error occurred\";\n\nif (error) {\n  console.log(error);\n}\n</code></pre> <p>En cambio, si cambia el valor de la variable <code>error</code> a una cadena vac\u00eda (<code>\"\"</code>), no imprimir\u00e1 nada en la consola porque la declaraci\u00f3n <code>if</code> lo eval\u00faa como <code>false</code>:</p>"},{"location":"javascript/booleanos/#operadores-booleanos-en-javascript","title":"Operadores Booleanos en JavaScript","text":"<p>JavaScript cuenta con una variedad de operadores booleanos que permiten realizar operaciones l\u00f3gicas y de comparaci\u00f3n en el c\u00f3digo. Estos operadores son esenciales para tomar decisiones basadas en condiciones y controlar el flujo del programa.</p> <p>Hay seis tipos principales de operadores booleanos en JavaScript, cada uno con su funci\u00f3n espec\u00edfica:</p> <ol> <li>AND l\u00f3gico: Representado por <code>&amp;&amp;</code>.</li> <li>OR l\u00f3gico: Representado por <code>||</code>.</li> <li>Comparaci\u00f3n: Incluye operadores como <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> y <code>&gt;=</code>.</li> <li>Comparaci\u00f3n estricta: Representado por <code>===</code> y <code>!==</code>.</li> <li>NOT l\u00f3gico: Representado por <code>!</code>.</li> <li>Operadores l\u00f3gicos bitwise: Incluye <code>&amp;</code> para AND, <code>|</code> para OR, <code>^</code> para XOR, <code>~</code> para NOT y <code>&lt;&lt;</code>, <code>&gt;&gt;</code> y <code>&gt;&gt;&gt;</code> para desplazamiento de bits.</li> </ol> <p>Mas adelante profundizamos en cada uno de los operadores.</p>"},{"location":"javascript/booleanos/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los booleanos en JavaScript son esenciales para la toma de decisiones y el control del flujo de los programas. Conocer los operadores l\u00f3gicos, los valores truthy y falsy y c\u00f3mo utilizar los booleanos en condiciones te permitir\u00e1 escribir c\u00f3digo m\u00e1s robusto y eficiente.</p> <p>En el siguiente art\u00edculo profundizaremos en el uso de las cadenas de caracteres (strings) en JavaScript, abordando sus m\u00e9todos y aplicaciones comunes.</p> <p></p>"},{"location":"javascript/numeros/","title":"Los N\u00fameros","text":""},{"location":"javascript/numeros/#los-numeros","title":"Los N\u00fameros","text":"<p>En JavaScript el tipo de dato <code>number</code> se utiliza para representar tanto n\u00fameros enteros como decimales. Este tipo de dato es fundamental en la programaci\u00f3n, ya que permite realizar operaciones matem\u00e1ticas, trabajar con c\u00e1lculos precisos y manejar valores especiales como <code>NaN</code>, <code>Infinity</code> y <code>-Infinity</code>.</p>"},{"location":"javascript/numeros/#que-son-los-numeros-en-javascript","title":"\u00bfQu\u00e9 son los n\u00fameros en JavaScript?","text":"<p>JavaScript utiliza un solo tipo de dato num\u00e9rico (<code>number</code>) para representar todos los n\u00fameros, ya sean enteros o de punto flotante. A diferencia de otros lenguajes que tienen tipos distintos para enteros y decimales, JavaScript trata todos los n\u00fameros de la misma manera.</p> <p>T\u00e9cnicamente utiliza el formato IEEE-754 para el tipo de dato <code>number</code>, que cubre tanto enteros como valores de punto flotante. Sin embargo, con la especificaci\u00f3n ES2020, se introdujo el tipo \u201cbigint\u201d para manejar enteros grandes, lo que proporciona una mayor flexibilidad en el manejo de valores num\u00e9ricos en JavaScript.</p>"},{"location":"javascript/numeros/#numeros-enteros","title":"N\u00fameros Enteros","text":"<p>A continuaci\u00f3n se muestra c\u00f3mo declarar una variable que contiene un n\u00famero entero decimal:</p> javascript<pre><code>const counter = 100;\n</code></pre> <p>Los n\u00fameros enteros se pueden representar en los siguientes formatos:</p> <ul> <li>Octal (base 8)</li> <li>Hexadecimal (basado en 16)</li> </ul> <p>Cuando utiliza n\u00fameros octales y hexadecimales en operaciones aritm\u00e9ticas, JavaScript los trata como n\u00fameros decimales.</p>"},{"location":"javascript/numeros/#numeros-octales","title":"N\u00fameros Octales","text":"<p>Un n\u00famero literal octal comienza con el d\u00edgito cero (0) seguido de una secuencia de d\u00edgitos octales (n\u00fameros del 0 al 7). Por ejemplo:</p> javascript<pre><code>const num = 071;\nconsole.log(num);\n</code></pre> <p>Si un n\u00famero octal contiene un n\u00famero que no est\u00e1 en el rango de 0 a 7, el motor de JavaScript ignora el 0 y trata el n\u00famero como un decimal. Por ejemplo:</p> javascript<pre><code>const num = 080;\nconsole.log(num);\n</code></pre> <p>Este comportamiento impl\u00edcito podr\u00eda causar problemas. Por tal raz\u00f3n ES6 introdujo un nuevo literal octal que comienza con <code>0o</code> seguido de una secuencia de d\u00edgitos octales (de 0 a 7). Por ejemplo:</p> javascript<pre><code>const num = 0o71;\nconsole.log(num);\n</code></pre>"},{"location":"javascript/numeros/#numeros-hexadecimales","title":"N\u00fameros Hexadecimales","text":"<p>Los n\u00fameros hexadecimales comienzan con 0x o 0X seguidos de cualquier n\u00famero de d\u00edgitos hexadecimales (del 0 al 9 y de la a a la f). Por ejemplo:</p> javascript<pre><code>const num = 0x1a;\nconsole.log(num);\n</code></pre>"},{"location":"javascript/numeros/#numeros-de-punto-flotante","title":"N\u00fameros de Punto Flotante","text":"<p>Para definir un n\u00famero literal de punto flotante, se agrega un punto decimal seguido de al menos un n\u00famero. Por ejemplo:</p> javascript<pre><code>const price = 9.99;\nconst tax = 0.08;\nconst discount = .05; // valido pero no recomendable\n</code></pre> <p>Cuando trabajas con n\u00fameros muy grandes puedes usar la notaci\u00f3n cient\u00edfica. La notaci\u00f3n E indica que un n\u00famero se multiplica por 10 elevado a una potencia espec\u00edfica.</p> javascript<pre><code>const amount = 3.14e7;\nconsole.log(amount);\n</code></pre> <p>La notaci\u00f3n <code>3.14e7</code> significa que se toma <code>3.14</code> y se multiplica por .<code>10</code><sup><code>7</code></sup></p> <p>Asimismo puedes utilizar la notaci\u00f3n E para representar un n\u00famero muy peque\u00f1o.</p> javascript<pre><code>const amount = 5e-7; \nconsole.log(amount); // 0.0000005\n</code></pre> <p>La notaci\u00f3n <code>5e-7</code> significa que se toma <code>5</code> y se divide entre <code>10.000.000</code>.</p> <p>Adem\u00e1s, JavaScript convierte autom\u00e1ticamente cualquier n\u00famero de punto flotante con al menos seis ceros despu\u00e9s del punto decimal en notaci\u00f3n electr\u00f3nica. Por ejemplo:</p> javascript<pre><code>const amount = 0.0000005;\nconsole.log(amount);\n</code></pre> <p>Los n\u00fameros de punto flotante tienen una precisi\u00f3n de hasta 17 decimales. Cuando realiza operaciones aritm\u00e9ticas con n\u00fameros de punto flotante a menudo obtiene el resultado aproximado.</p>"},{"location":"javascript/numeros/#trabajar-con-el-constructor-number","title":"Trabajar con el Constructor <code>Number()</code>","text":"<p>Los valores num\u00e9ricos en JavaScript se pueden crear usando su forma literal o con el constructor incorporado <code>Number()</code>. Puedes crear un objeto <code>Number</code> usando la palabra clave <code>new</code>, por ejemplo: <code>new Number(123)</code>. Sin embargo esto no es com\u00fan, ya que los objetos <code>Number</code> no son primitivos y pueden causar confusi\u00f3n.</p> <p>Una vez creado un valor num\u00e9rico, podemos realizar operaciones aritm\u00e9ticas como sumas (<code>+</code>), restas (<code>-</code>), multiplicaciones (<code>*</code>) y divisiones (<code>/</code>). Adem\u00e1s de la aritm\u00e9tica b\u00e1sica, JavaScript admite una gran variedad de funciones matem\u00e1ticas, <code>como Math.abs()</code>, <code>Math.pow()</code> y <code>Math.round()</code>, que se pueden utilizar para realizar operaciones m\u00e1s complejas.</p>"},{"location":"javascript/numeros/#conversion-a-primitivos-numericos","title":"Conversi\u00f3n a Primitivos Num\u00e9ricos:","text":"<p>M\u00e1s com\u00fanmente, <code>Number()</code> se utiliza como una funci\u00f3n para convertir valores a primitivos num\u00e9ricos. Por ejemplo, <code>Number(\"123\")</code> convierte el string <code>\"123\"</code> en el n\u00famero primitivo <code>123</code>.</p> javascript<pre><code>const stringToNumber = Number(\"123\")\nconsole.log(stringToNumber)\n</code></pre>"},{"location":"javascript/numeros/#diferencias-entre-objeto-y-primitivo","title":"Diferencias Entre Objeto y Primitivo:","text":"<p>Un objeto <code>Number</code> (<code>new Number(123)</code>) y un primitivo num\u00e9rico (<code>Number(\"123\")</code>) son diferentes, el primero es un objeto y el segundo es un primitivo. Esto se puede verificar usando <code>typeof</code></p> javascript<pre><code>const number1 = new Number(123);\nconst number2 = Number(\"123\");\n\nconsole.log(typeof number1);\nconsole.log(typeof number2);\n</code></pre>"},{"location":"javascript/numeros/#number-y-bigint","title":"<code>Number()</code> y <code>BigInt</code>","text":"<p>Cuando utilizas la funci\u00f3n <code>Number()</code> para convertir un <code>BigInt</code> a un n\u00famero, no se produce un error. Sin embargo, es importante tener en cuenta que puede haber p\u00e9rdida de precisi\u00f3n si el <code>BigInt</code> es demasiado grande.</p>"},{"location":"javascript/numeros/#comparacion-de-valores-numericos","title":"Comparaci\u00f3n de valores num\u00e9ricos","text":"<p>En JavaScript, los valores num\u00e9ricos tambi\u00e9n se pueden comparar utilizando operadores de comparaci\u00f3n como <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> y <code>&gt;=</code>. Por ejemplo, el siguiente c\u00f3digo comprueba si la variable <code>num</code> es menor que 50:</p> javascript<pre><code>const num = 40;\n\nif (num &lt; 50) {\n console.log(\"El n\u00famero es menor que 50\");\n}\n</code></pre> <p>M\u00e9todos y Propiedades \u00datiles:</p> <ul> <li><code>Number.isNaN()</code>: Determina si el valor es NaN (Not a Number) o No se un numero.</li> <li><code>Number.isFinite()</code>: Determina si el valor es finito.</li> <li><code>Number.isInteger()</code>: Determina si un valor es un entero.</li> <li><code>Number.MAX_SAFE_INTEGER</code>: El m\u00e1ximo entero seguro en JavaScript.</li> <li><code>Number.MIN_SAFE_INTEGER</code>: El m\u00ednimo entero seguro en JavaScript.</li> </ul>"},{"location":"javascript/numeros/#infinity","title":"Infinity","text":"<p>En JavaScript, <code>Infinity</code> es un valor especial que representa n\u00fameros que son demasiado grandes para ser manejados por el lenguaje. El n\u00famero m\u00e1s grande que JavaScript puede manejar es <code>1.7976931348623157e+308</code>.</p> javascript<pre><code>const hugeNumber = 2e308;\nconsole.log(hugeNumber);\n</code></pre> <p>Tambi\u00e9n hay un valor <code>-Infinity</code>, que se usa para n\u00fameros negativos que van por debajo de <code>-1.7976931348623157e+308</code></p> javascript<pre><code>const hugeNumber = -2e308;\nconsole.log(hugeNumber);\n</code></pre> <p>El valor de infinito tambi\u00e9n se puede obtener al dividir entre cero.</p> javascript<pre><code>let result = 10 / 0;\nconsole.log(result);\n</code></pre>"},{"location":"javascript/numeros/#nan","title":"NaN","text":"<p><code>NaN</code> es un valor de error que significa \u201cNot a Number\u201c. Se utiliza cuando se intenta realizar una operaci\u00f3n y el resultado no es un valor num\u00e9rico. Por ejemplo: Como cuando intentas multiplicar un string por un n\u00famero, por ejemplo.</p> javascript<pre><code>const result = \"Hola\" * 5;\nconsole.log(result);\n</code></pre> <p>Pero\u2026 el resultado devuelto por el operador <code>typeof</code> para <code>NaN</code>. Algo curioso que debemos tener en cuenta.</p> javascript<pre><code>console.log(typeof NaN);\n</code></pre>"},{"location":"javascript/numeros/#redondear-y-dar-formato-a-los-numeros","title":"Redondear y dar formato a los n\u00fameros","text":"<p>JavaScript proporciona varias funciones para redondear y dar formato a los valores num\u00e9ricos. La funci\u00f3n <code>toFixed()</code> puede utilizarse para redondear un n\u00famero a un n\u00famero especificado de decimales. Por ejemplo, el siguiente c\u00f3digo redondea la variable n\u00famero a dos decimales:</p> javascript<pre><code>const number = 1.23456;\nconst roundedNumber = number.toFixed(2);\n\nconsole.log(roundedNumber); \n</code></pre> <p>En temas m\u00e1s avanzados, exploraremos en detalle las diversas propiedades disponibles para el tipo <code>number</code> en JavaScript.</p>"},{"location":"javascript/numeros/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los n\u00fameros en JavaScript ofrecen una amplia gama de funcionalidades para realizar operaciones matem\u00e1ticas, trabajar con valores especiales y manejar grandes cantidades con precisi\u00f3n. Comprender sus particularidades y las herramientas disponibles es esencial para el desarrollo de aplicaciones robustas.</p> <p>En el siguiente art\u00edculo exploraremos los valores booleanos en JavaScript, abordando su importancia en las condiciones y la l\u00f3gica de programaci\u00f3n.</p> <p></p>"},{"location":"javascript/primeros-pasos/","title":"Primeros pasos","text":""},{"location":"javascript/primeros-pasos/#primeros-pasos","title":"Primeros pasos","text":"<p>JavaScript es un lenguaje de programaci\u00f3n interpretado, orientado a objetos y de alto nivel. Originalmente fue creado para a\u00f1adir interactividad en las p\u00e1ginas web, permitiendo que los sitios respondan a las acciones del usuario, como hacer clic en botones, mover el rat\u00f3n o enviar formularios. Con el paso de los a\u00f1os, su uso ha crecido y hoy en d\u00eda se utiliza tanto en el frontend (lo que ves en el navegador) como en el backend (el servidor).</p> <p>Una de las caracter\u00edsticas m\u00e1s atractivas de JavaScript es que es compatible con todos los navegadores modernos. Esto significa que puedes escribir JavaScript en cualquier p\u00e1gina HTML sin necesidad de configuraciones adicionales, funcionar\u00e1 en todos.</p>"},{"location":"javascript/primeros-pasos/#como-insertar-javascript-en-tu-html","title":"C\u00f3mo insertar JavaScript en tu HTML","text":"<p>Para empezar a usar JavaScript en tu p\u00e1gina web es fundamental saber c\u00f3mo se integra con HTML, el lenguaje de marcado que estructura las p\u00e1ginas web.</p> <p>Existen dos formas b\u00e1sicas de incluir JavaScript en un documento HTML:</p> <ol> <li>Incrustaci\u00f3n Directa: El c\u00f3digo se embebe directamente en la p\u00e1gina HTML</li> <li>Archivo Externo: Referenciar a un archivo de c\u00f3digo JavaScript externo.</li> </ol>"},{"location":"javascript/primeros-pasos/#incrustar-codigo-javascript-en-una-pagina-html","title":"Incrustar c\u00f3digo JavaScript en una p\u00e1gina HTML","text":"<p>Una forma sencilla y r\u00e1pida de comenzar a usar JavaScript es escribir el c\u00f3digo directamente en el mismo archivo HTML, dentro de etiquetas <code>&lt;script&gt;</code>. Esta t\u00e9cnica es \u00fatil para proyectos peque\u00f1os o para cuando necesitas agregar scripts espec\u00edficos que no ser\u00e1n reutilizados en otras p\u00e1ginas. Aunque esta opci\u00f3n es v\u00e1lida, no es la m\u00e1s recomendable para proyectos m\u00e1s complejos o escalables.</p> html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;title&gt;Mi P\u00e1gina Web&lt;/title&gt;\n  &lt;script&gt;\n    console.log(\"\u00a1Hola desde JavaScript!\");\n  &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;Contenido de la p\u00e1gina&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Esta forma es \u00fatil para peque\u00f1os fragmentos de c\u00f3digo o para ejecutar scripts espec\u00edficos en una p\u00e1gina en especifico.</p>"},{"location":"javascript/primeros-pasos/#incluir-un-archivo-javascript-externo","title":"Incluir un archivo JavaScript externo","text":"<p>A medida que los proyectos crecen y se vuelven m\u00e1s complejos, es buena pr\u00e1ctica separar el c\u00f3digo JavaScript en archivos independientes con extensi\u00f3n <code>.js</code> Estos archivos se enlazan al documento HTML a trav\u00e9s de la etiqueta <code>&lt;script&gt;</code> con el atributo que define la fuente de origen <code>src</code>.</p> <p>Esta forma permite un c\u00f3digo m\u00e1s organizado, facilita el mantenimiento y la reutilizaci\u00f3n del c\u00f3digo en diferentes partes del proyecto.</p> html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n&lt;head&gt;\n  &lt;title&gt;Mi P\u00e1gina Web&lt;/title&gt;\n  &lt;script src=\"./script.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;Contenido de la p\u00e1gina&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>En este caso, el archivo <code>script.js</code> est\u00e1 en el mismo directorio que el archivo <code>.html</code>.</p> <p>Usar archivos JavaScript externos es especialmente \u00fatil cuando trabajas en equipo, ya que permite que m\u00faltiples personas trabajen en diferentes archivos de manera simult\u00e1nea sin interferir en el c\u00f3digo HTML.</p>"},{"location":"javascript/primeros-pasos/#ventajas-de-usar-archivos-externos","title":"Ventajas de Usar Archivos Externos","text":"<p>El uso de archivos externos en lugar de incrustar el c\u00f3digo JavaScript directamente en el HTML tiene varias ventajas:</p> <ul> <li>Reutilizaci\u00f3n: Puedes usar el mismo archivo JavaScript en diferentes p\u00e1ginas de tu sitio web sin necesidad de copiar y pegar el c\u00f3digo en cada una de ellas.</li> <li>Mantenimiento: Separar la estructura HTML del comportamiento JavaScript facilita hacer cambios en el c\u00f3digo sin afectar el contenido visual de la p\u00e1gina.</li> <li>Mejoras de rendimiento: Los navegadores modernos pueden almacenar en cach\u00e9 los archivos JavaScript externos, lo que reduce el tiempo de carga en visitas posteriores a la p\u00e1gina.</li> </ul>"},{"location":"javascript/primeros-pasos/#ruta-del-archivo-externo","title":"Ruta del Archivo Externo:","text":"<p>La ruta del archivo externo te permite enlazar archivos desde otros directorios utilizando <code>..</code> para navegar hacia arriba en la jerarqu\u00eda de directorios.</p> html<pre><code>&lt;script src=\"../public/js/script.js\"&gt;&lt;/script&gt;\n</code></pre> <p>En el ejemplo anterior \u201c<code>..</code>\u201d indica que estamos retrocediendo un nivel en la jerarqu\u00eda de directorios. Luego, accedemos al directorio \u201cpublic\u201d, despu\u00e9s al subdirectorio \u201cjs\u201d y finalmente al archivo \u201c<code>script.js</code>\u201d.</p>"},{"location":"javascript/primeros-pasos/#enlace-a-archivos-externos-de-terceros","title":"Enlace a Archivos Externos de Terceros:","text":"<p>Tambi\u00e9n es posible enlazar archivos JavaScript alojados en servidores externos, como bibliotecas o CDNs. Un ejemplo com\u00fan es la inclusi\u00f3n de jQuery desde su CDN.</p> html<pre><code>&lt;script src=\"https://code.jquery.com/jquery-3.6.0.min.js\"&gt;&lt;/script&gt;\n</code></pre>"},{"location":"javascript/primeros-pasos/#incluir-multiples-archivos-javascript-en-un-archivo","title":"Incluir M\u00faltiples Archivos JavaScript en un Archivo","text":"<p>Incluir m\u00faltiples archivos JavaScript en una p\u00e1gina web es posible mediante la inclusi\u00f3n de varias etiquetas <code>&lt;script&gt;</code> en el c\u00f3digo HTML. El motor JavaScript interpreta estos archivos en el orden en que aparecen.</p> <p>Por ejemplo: html<pre><code>&lt;script src=\"js/functions.js\"&gt;&lt;/script&gt;\n&lt;script src=\"js/app.js\"&gt;&lt;/script&gt;\n</code></pre></p> <p>En este ejemplo, el motor JavaScript interpreta primero el archivo <code>functions.js</code> y luego <code>app.js</code>, en secuencia. Es importante tener en cuenta este orden, ya que las funciones y variables definidas en <code>functions.js</code> estar\u00e1n disponibles para su uso en <code>app.js</code>.</p> <p>Cuando una p\u00e1gina incluye muchos archivos JavaScript externos, puede ocurrir que la p\u00e1gina se muestre en blanco durante la fase de renderizado. Para evitar este problema, se recomienda incluir los archivos JavaScript justo antes del cierre de la etiqueta <code>&lt;/body&gt;</code>, como se muestra a continuaci\u00f3n:</p> html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;!-- Otros elementos del encabezado --&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- Contenido de la p\u00e1gina --&gt;\n\n    &lt;!-- Scripts al final del cuerpo --&gt;\n    &lt;script src=\"js/functions.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"js/app.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"javascript/primeros-pasos/#los-atributos-async-y-defer","title":"Los Atributos Async y Defer:","text":"<p>En la pr\u00e1ctica, es importante que el JavaScript no bloquee el renderizado del contenido de la p\u00e1gina, especialmente cuando se trabaja con muchos archivos o bibliotecas externas. Aqu\u00ed es donde entran en juego los atributos <code>async</code> y <code>defer</code> de la etiqueta <code>&lt;script&gt;</code>.</p>"},{"location":"javascript/primeros-pasos/#atributo-async-asincrono","title":"Atributo Async (As\u00edncrono):","text":"<p>El atributo <code>async</code> permite que el script se descargue en paralelo con la p\u00e1gina. Esto puede mejorar la velocidad de carga porque el navegador no tiene que esperar a que el script se descargue y ejecute antes de continuar renderizando el resto del contenido.</p> <p>Sin embargo <code>async</code> no garantiza que los scripts se ejecuten en el orden en que se declaran, lo que puede causar problemas si un script depende de otro.</p> html<pre><code>&lt;script async src=\"js/functions.js\"&gt;&lt;/script&gt;\n&lt;script async src=\"js/app.js\"&gt;&lt;/script&gt;\n</code></pre> <p>En el ejemplo anterior el archivo <code>app.js</code> podr\u00eda ejecutarse antes que el archivo <code>functions.js</code>. Por lo tanto, debes asegurarte de que no exista dependencia entre ellos.</p>"},{"location":"javascript/primeros-pasos/#atributo-defer-diferir","title":"Atributo Defer (Diferir):","text":"<p>El atributo <code>defer</code> por otro lado, asegura que los scripts se ejecuten en el orden en que aparecen en el documento HTML. Adem\u00e1s, garantiza que el script no se ejecute hasta que el navegador haya terminado de procesar completamente el HTML, lo que puede ser \u00fatil para asegurarse de que el DOM est\u00e9 listo para interactuar con el JavaScript.</p> html<pre><code>&lt;script defer src=\"js/app.js\"&gt;&lt;/script&gt;\n</code></pre> <p>Aunque coloquemos el elemento <code>&lt;script&gt;</code> en el <code>&lt;head&gt;</code>, el script esperar\u00e1 hasta que el navegador reciba el elemento <code>&lt;/html&gt;</code> de cierre para comenzar a ejecutarse.</p>"},{"location":"javascript/primeros-pasos/#buenas-practicas-en-la-inclusion-de-javascript","title":"Buenas Pr\u00e1cticas en la Inclusi\u00f3n de JavaScript","text":"<p>A medida que los proyectos web crecen, es \u00fatil seguir ciertas pr\u00e1cticas recomendadas para asegurarse de que el c\u00f3digo sea mantenible, eficiente y f\u00e1cil de entender para otros desarrolladores.</p> <ol> <li>Ubicaci\u00f3n de las etiquetas <code>&lt;script&gt;</code>: Aunque puedes colocar las etiquetas <code>&lt;script&gt;</code> en la cabecera del documento HTML (<code>&lt;head&gt;</code>), una mejor pr\u00e1ctica es colocarlas justo antes de la etiqueta de cierre del cuerpo (<code>&lt;/body&gt;</code>). Esto asegura que el contenido de la p\u00e1gina se cargue antes de ejecutar cualquier script, mejorando la experiencia del usuario y la percepci\u00f3n de la velocidad de carga de la p\u00e1gina.</li> <li>Modularidad: A medida que tu c\u00f3digo JavaScript crece, es recomendable dividirlo en m\u00f3dulos. Desde la llegada de ES6, JavaScript soporta m\u00f3dulos nativos, lo que facilita la organizaci\u00f3n del c\u00f3digo en partes reutilizables y bien definidas.</li> <li>Uso de herramientas para mejorar el c\u00f3digo: Para mantener una alta calidad en el c\u00f3digo, herramientas como ESLint y Prettier juegan un papel importante. Estas herramientas analizan el c\u00f3digo en busca de errores de sintaxis, inconsistencias o malas pr\u00e1cticas. Adem\u00e1s, pueden formatear autom\u00e1ticamente el c\u00f3digo para seguir un estilo consistente.</li> </ol>"},{"location":"javascript/primeros-pasos/#compatibilidad-con-todos-los-navegadores","title":"Compatibilidad con Todos los Navegadores","text":"<p>Uno de los aspectos m\u00e1s importantes al trabajar con JavaScript es asegurarse de que tu c\u00f3digo funcione correctamente en diferentes navegadores. Aunque la mayor\u00eda de los navegadores modernos soportan las \u00faltimas caracter\u00edsticas de JavaScript, algunos, especialmente los m\u00e1s antiguos, pueden no ser compatibles con ciertas funciones avanzadas.</p>"},{"location":"javascript/primeros-pasos/#uso-de-polyfills","title":"Uso de Polyfills","text":"<p>Los polyfills son fragmentos de c\u00f3digo que permiten que las funcionalidades modernas de JavaScript se ejecuten en navegadores antiguos. Por ejemplo, si deseas usar la funci\u00f3n <code>Array.prototype.includes()</code>, que no est\u00e1 disponible en todos los navegadores, puedes incluir un polyfill para asegurarte de que funcione en navegadores que no soportan esta funci\u00f3n.</p>"},{"location":"javascript/primeros-pasos/#conclusion","title":"Conclusi\u00f3n:","text":"<p>JavaScript es un lenguaje extremadamente poderoso y vers\u00e1til que ha evolucionado significativamente desde sus inicios. Saber c\u00f3mo integrarlo correctamente en tus proyectos HTML es solo el primer paso para desbloquear su potencial. Al seguir buenas pr\u00e1cticas, usar m\u00f3dulos y aprovechar las herramientas disponibles para mejorar la calidad del c\u00f3digo, podr\u00e1s crear aplicaciones web m\u00e1s r\u00e1pidas, eficientes y f\u00e1ciles de mantener.</p> <p></p>"},{"location":"javascript/que-es-javascript/","title":"\u00bfQu\u00e9 es JavaScript?","text":""},{"location":"javascript/que-es-javascript/#que-es-javascript","title":"\u00bfQu\u00e9 es JavaScript?","text":"<p>JavaScript es un lenguaje de programaci\u00f3n vers\u00e1til y ampliamente utilizado en el desarrollo web. Este fue dise\u00f1ado inicialmente para interactuar con elementos de p\u00e1ginas web y hoy d\u00eda permite a los desarrolladores implementar aplicaciones complejas, incluso afueras del entorno web.</p> <p>Dentro de los navegadores web, JavaScript consta de tres partes principales:</p> <ul> <li>ECMAScript: proporciona la funcionalidad principal.</li> <li>DOM (Document Object Model): proporciona interfaces para interactuar con elementos en p\u00e1ginas web.</li> <li>BOM (Browser Object Model): proporciona la API para interactuar con el navegador web.</li> </ul> <p>JavaScript es una poderosa herramienta para agregar interactividad y dinamismo a las p\u00e1ginas web, desempe\u00f1ando un papel fundamental como la tercera capa de las tecnolog\u00edas web est\u00e1ndar junto a HTML y CSS.</p> <p> M\u00e1s all\u00e1 de solo mejorar la funcionalidad de una p\u00e1gina, JavaScript permite crear experiencias de usuario m\u00e1s ricas e inmersivas. Desde la validaci\u00f3n instant\u00e1nea de formularios hasta la creaci\u00f3n de aplicaciones complejas y din\u00e1micas, pasando por la visualizaci\u00f3n de datos en tiempo real y el desarrollo de interfaces de usuario interactivas. Las posibilidades con JavaScript son casi ilimitadas.</p> <p></p> <p>Con el advenimiento de bibliotecas y frameworks modernos como React, Angular y Vue.js entre otros, el desarrollo web con JavaScript ha alcanzado un nuevo nivel de sofisticaci\u00f3n y eficiencia, permitiendo a los desarrolladores construir aplicaciones web m\u00e1s r\u00e1pidas, escalables y est\u00e9ticamente atractivas.</p>"},{"location":"javascript/que-es-javascript/#como-funciona-javascript","title":"\u00bfC\u00f3mo funciona JavaScript?","text":"<p>Cuando una p\u00e1gina web se carga en un navegador, el proceso de renderizado comienza con la descarga y an\u00e1lisis del HTML y el CSS asociados. Una vez que estos recursos se han descargado y analizado el navegador procede a ejecutar cualquier c\u00f3digo JavaScript presente en la p\u00e1gina. Esta etapa es la mas importante para la interactividad y dinamismo ya que permite que el sitio web responda a la interacci\u00f3n del usuario de manera activa.</p> <p>Por ejemplo, JavaScript puede agregar o eliminar elementos del DOM en funci\u00f3n de las acciones del usuario, como hacer clic en un bot\u00f3n o ingresar datos en un formulario. Adem\u00e1s, el script puede manipular estilos CSS y realizar solicitudes de red para cargar datos adicionales, todo en tiempo real sin necesidad de recargar la p\u00e1gina u aplicaci\u00f3n.</p>"},{"location":"javascript/que-es-javascript/#motores-javascript","title":"Motores JavaScript","text":"<p>El motor JavaScript es un componente esencial de los navegadores web, son el encargado de interpretar y ejecutar el c\u00f3digo JavaScript. Est\u00e1 compuesto por un analizador para examinar el c\u00f3digo, un compilador para convertirlo en c\u00f3digo de m\u00e1quina y un int\u00e9rprete para ejecutar el c\u00f3digo compilado.</p> <p>Los navegadores utilizan diversos motores de JavaScript para ejecutar el c\u00f3digo de manera eficiente. Algunos de los motores m\u00e1s destacados son V8 en Chrome, SpiderMonkey en Firefox y JavaScriptCore en Safari.</p> <p>Inicialmente los motores JavaScript se implementaban como int\u00e9rpretes. Sin embargo, en la actualidad los motores modernos se basan com\u00fanmente en compiladores (just-in-time) que convierten el c\u00f3digo JavaScript en c\u00f3digo de bytes para mejorar el rendimiento.</p>"},{"location":"javascript/que-es-javascript/#javascript-lado-del-cliente-vs-servidor","title":"JavaScript: lado del cliente vs servidor","text":"<p>JavaScript es un lenguaje de programaci\u00f3n que se puede utilizar tanto en el cliente como en el servidor. Aqu\u00ed tienes un resumen de las diferencias entre ambos:</p>"},{"location":"javascript/que-es-javascript/#javascript-del-lado-del-cliente-client-side","title":"JavaScript del Lado del Cliente (Client-Side):","text":"<ul> <li>Se ejecuta en el navegador del usuario.</li> <li>Se utiliza para crear interacciones din\u00e1micas en la p\u00e1gina web.</li> <li>Ejemplos incluyen animaciones, formularios interactivos y contenido que cambia sin recargar la p\u00e1gina.</li> </ul>"},{"location":"javascript/que-es-javascript/#javascript-del-lado-del-servidor-server-side","title":"JavaScript del Lado del Servidor (Server-Side):","text":"<ul> <li>Se ejecuta en el servidor, en plataformas como Node.js.</li> <li>Se utiliza para manejar solicitudes, interactuar con bases de datos y servir contenido din\u00e1mico al cliente.</li> <li>Ejemplos incluyen autenticaci\u00f3n de usuarios, operaciones con bases de datos y generaci\u00f3n de p\u00e1ginas web din\u00e1micas.</li> </ul> <p>Ambos lados trabajan juntos para ofrecer una experiencia web completa y funcional.</p>"},{"location":"javascript/que-es-javascript/#resumen-de-la-historia-de-javascript","title":"Resumen de la historia de JavaScript","text":"<p>JavaScript fue desarrollado por Brendan Eich de Netscape en 1995, inicialmente conocido como Mocha y luego renombrado como LiveScript. Netscape decidi\u00f3 cambiar el nombre a JavaScript para aprovechar la popularidad de Java, coincidiendo con el lanzamiento de Netscape Navigator 2.</p> <p>Netscape lanz\u00f3 JavaScript 1.1 con Netscape Navigator 3, mientras que Microsoft present\u00f3 Internet Explorer 3 (IE 3) con su propia implementaci\u00f3n llamada JScript. Esto dio lugar a dos versiones de JavaScript en el mercado.</p> <p>En 1997, JavaScript 1.1 se propuso a la European Computer Manufacturers Association (ECMA) para su estandarizaci\u00f3n. El Comit\u00e9 T\u00e9cnico #39 (TC39) fue asignado para estandarizar el lenguaje, dando lugar a ECMAScript, una especificaci\u00f3n para un lenguaje de secuencias de comandos multiplataforma.</p> <p>ECMA-262 fue la norma resultante, y ECMAScript fue adoptado por la Organizaci\u00f3n Internacional de Normalizaci\u00f3n (ISO/IEC), estableciendo un est\u00e1ndar para el lenguaje de programaci\u00f3n JavaScript moderno.</p>"},{"location":"javascript/que-es-javascript/#primer-vistazo-del-lenguaje","title":"Primer vistazo del lenguaje","text":"<p>El siguiente apartado ofrece una s\u00f3lida introducci\u00f3n al c\u00f3digo de JavaScript. Si a\u00fan no est\u00e1s familiarizado con \u00e9l, est\u00e1 bien. Tendr\u00e1s la oportunidad de aprender en el pr\u00f3ximo tutorial.</p>"},{"location":"javascript/que-es-javascript/#declarar-variables","title":"Declarar variables","text":"<p>Para definir una variable en JavaScript utilizamos la palabra clave <code>var</code>:</p> javascript<pre><code>var name = \"James\";\nvar age = 20;\n</code></pre> <p>JavaScript tambi\u00e9n introdujo una nueva forma de declarar variables con la palabra clave <code>let</code>:</p> javascript<pre><code>let x = 10;\nlet y = 20;\n</code></pre> <p> Hablaremos m\u00e1s sobre las diferencias entre var y let en pr\u00f3ximos tutoriales, pero por ahora es una buena pr\u00e1ctica utilizar let para declarar variables.</p> <p></p>"},{"location":"javascript/que-es-javascript/#definir-funciones","title":"Definir Funciones","text":"<p>Para declarar una funci\u00f3n en JavaScript, usamos la palabra clave <code>function</code>:</p> javascript<pre><code>function add(a, b) {\n  return a + b;\n}\n</code></pre> <p>Esta funci\u00f3n <code>add()</code> toma dos argumentos y devuelve su suma. Para llamar a la funci\u00f3n utilizamos la siguiente sintaxis:</p> javascript<pre><code>let x = 10;\nlet y = 20;\n\nfunction add(a, b) {\n  return a + b;\n}\nlet result = add(x, y);\n\nconsole.log(result);\n</code></pre> <p>En el anterior ejemplo pasamos las variables <code>x</code> y <code>y</code> como argumentos a la funci\u00f3n <code>add()</code> y almacenamos el resultado en la variable <code>result</code>.</p>"},{"location":"javascript/que-es-javascript/#condicionales","title":"Condicionales","text":"<p>JavaScript tambi\u00e9n nos proporciona declaraciones de condici\u00f3n como <code>if-else</code> y <code>switch</code>. Por ejemplo:</p> javascript<pre><code>function divide(a, b) {\n  if (b === 0) {\n    throw 'Divisi\u00f3n por cero';\n  }\n  return a / b;\n}\n</code></pre> <p>En esta funci\u00f3n <code>divide()</code> verificamos si el denominador <code>b</code> es cero. Si es as\u00ed, lanzamos una excepci\u00f3n. De lo contrario, devolvemos el resultado de <code>a/b</code>.</p>"},{"location":"javascript/que-es-javascript/#arrays-matrices","title":"Arrays (Matrices)","text":"<p>Para declarar un array en JavaScript, utilizamos la siguiente sintaxis:</p> javascript<pre><code>let items = [];\n</code></pre> <p>Tambi\u00e9n puedes declarar un array con elementos iniciales:</p> javascript<pre><code>let items = [1, 2, 3];\n</code></pre> <p>Para iterar sobre los elementos del array, puedes usar un bucle <code>for</code>:</p> javascript<pre><code>let items = [1, 2, 3];\n\nfor (let i = 0; i &lt; items.length; i++) {\n  console.log(items[i]);\n}\n</code></pre> <p>Alternativamente, puedes utilizar el bucle <code>for...of</code> introducido en ES6:</p> javascript<pre><code>let items = [1, 2, 3];\n\nfor(let item of items) {\n    console.log(item);\n}\n</code></pre> <p>Este ejemplo introductorio te ha dado un primer vistazo a algunos de los conceptos b\u00e1sicos de JavaScript. En los pr\u00f3ximos tutoriales, profundizaremos a\u00fan m\u00e1s en el lenguaje y aprenderemos a utilizarlo de manera m\u00e1s efectiva.</p> <p>A medida que la web contin\u00faa evolucionando, JavaScript se afianza como una herramienta fundamental en el desarrollo web moderno. Con su versatilidad y capacidades en constante expansi\u00f3n, este lenguaje de programaci\u00f3n permite a los desarrolladores crear experiencias de usuario cada vez m\u00e1s ricas e interactivas, tanto en el lado del cliente como del servidor.</p> <p></p>"},{"location":"javascript/sintaxis-javascript/","title":"Sintaxis de JavaScript","text":""},{"location":"javascript/sintaxis-javascript/#sintaxis-de-javascript-fundamentos-y-elementos-clave","title":"Sintaxis de JavaScript: Fundamentos y Elementos Clave","text":"<p>La sintaxis de JavaScript define las reglas y estructuras que se deben seguir para escribir c\u00f3digo v\u00e1lido. Es fundamental comprender los conceptos b\u00e1sicos para evitar errores y aprovechar al m\u00e1ximo las capacidades del lenguaje. En este art\u00edculo exploraremos los aspectos esenciales de la sintaxis de JavaScript, incluyendo declaraciones, identificadores, comentarios, expresiones y palabras reservadas.</p>"},{"location":"javascript/sintaxis-javascript/#declaraciones-en-javascript","title":"Declaraciones en JavaScript","text":"<p>Las declaraciones son instrucciones que indican al programa que realice una acci\u00f3n espec\u00edfica, como asignar un valor a una variable, llamar a una funci\u00f3n o ejecutar un bucle. En JavaScript, las declaraciones generalmente terminan con un punto y coma (<code>;</code>), aunque no es obligatorio se recomienda para mejorar la legibilidad y evitar errores.</p> <p>Las declaraciones son la base para construir cualquier l\u00f3gica en JavaScript. Cada l\u00ednea de c\u00f3digo ejecutable en un programa se considera una declaraci\u00f3n.</p>"},{"location":"javascript/sintaxis-javascript/#ejemplo-de-declaracion","title":"Ejemplo de Declaraci\u00f3n:","text":"javascript<pre><code>const mensaje = \"Hola, mundo\";\nconsole.log(mensaje);\n</code></pre> <p>En el ejemplo anterior la primera declaraci\u00f3n asigna un valor a la variable <code>mensaje</code>, mientras que la segunda muestra el valor en la consola.</p> <p>Buenas pr\u00e1cticas: Es recomendable seguir estas pautas para que el c\u00f3digo sea m\u00e1s legible:</p> <ul> <li>Usar una declaraci\u00f3n por l\u00ednea: Evita combinar m\u00faltiples declaraciones en una sola l\u00ednea.</li> <li>Terminar cada declaraci\u00f3n con un punto y coma (<code>;</code>): Aunque JavaScript puede interpretar las declaraciones sin \u00e9l, es mejor incluirlo para prevenir errores en c\u00f3digo m\u00e1s complejo.</li> </ul>"},{"location":"javascript/sintaxis-javascript/#bloques-en-javascript","title":"Bloques en JavaScript","text":"<p>Los bloques de c\u00f3digo son secuencias de declaraciones agrupadas entre llaves {\u2026}. Estos son comunes en las estructuras de control como los bucles y funciones, adem\u00e1s estos permiten controlar el \u00e1mbito (scope) de las variables.</p> <p>Los bloques permiten organizar el c\u00f3digo en secciones manejables delimitando su \u00e1mbito. Esto es especialmente \u00fatil cuando se trabaja con estructuras de control, como condicionales y bucles para asegurar que el flujo del programa se comporte de manera esperada.</p> javascript<pre><code>const condicion = true;\n\nif (condicion) {\n  // Declaraciones dentro del bloque if\n} else {\n  // Declaraciones dentro del bloque else\n}\n\nwhile (condicion) {\n  // Declaraciones dentro del bloque while\n}\n</code></pre> <p>En el anterior snippet se muestra como los bloques ayudan a definir las acciones a realizar en diferentes condiciones o repeticiones.</p> <p> Es importante recordar que JavaScript utiliza el alcance l\u00e9xico, lo que significa que las variables declaradas dentro de un bloque estar\u00e1n disponibles solo dentro de ese bloque y de los bloques internos, pero no fuera de ellos.</p> <p></p>"},{"location":"javascript/sintaxis-javascript/#identificadores-en-javascript","title":"Identificadores en JavaScript","text":"<p>Los identificadores son nombres que se utilizan para referirse a variables, funciones, clases y otros elementos del programa. Estos deben seguir ciertas reglas de nomenclatura. Ejemplo: Deben comenzar con una letra, guion bajo (<code>_</code>) o signo de d\u00f3lar (<code>$</code>) y pueden contener letras, n\u00fameros, guiones bajos y signos de d\u00f3lar.</p> <p>Elegir identificadores claros y descriptivos es importante para que el c\u00f3digo sea f\u00e1cil de entender. Adem\u00e1s, es fundamental seguir las convenciones y reglas de nomenclatura para evitar errores.</p> <p>Ejemplo: Identificadores v\u00e1lidos:</p> javascript<pre><code>let nombreUsuario = \"Carlos\";\nlet _resultado = 100;\nlet $totalVentas = 5000;\n</code></pre> <p> Ten en cuenta que la letra inicial no se limita al conjunto de caracteres ASCII y puede incluir caracteres ASCII extendidos o Unicode, aunque no se recomienda su uso.</p> <p></p> <p>Reglas importantes:</p> <ul> <li>Los identificadores son sensibles a may\u00fasculas y min\u00fasculas (<code>variable</code> y <code>Variable</code> se consideran diferentes).</li> <li>No se pueden utilizar palabras clave reservadas como identificadores, ya que est\u00e1n reservadas para funciones espec\u00edficas del lenguaje.</li> </ul>"},{"location":"javascript/sintaxis-javascript/#javascript-es-case-sensitive","title":"JavaScript es Case Sensitive","text":"<p>Los identificadores en JavaScript son sensibles a may\u00fasculas y min\u00fasculas. Esto significa que el lenguaje trata las letras may\u00fasculas y min\u00fasculas como caracteres diferentes. Por lo tanto, en el siguiente ejemplo los identificadores <code>message</code> y <code>Message</code> ser\u00edan considerados dos variables distintas.</p> javascript<pre><code>var message = \"Hola, esto es un mensaje.\";\nvar Message = \"Esto es otro mensaje.\";\n\nconsole.log(message);\nconsole.log(Message);\n</code></pre> <p>Es importante recordar esta distinci\u00f3n al nombrar tus variables y al referenciarlas m\u00e1s adelante en tu c\u00f3digo para evitar confusiones o errores inesperados.</p>"},{"location":"javascript/sintaxis-javascript/#comentarios-en-javascript","title":"Comentarios en JavaScript","text":"<p>Los comentarios son partes del c\u00f3digo que se ignoran durante la ejecuci\u00f3n del programa. Se utilizan para documentar el c\u00f3digo, explicar el prop\u00f3sito de ciertas secciones o anotar cosas que se deben hacer.</p> <p>El uso de comentarios es una pr\u00e1ctica com\u00fan para mejorar la legibilidad del c\u00f3digo y facilitar la colaboraci\u00f3n entre desarrolladores, proporcionando una mejor comprensi\u00f3n del prop\u00f3sito de las instrucciones o dejando notas \u00fatiles.</p>"},{"location":"javascript/sintaxis-javascript/#comentarios-de-una-sola-linea","title":"Comentarios de Una Sola L\u00ednea:","text":"<p>Para crear un comentario de una sola l\u00ednea en JavaScript, simplemente debes a\u00f1adir dos barras inclinadas (<code>//</code>) antes del texto que actuar\u00e1 como comentario.</p> javascript<pre><code>// Esto es un comentario de una sola l\u00ednea\n</code></pre>"},{"location":"javascript/sintaxis-javascript/#comentarios-de-bloque","title":"Comentarios de Bloque","text":"<p>Para crear un comentario de bloque o de varias l\u00edneas en JavaScript, utilizamos una barra inclinada seguida de un asterisco (<code>/*</code>) para iniciar el comentario y a\u00f1adimos un asterisco seguido de una barra inclinada (<code>*/</code>) para finalizarlo.</p> javascript<pre><code>/* \n  Esto es un comentario \n  de m\u00faltiples l\u00edneas \n*/\n</code></pre> <p> Utilizar comentarios de manera efectiva puede ayudar a identificar r\u00e1pidamente secciones clave del c\u00f3digo y entender su prop\u00f3sito.</p> <p></p>"},{"location":"javascript/sintaxis-javascript/#expresiones-en-javascript","title":"Expresiones en JavaScript","text":"<p>Una expresi\u00f3n es cualquier combinaci\u00f3n de valores, variables, operadores y funciones que se eval\u00faa para producir un resultado. Las expresiones son esenciales en JavaScript ya que permiten realizar operaciones y evaluar condiciones.</p> <p>Las expresiones son las piezas b\u00e1sicas y pueden ser tan simples como un valor num\u00e9rico o tan complejas como una combinaci\u00f3n de m\u00faltiples operadores y funciones.</p>"},{"location":"javascript/sintaxis-javascript/#tipos-comunes-de-expresiones","title":"Tipos Comunes de Expresiones:","text":"<ol> <li>Expresiones aritm\u00e9ticas: Las expresiones aritm\u00e9ticas son \u00fatiles para c\u00e1lculos matem\u00e1ticos, como sumar, restar, multiplicar o dividir.</li> </ol> javascript<pre><code>const suma = 5 + 3;\n</code></pre> <ol> <li>Expresiones l\u00f3gicas: Eval\u00faan condiciones y devuelven valores booleanos (<code>true</code> o <code>false</code>). Son comunes en las estructuras de control, como <code>if</code>, <code>while</code> y <code>for</code>, donde las condiciones determinan el flujo de ejecuci\u00f3n.</li> </ol> javascript<pre><code>const esMayor = 10 &gt; 5;\n</code></pre> <ol> <li>Expresiones de asignaci\u00f3n: Permiten almacenar el resultado de una operaci\u00f3n o valor en una variable para su uso posterior.</li> </ol> javascript<pre><code>const resultado = 20;\n</code></pre> <p>B\u00e1sicamente las expresiones son la base de los c\u00e1lculos, la l\u00f3gica y la programaci\u00f3n en general.</p>"},{"location":"javascript/sintaxis-javascript/#palabras-clave-y-palabras-reservadas","title":"Palabras Clave y Palabras Reservadas","text":"<p>JavaScript tiene palabras clave reservadas para usos espec\u00edficos y exclusivos del lenguaje. Estas palabras no se pueden usar como nombres de variables, funciones o identificadores ya que est\u00e1n destinadas a funciones espec\u00edficas, como declarar variables, definir funciones o controlar el flujo del programa.</p> <p>La siguiente tabla muestra las palabras reservadas de JavaScript tal como se definen en ECMA-262:</p> Claves break case catch continue debugger default else export extends function if import new return super throw try null void while with class delete finally in switch typeof yield const do for instanceof this var <p>Adem\u00e1s de las palabras clave reservadas, ECMA-252 tambi\u00e9n define una lista de futuras palabras reservadas que no se pueden utilizar como identificadores o nombres de propiedad:</p> Claves enum implements let protected private public await interface package implements public <p>Conocer las palabras clave es importante para evitar errores de sintaxis y comprender mejor las funciones internas del lenguaje.</p>"},{"location":"javascript/sintaxis-javascript/#conclusion","title":"Conclusi\u00f3n","text":"<p>Comprender la sintaxis de JavaScript es fundamental para escribir c\u00f3digo correctamente. Conocer los conceptos b\u00e1sicos como declaraciones, bloques, identificadores, comentarios, expresiones y palabras clave te permitir\u00e1 avanzar con confianza en el aprendizaje de JavaScript. Estos fundamentos son esenciales para construir aplicaciones m\u00e1s complejas y aprovechar al m\u00e1ximo las capacidades del lenguaje.</p> <p>En el siguiente art\u00edculo exploraremos las variables en JavaScript, c\u00f3mo se declaran y gestionan, as\u00ed como las diferencias entre <code>var</code>, <code>let</code> y <code>const</code>.</p> <p></p>"},{"location":"javascript/tipos-de-datos/","title":"Tipos de datos","text":""},{"location":"javascript/tipos-de-datos/#tipos-de-datos","title":"Tipos de datos","text":"<p>En JavaScript los tipos de datos son fundamentales para gestionar y manipular la informaci\u00f3n. Entender los diferentes tipos y c\u00f3mo funcionan es esencial para escribir c\u00f3digo eficiente. JavaScript tiene varios tipos de datos que se dividen en dos categor\u00edas principales: primitivos y de referencia. En este art\u00edculo, exploraremos cada tipo de dato en JavaScript, c\u00f3mo funcionan y ejemplos pr\u00e1cticos para ilustrar su uso.</p>"},{"location":"javascript/tipos-de-datos/#conocer-el-tipo-de-dato-en-javascript","title":"Conocer el Tipo de Dato en JavaScript","text":"<p>JavaScript es un lenguaje de tipado din\u00e1mico, lo que significa que una variable puede contener valores de diferentes tipos sin estar vinculada a uno espec\u00edfico. Por ejemplo:</p> javascript<pre><code>let score = 10;      // score es un n\u00famero\nscore = true;        // score ahora es un booleano\nscore = \"ganador\";   // score ahora es una cadena de texto\n</code></pre> <p>Por lo tanto es importante determinar el tipo actual del valor almacenado en una variable. Para hacerlo utilizamos el operador <code>typeof</code>.</p> javascript<pre><code>let score = 10;\nconsole.log(typeof(score));\n\nscore = false; \nconsole.log(typeof(score));\n\nscore = \"Hi\";\nconsole.log(typeof(score));\n</code></pre> <p>Ahora que sabemos identificar el tipo de dato de una variable, podemos conocer como estos est\u00e1n definidos en JavaScript. Comencemos con los primitivos:</p>"},{"location":"javascript/tipos-de-datos/#tipos-de-datos-primitivos","title":"Tipos de Datos Primitivos","text":"<p>Los tipos primitivos son los m\u00e1s b\u00e1sicos y simples en JavaScript. Estos se caracterizan por ser inmutables, lo que significa que su valor no se puede cambiar una vez creado.</p> <p>Los tipos de datos primitivos en JavaScript son: <code>null</code>, <code>undefined</code>, <code>boolean</code>, <code>number</code>, <code>string</code>, <code>symbol</code>, <code>bigint</code></p>"},{"location":"javascript/tipos-de-datos/#1-tipo-indefinido-undefined","title":"1. Tipo Indefinido: <code>undefined</code>","text":"<p>El tipo de dato <code>undefined</code> es una propiedad del objeto global y se utiliza para representar una variable que se ha declarado pero a la que a\u00fan no se le ha asignado un valor. Es decir, representa la ausencia de un valor definido.</p> javascript<pre><code>let score;\n\nconsole.log(score);\nconsole.log(typeof score);\n</code></pre>"},{"location":"javascript/tipos-de-datos/#2-tipo-nulo-null","title":"2. Tipo Nulo: <code>null</code>","text":"<p>En JavaScript el valor <code>null</code> representa la ausencia intencional de un valor. Es uno de los valores primitivos y se utiliza cuando se quiere indicar que una variable no tiene un valor asignado o que est\u00e1 \u201cvac\u00eda\u201d.</p> javascript<pre><code>let score = null;\n\nif (score === null) {\n  console.log('Aun no tienes un score iniciado');\n} else {\n  console.log(\"Tu score es \" + score);\n}\n</code></pre> <p>A diferencia de <code>undefined</code>, <code>null</code> se asigna expl\u00edcitamente a una variable como representaci\u00f3n de la ausencia de valor.</p>"},{"location":"javascript/tipos-de-datos/#3-tipo-numero-number","title":"3. Tipo N\u00famero: <code>number</code>","text":"<p>El tipo de dato <code>number</code> incluye tanto n\u00fameros enteros como n\u00fameros decimales. En JavaScript no hay distinci\u00f3n entre n\u00fameros enteros e \u00edndices flotantes.</p> javascript<pre><code>const entero = 42;\nconst decimal = 3.14;\nconst negativo = -10;\n</code></pre> <p>Casos especiales de <code>number</code></p> <ul> <li><code>Infinity</code>: Resultado de dividir un n\u00famero por cero.</li> <li><code>-Infinity</code>: Resultado de dividir un n\u00famero negativo por cero.</li> <li><code>NaN</code> (Not a Number): Indica que un valor no es num\u00e9rico.</li> </ul> javascript<pre><code>console.log(1 / 0);\nconsole.log(-1 / 0);\nconsole.log(\"hola\" * 2);\n</code></pre>"},{"location":"javascript/tipos-de-datos/#4-tipo-cadena-de-caracteres-string","title":"4. Tipo Cadena de Caracteres: <code>string</code>","text":"<p>El tipo de dato string o cadena se utiliza para representar una secuencia de caracteres y es uno de los tipos de datos m\u00e1s utilizados en JavaScript. Se puede definir con comillas simples, dobles o acento grave para los template literals, que permiten interpolaci\u00f3n de variables.</p> javascript<pre><code>let saludo = \"Hola\";\nlet nombre = 'Mundo';\nlet mensaje = `Hola, ${nombre}!`;  // Template literal\n\nconsole.log(mensaje);\n</code></pre> <p> Los tipos strings en JavaScript son inmutables, lo que quiere decir que no se pueden modificar una vez creadas. No obstante, puedes crear una nueva cadena a partir de una existente.</p> <p></p>"},{"location":"javascript/tipos-de-datos/#5-tipo-booleano-boolean","title":"5. Tipo Booleano: <code>boolean</code>","text":"<p>El tipo de dato <code>boolean</code> representa un valor l\u00f3gico que puede ser <code>true</code> o <code>false</code> (verdadero / falso). Es com\u00fanmente utilizado en condiciones y comparaciones.</p> javascript<pre><code>let esMayor = 10 &gt; 5;  // true\nlet esIgual = 10 === \"10\";  // false\n</code></pre> <p>Es importante destacar que en JavaScript algunos valores se consideran \u201c<code>falsy</code>\u201d o equivalentes a <code>false</code> cuando se eval\u00faan en un contexto booleano. Estos incluyen <code>0</code>, <code>-0</code>, <code>null</code>, <code>false</code>, <code>NaN</code>, <code>undefined</code> y un string vacio <code>\"\"</code>.</p> <p>Por otro lado, todos los dem\u00e1s valores se consideran \u201c<code>truthy</code>\u201d o equivalentes a <code>true</code>, incluyendo objetos, arreglos y cadenas no vac\u00edas.</p>"},{"location":"javascript/tipos-de-datos/#6-tipo-simbolo-symbol","title":"6. Tipo S\u00edmbolo: <code>Symbol</code>","text":"<p>El tipo <code>symbol</code> es un valor \u00fanico e inmutable usado com\u00fanmente como identificador para las propiedades de los objetos. Cada vez que se crea un <code>symbol</code> es \u00fanico.</p> javascript<pre><code>let id1 = Symbol(\"id\");\nlet id2 = Symbol(\"id\");\n\nconsole.log(id1 === id2);\n</code></pre> <p>La funci\u00f3n <code>Symbol()</code> crea un nuevo valor \u00fanico cada vez que se llama. Por lo tanto si intentamos comparar sus valores, obtendremos el valor booleano <code>false</code>:</p> javascript<pre><code>console.log(Symbol() == Symbol());\n</code></pre>"},{"location":"javascript/tipos-de-datos/#7-tipo-bigint","title":"7. Tipo Bigint","text":"<p>El tipo bigInt en JavaScript es un primitivo que se introdujo para representar n\u00fameros enteros m\u00e1s grandes que el valor m\u00e1ximo que puede manejar el tipo <code>Number</code> (que es <code>2^53 \u2013 1</code>). A diferencia de los n\u00fameros regulares, estos pueden ser grandes y precisos.</p> javascript<pre><code>let pageView = 9007199254740991n;\n\nconsole.log(typeof(pageView));\n</code></pre>"},{"location":"javascript/tipos-de-datos/#tipos-de-datos-de-referencia","title":"Tipos de Datos de Referencia","text":"<p>Los tipos no primitivos tambi\u00e9n conocidos como tipos de referencia, son m\u00e1s complejos, estos pueden contener una colecci\u00f3n de valores y tienen comportamientos m\u00e1s din\u00e1micos. Estos incluyen: <code>objects</code> (Objetos, Fechas, Arrays y Funciones)</p>"},{"location":"javascript/tipos-de-datos/#objetos-object","title":"Objetos (<code>Object</code>)","text":"javascript<pre><code>let persona = {\n  nombre: \"Juan\",\n  edad: 30,\n  saludar: function() {\n    console.log(\"Hola, soy \" + this.nombre);\n  }\n};\n\npersona.saludar();\n</code></pre>"},{"location":"javascript/tipos-de-datos/#funciones","title":"Funciones","text":"<p>En JavaScript las funciones son objetos ciudadanos de primera clase, lo que significa que se pueden almacenar en variables, pasarlas como argumentos y devolverlas como resultado.</p> javascript<pre><code>function sumar(a, b) {\n    return a + b;\n}\n\nconsole.log(sumar(5, 3));\n</code></pre>"},{"location":"javascript/tipos-de-datos/#fechas-date","title":"Fechas (<code>Date</code>)","text":"<p>El objeto <code>Date</code> se utiliza para trabajar con fechas y horas.</p> javascript<pre><code>const hoy = new Date();\n\nconsole.log(hoy.toDateString());\n</code></pre>"},{"location":"javascript/tipos-de-datos/#diferencias-entre-tipos-primitivos-y-referenciados","title":"Diferencias Entre Tipos Primitivos y Referenciados","text":"<p>Mutabilidad:</p> <ul> <li>Los tipos primitivos son inmutables. Modificar un valor primitivo crea un nuevo valor.</li> <li>Los tipos de referencia son mutables. Cambiar una propiedad de un objeto afecta directamente el valor.</li> </ul> <p>Asignaci\u00f3n y Comparaci\u00f3n:</p> <ul> <li>Cuando se asigna un tipo primitivo, se copia el valor. Con los datos de tipos referencia, se copia la referencia en memoria.</li> <li>Los tipos de referencia se comparan por su referencia, no por su contenido.</li> </ul>"},{"location":"javascript/tipos-de-datos/#conversion-entre-tipos-de-datos","title":"Conversi\u00f3n entre tipos de datos","text":"<p>Una de las potentes caracter\u00edsticas de JavaScript es su capacidad para convertir entre distintos tipos de datos. Esto puede hacerse utilizando las funciones de conversi\u00f3n incorporadas, como <code>Number()</code>, <code>String()</code> y <code>Boolean()</code>.</p> <p>Estas funciones pueden utilizarse para convertir un valor de un tipo de datos en un valor de un tipo de datos diferente sin cambiar los datos subyacentes. Pero de esto hablamos en profundidad en otros tutoriales.</p>"},{"location":"javascript/tipos-de-datos/#conclusion","title":"Conclusi\u00f3n","text":"<p>Entender los tipos de datos en JavaScript es clave para manipular la informaci\u00f3n correctamente. Al aprender sobre los tipos primitivos y de referencia, as\u00ed como sus diferencias, puedes evitar errores comunes y escribir c\u00f3digo m\u00e1s robusto.</p> <p>En el siguiente art\u00edculo nos sumergiremos en el manejo de n\u00fameros en JavaScript, abordando operaciones matem\u00e1ticas y trucos para trabajar con precisi\u00f3n.</p> <p></p>"},{"location":"javascript/var-let/","title":"Diferencias entre var, let y const","text":""},{"location":"javascript/var-let/#variables-diferencias-entre-var-let-y-const","title":"Variables: Diferencias entre var, let y const","text":"<p>En JavaScript existen tres formas principales de declarar variables: <code>var</code>, <code>let</code> y <code>const</code>. Cada una tiene caracter\u00edsticas espec\u00edficas que las hacen adecuadas para diferentes situaciones. Comprender las diferencias entre ellas es importante para escribir c\u00f3digo predecible y evitar errores comunes.</p> <p>En este art\u00edculo exploraremos las particularidades de cada tipo de declaraci\u00f3n, sus \u00e1mbitos, el comportamiento en la elevaci\u00f3n (hoisting), la zona muerta temporal y otros detalles clave.</p>"},{"location":"javascript/var-let/#el-ambitos-de-las-variables","title":"El \u00c1mbitos de las Variables","text":"<p>El concepto de \u00e1mbito de variable hace referencia a la regi\u00f3n del c\u00f3digo donde esta es v\u00e1lida y accesible. En JavaScript la palabra clave <code>var</code> tiene un \u00e1mbito global o de funci\u00f3n, lo que significa que las variables declaradas con esta keyword pueden ser accedidas o modificadas desde fuera de un bloque espec\u00edfico.</p> <p>Si declaramos una variable con <code>var</code> fuera de una funci\u00f3n, esta se convierte en una variable global y puede ser accedida desde cualquier parte del c\u00f3digo:</p> javascript<pre><code>var age = 30;\n\nfunction printAge() {\n  console.log(age);\n}\n\nprintAge();\n</code></pre> <p>Cuando una variable se declara dentro de una funci\u00f3n utilizando var, su alcance se limita al contexto de esa funci\u00f3n, lo que significa que no puede ser accedida desde fuera de la funci\u00f3n. Por ejemplo:</p> javascript<pre><code>function greet() {\n  var message = \"\u00a1Hola!\";\n  console.log(message);\n}\n\ngreet();\nconsole.log(message);\n</code></pre> <p>Ahora, ya que tenemos el concepto del \u00e1mbito veamos que ofrece cada declaraci\u00f3n que utilizamos para definir variables.</p>"},{"location":"javascript/var-let/#la-forma-tradicional-de-declarar-variables-var","title":"La Forma Tradicional de Declarar Variables: <code>var</code>","text":"<p><code>var</code> fue la \u00fanica manera de declarar variables en JavaScript hasta la introducci\u00f3n de ES6. Aunque sigue siendo v\u00e1lida, esta presenta varias peculiaridades que pueden llevar a errores dif\u00edciles de rastrear. Veamos las principales:</p> <ul> <li>\u00c1mbito global o de funci\u00f3n: Las variables declaradas con <code>var</code> tienen un \u00e1mbito que se limita a la funci\u00f3n en la que se declaran o son globales si se declaran fuera de cualquier funci\u00f3n.</li> <li>Permite la redeclaraci\u00f3n: Es posible declarar la misma variable varias veces en el mismo \u00e1mbito, lo que puede generar confusi\u00f3n.</li> <li>Hoisting: Las variables declaradas con <code>var</code> se elevan al principio del contexto de ejecuci\u00f3n, con un valor inicial de <code>undefined</code>.</li> </ul> <p>Ejemplo de \u00e1mbito y hoisting con <code>var</code>:</p> javascript<pre><code>console.log(mensaje);\n\nvar mensaje = \"Hola, mundo\";\n\nfunction saludo() {\n  var mensajeInterno = \"Hola desde la funci\u00f3n\";\n  console.log(mensajeInterno);\n}\nsaludo();\n</code></pre> <p>En el ejemplo anterior la variable <code>mensaje</code> se eleva y tiene un valor <code>undefined</code> antes de ser asignada, lo que muestra la naturaleza del hoisting en <code>var</code>.</p>"},{"location":"javascript/var-let/#problema-de-la-creacion-de-propiedades-globales","title":"Problema de la Creaci\u00f3n de Propiedades Globales","text":"<p>Las variables globales definidas con <code>var</code> se agregan al objeto global como propiedades adicionales. Esto puede aumentar las posibilidades de conflictos con otras bibliotecas o scripts que tambi\u00e9n utilizan el objeto global para sus propias variables.</p> <p> En el navegador web, el objeto global es window, mientras que en Node.js es global.</p> <p></p>"},{"location":"javascript/var-let/#la-alternativa-moderna-let","title":"La Alternativa Moderna: <code>let</code>","text":"<p><code>let</code> es una mejora significativa introducida en ES6 para declarar variables de manera m\u00e1s segura. Su \u00e1mbito est\u00e1 limitado al bloque en el que se declara, lo que evita problemas comunes asociados con el uso de <code>var</code>.</p> <p>Caracter\u00edsticas de <code>let</code>:</p> <ul> <li>\u00c1mbito de bloque: Las variables declaradas con <code>let</code> solo son accesibles dentro del bloque en el que se declaran.</li> <li>No permite la redeclaraci\u00f3n en el mismo \u00e1mbito: Esto ayuda a evitar errores accidentales.</li> <li>Hoisting con inicializaci\u00f3n diferida: Aunque <code>let</code> se eleva, no se puede acceder a la variable antes de su declaraci\u00f3n debido a la \u201czona muerta temporal\u201d.</li> </ul>"},{"location":"javascript/var-let/#la-zona-muerta-temporal","title":"La Zona Muerta Temporal","text":"<p>La zona muerta temporal es el per\u00edodo entre el inicio del bloque y la declaraci\u00f3n de la variable <code>let</code>, durante el cual no se puede acceder a la variable. Intentar hacerlo generar\u00e1 un <code>ReferenceError</code>.</p> javascript<pre><code>{\n    console.log(nombre);\n    let nombre = \"Carlos\";\n}\n</code></pre> <p>En el ejemplo anterior <code>nombre</code> est\u00e1 en la zona muerta temporal hasta que se alcanza la declaraci\u00f3n.</p>"},{"location":"javascript/var-let/#declaracion-para-constantes-const","title":"Declaraci\u00f3n para Constantes: <code>const</code>","text":"<p><code>const</code> se utiliza para declarar constantes, es decir, \u201cvariables porque almacena un dato\u201d cuyo valor no puede cambiar una vez asignado. Sin embargo, si el valor es un objeto o un array sus propiedades o elementos pueden ser modificados.</p> <p>Caracter\u00edsticas de <code>const</code>:</p> <ul> <li>Debe ser inicializada al momento de la declaraci\u00f3n.</li> <li>No permite la reasignaci\u00f3n: Una vez asignado, el valor de una variable <code>const</code> no puede cambiar.</li> <li>\u00c1mbito de bloque: Al igual que <code>let</code>, las variables <code>const</code> solo est\u00e1n disponibles dentro del bloque en el que se declaran.</li> </ul> <p>Ejemplo de modificaci\u00f3n de un objeto constante:</p> javascript<pre><code>const usuario = { nombre: \"Ana\", edad: 30 };\nusuario.edad = 31;  // Esto es v\u00e1lido, ya que se modifica una propiedad, no la referencia\n\nconsole.log(usuario.edad);\n</code></pre>"},{"location":"javascript/var-let/#buenas-practicas-para-usar-var-let-y-const","title":"Buenas Pr\u00e1cticas para Usar <code>var</code>, <code>let</code> y <code>const</code>","text":"<ol> <li>Usar <code>const</code> de forma predeterminada: Siempre que el valor de una variable no cambie usa <code>const</code> para asegurar la inmutabilidad.</li> <li>Optar por <code>let</code> si necesitas cambiar el valor: Si el valor de la variable debe cambiar, usa <code>let</code>.</li> <li>Evitar <code>var</code>: Los problemas de alcance y hoisting hacen que <code>var</code> no sea la mejor opci\u00f3n en la mayor\u00eda de los casos.</li> </ol>"},{"location":"javascript/var-let/#conclusion","title":"Conclusi\u00f3n","text":"<p>Comprender las diferencias entre <code>var</code>, <code>let</code> y <code>const</code> es \u00fatil para escribir c\u00f3digo limpio y seguro en JavaScript. Utilizar la opci\u00f3n adecuada en cada situaci\u00f3n ayuda a evitar errores comunes y mejora la calidad del c\u00f3digo.</p> <p>En el pr\u00f3ximo art\u00edculo nos adentraremos en los tipos de datos en JavaScript, explorando cada uno en detalle.</p> <p></p>"},{"location":"javascript/variables/","title":"Variables","text":""},{"location":"javascript/variables/#variables","title":"Variables","text":"<p>Las variables son componentes importantes en JavaScript, ya que permiten almacenar y gestionar datos de manera eficiente. Al aprender a trabajar con variables se facilita el desarrollo de aplicaciones din\u00e1micas y funcionales. En este art\u00edculo exploraremos el trabajo de variables con JavaScript, el c\u00f3mo declararlas, asignarles valores y usarlas adecuadamente en el contexto de JavaScript.</p>"},{"location":"javascript/variables/#que-son-las-variables","title":"\u00bfQu\u00e9 son las Variables?","text":"<p>Las variables son contenedores que almacenan informaci\u00f3n que puede ser utilizada y modificada durante la ejecuci\u00f3n de un programa. Act\u00faan como etiquetas que hacen referencia a un valor, permitiendo que el c\u00f3digo sea m\u00e1s din\u00e1mico y f\u00e1cil de entender.</p> <p>En JavaScript, existen tres palabras clave principales para declarar variables: <code>var</code>, <code>let</code> y <code>const</code>. Cada una con caracter\u00edsticas espec\u00edficas que se utilizan en diferentes escenarios.</p>"},{"location":"javascript/variables/#declaracion-de-variables","title":"Declaraci\u00f3n de Variables","text":"<p>Antes de poder utilizar una variable es necesario declararla. A partir de ES6 se introdujeron las palabras clave <code>let</code> y <code>const</code> para mejorar el manejo de variables en comparaci\u00f3n con <code>var</code>.</p>"},{"location":"javascript/variables/#palabras-clave-para-declarar-variables","title":"Palabras Clave para Declarar Variables","text":"<ol> <li>La sentencia <code>var</code>: Se utiliza para declarar e inicializar variables con acceso en todo el programa. Estas pueden cambiar su valor y se elevan al inicio del programa.</li> <li>La sentencia <code>let</code>: Declaran variables accesibles solo dentro de su \u00e1mbito, como en funciones. Estas no se elevan al inicio del programa.</li> <li>La sentencia <code>const</code>: Se utiliza para declarar constantes cuyo valor no puede modificarse. Al igual que las variables let las constantes no se elevan al inicio del programa.</li> </ol> <p>Ejemplos de Declaraci\u00f3n:</p> javascript<pre><code>let nombre = \"Carlos\";\nconst edad = 30;\nvar pais = \"Espa\u00f1a\";\n</code></pre> <p>En este ejemplo <code>nombre</code> se declara con <code>let</code> para que su valor pueda cambiar, <code>edad</code> con <code>const</code> para mantenerla inmutable, y <code>pais</code> con <code>var</code>, aunque se recomienda el uso de <code>let</code> o <code>const</code>.</p>"},{"location":"javascript/variables/#nombres-de-variables-o-identificadores","title":"Nombres de Variables o Identificadores","text":"<p>Los identificadores son los nombres que asignamos a las variables y estas deben seguir ciertas reglas para ser v\u00e1lidos en JavaScript:</p> <ul> <li>Deben comenzar con una letra, guion bajo (<code>_</code>) o signo de d\u00f3lar (<code>$</code>), no con un n\u00famero.</li> <li>Pueden contener letras, n\u00fameros, guiones bajos o s\u00edmbolos de d\u00f3lar.</li> <li>Son sensibles a may\u00fasculas y min\u00fasculas (<code>variable</code> y <code>Variable</code> son diferentes).</li> <li>No deben coincidir con palabras reservadas del lenguaje, como <code>function</code> o <code>return</code>.</li> </ul>"},{"location":"javascript/variables/#buenas-practicas-al-nombrar-variables","title":"Buenas Pr\u00e1cticas al Nombrar Variables","text":"<ol> <li>Usar camelCase: Esto indica el comenzar con min\u00fascula y cada nueva palabra con may\u00fascula (<code>miVariableImportante</code>).</li> <li>Elegir nombres descriptivos: Evitar nombres gen\u00e9ricos como <code>x</code> o <code>data</code> a menos que el contexto sea claro.</li> </ol> <p> JavaScript es un lenguaje escrito din\u00e1micamente. Esto significa que no es necesario especificar el tipo de variable en la declaraci\u00f3n como otros lenguajes de tipo est\u00e1tico como Java o C#</p> <p></p> <p>Al nombrar constantes y variables es fundamental elegir nombres descriptivos que reflejen claramente su prop\u00f3sito y funci\u00f3n en el c\u00f3digo. Esto ayuda a mejorar la legibilidad y comprensi\u00f3n del c\u00f3digo tanto para ti como para otros desarrolladores que puedan trabajar con \u00e9l en el futuro.</p>"},{"location":"javascript/variables/#inicializacion-de-variables","title":"Inicializaci\u00f3n de Variables","text":"<p>La inicializaci\u00f3n de una variable consiste en asignarle un valor en el momento de su declaraci\u00f3n. Si una variable se declara sin inicializar su valor es <code>undefined</code>.</p> <p>Una vez que has declarado una variable o una constante puedes inicializarla asign\u00e1ndole un valor. Esto se logra mediante el operador de asignaci\u00f3n (<code>=</code>), seguido del nombre y el valor que deseas asignarle.</p> <p>Ejemplo de inicializaci\u00f3n:</p> javascript<pre><code>let saludo;\nconsole.log(saludo);\n\nsaludo = \"Hola, mundo\";\nconsole.log(saludo);\n</code></pre> <p>En este caso la variable <code>saludo</code> se declara pero no se inicializa hasta la segunda l\u00ednea, donde se le asigna un valor.</p> <p>Incluso podemos declarar y asignar m\u00faltiples variables al mismo tiempo, para esto separamos cada declaraci\u00f3n con una coma (<code>,</code>).</p> javascript<pre><code>let saludo = \"Hola\",\n    usuario = \"Pedro\",\n    estatus = true;\n</code></pre>"},{"location":"javascript/variables/#cambiar-el-valor-de-una-variable","title":"Cambiar el Valor de una Variable","text":"<p>Las variables declaradas con <code>let</code> o <code>var</code> pueden cambiar su valor durante la ejecuci\u00f3n del programa. Sin embargo, las declaradas con <code>const</code> no pueden ser reasignadas.</p> <p>Ejemplo: Cambio de Valor:</p> javascript<pre><code>let edad = 25;\nedad = 26;  // Cambio de valor\nconsole.log(edad);\n</code></pre>"},{"location":"javascript/variables/#diferencias-entre-variables-no-definidas-y-no-declaradas","title":"Diferencias Entre Variables no Definidas y no Declaradas","text":"<p>Es importante distinguir entre variables no definidas y no declaradas:</p> <ul> <li>Variable no definida: Ha sido declarada pero no se le ha asignado ning\u00fan valor, por lo que su valor es <code>undefined</code>.</li> <li>Variable no declarada: No ha sido definida en el c\u00f3digo, lo que provoca un error al intentar acceder a ella.</li> </ul> <p>Ejemplo: variable no definida vs. no declarada:</p> javascript<pre><code>let mensaje;\n\nconsole.log(mensaje);  // Output: undefined\nconsole.log(texto);  // Error: texto is not defined\n</code></pre>"},{"location":"javascript/variables/#variables-constantes-y-mutabilidad","title":"Variables Constantes y Mutabilidad","text":"<p>Las constantes declaradas con <code>const</code>, no permiten la reasignaci\u00f3n del valor una vez que ha sido definido. Sin embargo, si el valor es un objeto o un array sus propiedades o elementos internos pueden ser modificados.</p> <p>Ejemplo de constante mutable:</p> javascript<pre><code>const usuario = {\n  nombre: \"Ana\",\n  edad: 28\n};\n\nusuario.edad = 29;  // Esto es v\u00e1lido, ya que se modifica una propiedad, no la referencia\nconsole.log(usuario.edad);\n</code></pre>"},{"location":"javascript/variables/#conclusion","title":"Conclusi\u00f3n","text":"<p>Las variables en JavaScript son un componente esencial para gestionar datos en las aplicaciones. Comprender las diferencias entre <code>let</code>, <code>const</code> y <code>var</code>, as\u00ed como las pr\u00e1cticas recomendadas para nombrarlas e inicializarlas, las base para escribir un c\u00f3digo claro y eficiente.</p> <p>En el siguiente art\u00edculo abordaremos las diferencias espec\u00edficas entre <code>var</code>, <code>let</code> y <code>const</code>, profundizando en sus caracter\u00edsticas y mejores pr\u00e1cticas.</p> <p></p>"},{"location":"tutoriales/","title":"Tutoriales","text":"Tutoriales <p>PT Full Stack Development with JavaScript, Python, React</p> <p>\u00cdNDICE DE CONTENIDOS</p> <ol> <li>Ruta de aprendizaje:<ul> <li>Desarrollador Full Stack</li> </ul> </li> <li>Control de versiones:<ul> <li>Comandos GIT</li> </ul> </li> <li>Instalaci\u00f3n de librerias:<ul> <li>MkDocs + virtualenv</li> <li>Despliegue a GitHub Pages</li> </ul> </li> <li>Desarrollo web:<ul> <li>Optimizar el SEO</li> </ul> </li> </ol> <p> </p>"},{"location":"tutoriales/control-versiones/comandos-git/","title":"GIT desde la l\u00ednea de comandos","text":""},{"location":"tutoriales/control-versiones/comandos-git/#comandos-basicos-para-trabajar-en-localhost","title":"Comandos b\u00e1sicos para trabajar en localhost:","text":"<ul> <li>git init Iniciar GIT</li> <li>git add . Agrega todos los archivos al GIT</li> <li>git commit -m \"primer commit\" Agrega un commit al GIT</li> </ul>"},{"location":"tutoriales/control-versiones/comandos-git/#comandos-para-sincrinizar-por-primera-vez-git-con-github-desde-terminal-de-vscode","title":"Comandos para sincrinizar por primera vez GIT con GitHub desde terminal de VSCode:","text":"<ul> <li>git init Iniciar GIT</li> <li>git config --global user.name \"nombre_usuario\" Usuario de GitHub</li> <li>git config --global user.email \"micorreo@ejemplo.com\" Email de GitHub</li> </ul>"},{"location":"tutoriales/control-versiones/comandos-git/#comandos-basicos-para-subir-nuestro-proyecto-localhost-al-repositorio-de-github","title":"Comandos basicos para subir nuestro proyecto localhost al repositorio de GitHub:","text":"<ul> <li>git init Iniciar GIT</li> <li>git add . Agrega todos los archivos al GIT</li> <li>git commit -m \"primer commit\" Agrega un commit al GIT</li> <li>git branch -M main Fuerza a renombrar la rama local actual por (main) actual main</li> <li>git remote add origin https://github.com/usuario/mi_repositorio.git Crea una conexi\u00f3n remota llamada origin con el repositorio de GitHub</li> <li>git remote -v Verifica la comunicaci\u00f3n con el repositorio remoto</li> <li>git status Muestra el estado de los procesos GIT</li> <li>git push -u origin main Sube los archivos a la rama main remoto de GitHub</li> </ul>"},{"location":"tutoriales/control-versiones/comandos-git/#comandos-utiles","title":"Comandos \u00fatiles:","text":"<ul> <li>git status Muestra el estado de los procesos GIT</li> <li>git add ejemplo.html Agrega los archivos indibidualmente al GIT</li> <li>git remote -v Verifica la comunicaci\u00f3n con el repositorio remoto</li> <li>git log Muestra el hist\u00f3rico de commits</li> <li>git log -n 2 Muestra los \u00faltimos 2 commits</li> <li>git log prueba.html Muestra los commits del archivo (prueba.html)</li> <li>git switch main Cambia de la rama actual a la rama (main)</li> <li>git branch branch-test Crea una nueva rama (branch-test) a partir de la rama actual</li> <li>git branch -m branch-test Renombra la rama local actual por (branch-test) actual branch-test</li> <li>git branch -M branch-test Fuerza a renombrar la rama local actual por (branch-test) actual branch-test</li> <li>git branch Muestra todas las ramas locales y distingue con un (*) la rama actual</li> <li>git branch --list Muestra todas las ramas locales y distingue con un (*) la rama actual</li> <li>git branch -r Muestra todas las ramas del repositorio remoto</li> <li>git branch -a Muestra todas las ramas, tanto locales como remotas y distingue con un (*) la rama actual</li> <li>git branch --show-current Muestra la rama actual</li> <li>git branch -d branch-test Elimina la rama (branch-test) del repositorio local si esta fusionado con (main)</li> <li>git branch -D branch-test Fuerza a eliminar la rama (branch-test) del repositorio local este o no fusionado con (main)</li> <li>git branch --no-merged Muestra las ramas que estan sin fusionar con (main)</li> <li>git remote add origin https://github.com/usuario/mi_repositorio.git Crea una conexi\u00f3n remota llamada origin con el repositorio de GitHub</li> <li>git clone https://github.com/usuario/mi_repositorio.git Copia el repositorio remoto completo al local y se crea autom\u00e1ticamente una conexi\u00f3n remota llamada origin</li> <li>git pull origin main Actualiza la rama actual del repositorio local con los nuevos cambios efectuados en la rama (main) del repositorio remoto</li> <li>git merge branch-test Fusiona la rama (branch-test) a la rama actual del repositorio local</li> <li>git push origin --delete branch-test Elimina la rama (branch-test) del repositorio remoto</li> <li>git fetch --prune Elimina todas las referencias de seguimiento obsoletas del repositorio remoto</li> <li>git prune Elimina todas las referencias de seguimiento obsoletas del repositorio local</li> <li>git prune --verbose Elimina y muestra todas las referencias de seguimiento obsoletas que a eliminado del repositorio local</li> <li>git commit --amend -m \"texto corregido\" Edita el commit mas reciente y lo sustituye por uno nuevo</li> </ul>"},{"location":"tutoriales/control-versiones/comandos-git/#comandos-para-restaurar-o-resetear-a-un-commit-anterior-especifico","title":"Comandos para restaurar o resetear a un commit anterior espec\u00edfico:","text":"<ol> <li> <p>El m\u00e9todo (git restore): </p> <ul> <li>git log --oneline Muestra informaci\u00f3n simplificada de commits donde sale el hash de cada uno</li> <li>git restore --source 20cf9cb prueba.html Restaura el archivo (prueba.html) al commit mediante hash (20cf9cb)</li> </ul> </li> <li> <p>El m\u00e9todo (git reset):</p> <ul> <li>git log --oneline Muestra informaci\u00f3n simplificada de commits donde sale el hash de cada uno</li> <li>git reset 20cf9cb Regresa al commit mediante hash (20cf9cb)</li> </ul> <p>NOTA</p> <p>A pesar de que los commits ya no aparecen en el log, no se eliminan de GIT</p> <p></p> </li> </ol> <p>NOTA</p> <ul> <li>Para detener el servidor de \"mkdocs\" pulsa (ctrl + c)</li> <li>Para limpiar la consola utiliza el comando (cls) o (clear)</li> <li>Para salir de algun comando GIT pulsa (q)</li> </ul> <p>MALAS PR\u00c1CTICAS</p> <p>Est\u00e1 totalmente desaconsejado alterar el historial de commits, esto podria generar conflictos con los commits del repositorio remoto cuando se vaya hacer push o pull por cualquiera de los miembros, intenta siempre trabajar hacia adelante. Por lo general, est\u00e1 bien hacer este tipo de cambios en su propio repositorio local.</p> <p>BUENAS PR\u00c1CTICAS</p> <p>El mensaje del commit se escribe en presente, debe ser corto y conciso, no utilizar puntos ni puntos suspensivos al final.</p> <ol> <li>Ejemplo commit: <code>remove a random notification</code> </li> <li>Ejemplo commit: <code>add a new search feature</code></li> <li>Ejemplo commit: <code>change the default system color</code></li> <li>Ejemplo commit: <code>fix a problem with the topbar</code></li> </ol> <p></p> <p>Fuente: Sitio web oficial </p>"},{"location":"tutoriales/desarrollo-web/optimizar-seo/","title":"Optimizar el SEO","text":"<p>Antes de subir cualquier proyecto a producci\u00f3n, es importante comprobar que el SEO (Search Engine Optimization) este correctamente construido. Mencionare una herramienta gratuita que nos ayudara a testear nuestro SEO.</p>"},{"location":"tutoriales/desarrollo-web/optimizar-seo/#herramientas-online","title":"Herramientas online:","text":"<ul> <li>Open Graph es una herramienta que nos permitira ver la vista previa de la url compartida</li> <li>Squoosh es una herramienta de Google para editar y optimizar im\u00e1genes </li> </ul>"},{"location":"tutoriales/desarrollo-web/optimizar-seo/#la-importancia-del-orden","title":"La importancia del orden:","text":"<p>Para optimizar el SEO, es necesario seguir un orden espec\u00edfico dentro del head. Harry Roberts fue el creador de este orden. <pre><code>&lt;head&gt;\n  &lt;meta charset | http-equiv \\ viewport/&gt;\n  &lt;title&gt;&lt;/title&gt;\n  &lt;script src=\"\" async&gt;&lt;/script&gt;\n  CSS that icludes @import\n  Synchronous JS\n  Synchronous CSS\n  preload\n  &lt;script src=\"\" defer&gt;&lt;/script&gt;\n  prefetch / prerender\n  Everything else ('SEO' meta tags, icons, Open Graph, etc.)\n&lt;/head&gt;\n</code></pre></p>"},{"location":"tutoriales/desarrollo-web/optimizar-seo/#construccion-basica-del-head-con-el-seo-optimizado","title":"Construcci\u00f3n b\u00e1sica del head con el SEO optimizado:","text":"<ul> <li> <p>Aqu\u00ed la configuraci\u00f3n general del sitio web <pre><code>&lt;meta charset=\"UTF-8\"/&gt;\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/&gt;\nmas...\n</code></pre></p> </li> <li> <p>Aqu\u00ed la informaci\u00f3n general del sitio web <pre><code>&lt;title&gt;Documentaci\u00f3n t\u00e9cnica&lt;/title&gt;\n&lt;link rel=\"icon\" type=\"image/png\" href=\"src/img/favicon.png\"/&gt;\n&lt;meta name=\"description\"  content=\"Documentaci\u00f3n de proyectos, tutoriales de programaci\u00f3n, gu\u00edas de instalaci\u00f3n, todo en un \u00fanico lugar.\"/&gt;\nmas...\n</code></pre></p> </li> <li> <p>Aqu\u00ed la fuente de css y js <pre><code>&lt;link rel=\"stylesheet\" href=\"src/css/custom.css\"/&gt;\n&lt;script src=\"src/js/custom.js\"&gt;&lt;/script&gt;\nmas...\n</code></pre></p> </li> <li> <p>Aqu\u00ed el protocolo general de Open Graph que genera vista previa del enlace cuando es compartido.     <pre><code>&lt;meta property=\"og:url\" content=\"https://zuluta.github.io\"/&gt; &lt;!-- url a compartir --&gt;\n&lt;meta property=\"og:type\" content=\"website\"/&gt; &lt;!-- tipo de url a compartir --&gt;\n&lt;meta property=\"og:title\" content=\"Documentaci\u00f3n t\u00e9cnica\"/&gt; &lt;!-- t\u00edtulo de url a compartir --&gt;\n&lt;meta property=\"og:description\" content=\"Documentaci\u00f3n de proyectos, tutoriales de programaci\u00f3n, gu\u00edas de instalaci\u00f3n, todo en un \u00fanico lugar.\"/&gt; &lt;!-- descripci\u00f3n de url a compartir --&gt;\n&lt;meta property=\"og:image\" content=\"https://zuluta.github.io/og.jpg\"/&gt; &lt;!-- imagen de url a compartir --&gt;\n&lt;meta property=\"og:locale\" content=\"es_ES\"/&gt;\nmas...\n</code></pre></p> </li> </ul> <p>Ejemplo b\u00e1sico con el SEO optimizado<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n\n  &lt;!-- informaci\u00f3n que lee el navegador --&gt;\n  &lt;head&gt;\n\n    &lt;!-- configuraci\u00f3n general del sitio web --&gt;\n    &lt;meta charset=\"UTF-8\"/&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/&gt;\n\n    &lt;!-- informaci\u00f3n general del sitio web --&gt;\n    &lt;title&gt;Documentaci\u00f3n t\u00e9cnica&lt;/title&gt;\n    &lt;link rel=\"icon\" type=\"image/png\" href=\"src/img/favicon.png\"/&gt;\n    &lt;meta name=\"description\"  content=\"Documentaci\u00f3n de proyectos, tutoriales de programaci\u00f3n, gu\u00edas de instalaci\u00f3n, todo en un \u00fanico lugar.\"/&gt;\n\n    &lt;!-- fuente de css y js --&gt;\n    &lt;link rel=\"stylesheet\" href=\"src/css/custom.css\"/&gt;\n    &lt;script src=\"src/js/custom.js\"&gt;&lt;/script&gt;\n\n    &lt;!-- protocolo open graph --&gt;\n    &lt;meta property=\"og:url\" content=\"https://zuluta.github.io\"/&gt; &lt;!-- url a compartir --&gt;\n    &lt;meta property=\"og:type\" content=\"website\"/&gt; &lt;!-- tipo de url a compartir --&gt;\n    &lt;meta property=\"og:title\" content=\"Documentaci\u00f3n t\u00e9cnica\"/&gt; &lt;!-- t\u00edtulo de url a compartir --&gt;\n    &lt;meta property=\"og:description\" content=\"Documentaci\u00f3n de proyectos, tutoriales de programaci\u00f3n, gu\u00edas de instalaci\u00f3n, todo en un \u00fanico lugar.\"/&gt; &lt;!-- descripci\u00f3n de url a compartir --&gt;\n    &lt;meta property=\"og:image\" content=\"https://zuluta.github.io/docs/assets/images/og.png\"/&gt; &lt;!-- imagen de url a compartir --&gt;\n    &lt;meta property=\"og:locale\" content=\"es_ES\"/&gt;\n\n  &lt;/head&gt;\n\n  &lt;!-- contenido que ve el usuario --&gt;\n  &lt;body&gt;\n\n    &lt;!-- Esto mejora el rendimiento de la p\u00e1gina, primero carga el contenido HTML y luego el c\u00f3digo JavaScript --&gt;\n    &lt;script src=\"src/js/dictionary-builder.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre> Lo m\u00e1s normal es colocar los scripts Javascript justo antes del cierre de la etiqueta &lt;body&gt;</p> <p> </p>"},{"location":"tutoriales/instalacion-librerias/gh-deploy/","title":"Despliegue de proyecto local a GitHub Pages","text":"<p>01. Accede a GitHub y crea un repositorio nuevo.</p> <p> </p> <p>02. Escribe el mismo nombre del proyecto local, deja en p\u00fablico y pulsa el bot\u00f3n crear repositorio.</p> <p> </p> <p>03. Muestra los comandos y la URL remota del repositorio creado.</p> <p> </p> <p>04. Comandos para sincrinizar por primera vez GIT con GitHub desde la terminal de VSCode.</p> <ul> <li>(git init) Inicia el GIT</li> <li>(git config --global user.name \"nombre-usuario\") Usuario de GitHub</li> <li>(git config --global user.email \"micorreo@ejemplo.com\") Email de GitHub </li> </ul> <p>05. Comandos de terminal mas utilizados en GIT.</p> <ul> <li>(git init) Inicia el GIT</li> <li>(git add .) Agrega todos los archivos al GIT</li> <li>(git add ejemplo.html) Agrega los archivos indibidualmente al GIT</li> <li>(git commit -m \"inserta el mensaje aqui\") Agrega un commit al GIT</li> <li>(git branch -M main) Fuerza a renombrar la rama local actual por (main) actual main</li> <li>(git remote add origin https://github.com/usuario/mi-repositorio.git) Agrega la url remota del repositorio GitHub</li> <li>(git remote -v) Verifica la comunicaci\u00f3n con el repositorio remoto</li> <li>(git status) Muestra el estado de los procesos GIT</li> <li>(git push -u origin main) Sube los archivos a la rama main del repositorio GitHub</li> </ul> <p>El orden de ejecuci\u00f3n</p> <p>El orden de ejecuci\u00f3n, variara en funci\u00f3n de lo que quieras hacer. Por l\u00f3gica, primero se inicia el GIT, se agregan los archivos, se envia un commit, la verificaci\u00f3n de estado y la comunicaci\u00f3n con el repositorio solo nos da informaci\u00f3n, no hace ningun cambio en el repositorio.</p> <p></p> <p>06. Entra en VSCode y abre una terminal nueva.</p> <ul> <li>Desde la carpeta de trabajo \"proyecto-docs\", activa el entorno virtual (.envscriptsactivate)</li> <li>Accede a la carpeta del proyecto \"docs\" y lanza el comando (mkdocs build) para compilar, \u00e9sto creara una nueva carpeta llamada site donde compilara todo el proyecto.</li> </ul> <p> </p> <p>07. Desde la carpeta del proyecto \"docs\", abre la terminal y prepara el repositorio GIT para subir al repositorio GitHub.</p> <ul> <li>Ejecuta el comando (git init)</li> <li>Ejecuta el comando (git add .)</li> <li>Ejecuta el comando (git commit -m \"despliegue\")</li> <li>Ejecuta el comando (git branch -M main)</li> <li>Ejecuta el comando (git remote add origin https://github.com/zuluta/docs.git)</li> <li>Ejecuta el comando (git remote -v)</li> <li>Ejecuta el comando (git status)</li> <li>Ejecuta el comando (git push -u origin main)</li> </ul> <p>NOTA</p> <p>La rama \"master\" y \"main\" son lo mismo. Hace unos a\u00f1os, la comunidad de software decidi\u00f3 cambiar el nombre de la rama principal de master a main. Verifica con el comando (git branch) las ramas existentes en tu repositorio local y si existe la rama master, pasa a la rama master con el comando (git switch master) y cambia el nombre de la rama con el comando (git branch -m main) o (git branch -M main) para forzarlo. De este modo, solo se dejara una rama principal con el nombre \"main\" por repositorio.</p> <p> </p> <p>08. Entra al repositorio y verifica si se subieron bien los archivos a GitHub en la rama main.</p> <p> </p> <p>09. GitHub permite crear una pagina web gratis desde el repositorio.</p> <ul> <li>Ejecuta el comando (mkdocs gh-deploy)</li> </ul> <p>Este comando es espec\u00edfico de mkdocs para GitHub. Este comando creara de forma autom\u00e1tica una nueva rama gh-pages en el mismo repositorio del proyecto para poder desplegar GitHub Pages.</p> <p>10. Entra al repositorio de GitHub y verifica si se creo la rama \"gh-pages\".</p> <p> </p> <p>11. Entra en Settings, luego en Pages, donde pone Branch, selecciona la rama \"gh-pages\" y la carpeta \"(root)\". Pulsa el bot\u00f3n de guardar y espera unos segundos a que se active la p\u00e1gina.</p> <p> </p> <p>12. Entra en Settings, luego en Pages, donde pone GitHub Pages, verifica que la p\u00e1gina este operativa.</p> <p> </p> <p>13. Si necesitas actualizar GitHub Pages por nuevos cambios, ejecuta lo siguiente.</p> <ul> <li>Desde la carpeta de trabajo \"proyecto-docs\", activa el entorno virtual (.envscriptsactivate)</li> <li>Accede a la carpeta del proyecto \"docs\" y lanza el comando (mkdocs build)</li> <li>Ejecuta el comando (git init)</li> <li>Ejecuta el comando (git add .)</li> <li>Ejecuta el comando (git commit -m \"actualizar contenido\")</li> <li>Ejecuta el comando (git branch)</li> <li>Ejecuta el comando (git switch main)</li> <li>Ejecuta el comando (git remote add origin https://github.com/zuluta/docs.git)</li> <li>Ejecuta el comando (git remote -v)</li> <li>Ejecuta el comando (git status)</li> <li>Ejecuta el comando (git push -u origin main) Se sube a la rama \"main\" del repositorio donde se guarda el proyecto</li> <li>Ejecuta el comando (mkdocs gh-deploy) Compila y despliega a la rama \"gh-pages\" del repositorio. \u00c9sta rama, va enlazado al sitio web de GitHub Pages</li> <li>Verifica los cambios en la p\u00e1gina  </li> </ul>"},{"location":"tutoriales/instalacion-librerias/mkdocs/","title":"Instalar MkDocs con Python y virtualenv","text":"<p>01. Verifica si Python y virtualenv est\u00e1n instalados de forma global y si no aparecen, instalalos.</p> <p> </p> <p>02. Entra en \u201cescritorio\u201d y crea una carpeta de trabajo que se llame (proyecto-docs) con el comando (mkdir proyecto-docs).</p> <p>03. Entra en \u201cproyecto-docs\u201d y crea una carpeta virtual que se llame (env).</p> <p>04. Act\u00edva la carpeta \u201cenv\u201d en modo virtual con el comando (.\\env\\scripts\\activate).</p> <p>05. Instala la librer\u00eda dentro de la carpeta \u201cenv\u201d con el comando (pip install mkdocs).</p> <p> </p> <p>06. Verifica si la librer\u00eda mkdocs se instal\u00f3 bien.</p> <p> </p> <p>07. Crea nuevo proyecto de mkdocs que se llame (mi-documentacion).</p> <p>08. Verifica si el proyecto se cre\u00f3 bien y desactiva el entorno virtual con el comando (deactivate). Cierra la terminal.</p> <p> </p> <p>09. Abre VSCode y carga la carpeta del escritorio \u201cproyecto-docs\u201d desde el menu superior (Archivo / Abrir carpeta\u2026).</p> <p> </p> <p>10. Dentro del proyecto \u201cmi-documentacion\u201d, abre el archivo que pone index.md.</p> <p>11. Abre una nueva terminal desde el menu superior (... / Terminal / Nuevo terminal) para ejecutar el servidor en local. Recordar que la librer\u00eda mkdocs se instal\u00f3 en un entorno virtual por lo que sera necesario primero activar el entorno virtual desde la carpeta de trabajo \u201cproyecto-docs\u201d con el comando (.\\env\\Scripts\\activate). Luego entra en la carpeta del proyecto \u201cmi-documentaci\u00f3n\u201d y desde ah\u00ed, ejecutar el siguiente comando (mkdocs serve), esto ejecutara el servidor local.</p> <p> </p> <p>12. Para verificar, copia la URL del servidor y abre en el navegador, le aparecer\u00e1 la p\u00e1gina de bienvenida por defecto.</p> <p> </p> <p>13. Con esto, ya tendrias instalado la librer\u00eda mkdocs en un entorno virtual y creado el proyecto para empezar a editar tu propia documentaci\u00f3n, porfolio, o lo que quieras de forma local.</p> <p>14. Ahora que ya tenemos mkdocs en marcha, toca instalar un tema desarrollado para mkdocs que le va dar un dise\u00f1o mucho mas moderno. Abre la terminal de VSCode, pulsa (ctrl + c) para detener el servidor, activa el entorno virtual, accede a la carpeta \u201cmi-documentaci\u00f3n\u201d y desde ah\u00ed ejecuta el comando (pip install mkdocs-material). Una vez terminada la instalaci\u00f3n, abre el archivo \u201cmkdocs.yml\u201d y modifica el nombre del tema. En este caso, se llama material. El tema que viene instalado por defecto se llama \u201creadthedocs\u201d.</p> <p> </p> <p>15. Para finalizar, recarga la p\u00e1gina y veras un aspecto mucho mas moderno de tu sitio web.</p> <p> </p>"},{"location":"tutoriales/ruta-aprendizaje/desarrollador-full-stack/","title":"Desarrollador Full Stack","text":"<p>El programador Full Stack es el profesional encargado de desarrollar p\u00e1ginas web, tanto en el FRONTEND como en el BACKEND. Para desempe\u00f1ar sus funciones, que incluyen desde el dise\u00f1o de interfaces hasta el desarrollo de arquitecturas y la optimizaci\u00f3n del sitio web, debe combinar una serie de conocimientos t\u00e9cnicos y creativos.</p>"},{"location":"tutoriales/ruta-aprendizaje/desarrollador-full-stack/#diagrama","title":"Diagrama","text":"<p>Creado con app.diagrams.net </p>"}]}